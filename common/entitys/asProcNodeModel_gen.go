// Code generated by goctl. DO NOT EDIT!

package entitys

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	asProcNodeFieldNames          = builder.RawFieldNames(&AsProcNode{})
	asProcNodeRows                = strings.Join(asProcNodeFieldNames, ",")
	asProcNodeRowsExpectAutoSet   = strings.Join(stringx.Remove(asProcNodeFieldNames, "`create_time`", "`update_time`"), ",")
	asProcNodeRowsWithPlaceHolder = strings.Join(stringx.Remove(asProcNodeFieldNames, "`id`", "`create_time`", "`update_time`"), "=?,") + "=?"

	cacheAssetAsProcNodeIdPrefix = "cache:asset:asProcNode:id:"
)

type (
	asProcNodeModel interface {
		Insert(ctx context.Context, data *AsProcNode) (sql.Result, error)
		FindOne(ctx context.Context, id string) (*AsProcNode, error)
		Update(ctx context.Context, data *AsProcNode) error
		Delete(ctx context.Context, id string) error
	}

	defaultAsProcNodeModel struct {
		sqlc.CachedConn
		table string
	}

	AsProcNode struct {
		Id               string         `db:"id"`
		ProcModelId      string         `db:"proc_model_id"`
		NodeId           string         `db:"node_id"`
		NodeType         int64          `db:"node_type"`         // 1经办，2审批，3抄送
		CandidateUser    sql.NullString `db:"candidate_user"`    // 处理人
		CandidateGroup   sql.NullString `db:"candidate_group"`   // 处理组，这里应该设置成json数据，可以包含复杂数据，比如排除掉某个组里的某些人或者某个组里的某些小组（这个暂时不做，先留个接口在这里）
		LimitTime        sql.NullTime   `db:"limit_time"`        // 处理该节点事项的限时，目前暂时只做审批节点超过限时后，转交其他人处理或者直接流到下一节点
		OvertimeStrategy sql.NullInt64  `db:"overtime_strategy"` // 节点如果超时之后的处理方式：0：交由系统管理员处理1：自动到下一节点
		SignStrategy     sql.NullString `db:"sign_strategy"`     // 这是设置节点多人审批的策略，用json格式存储实现复杂规则
		TodoStrategy     sql.NullString `db:"todo_strategy"`     // 这是设置节点多人处理经办节点的策略，用json格式存储实现复杂规则
		IfJointSign      sql.NullInt64  `db:"if_joint_sign"`     // 判断是否是多人会签节点0：不是会签1：是会签，串行2：是会签，并行
		ApproveType      sql.NullInt64  `db:"approve_type"`      // 在当前节点是审批节点的情况下，该属性表示在这个审批节点上点击“不同意”执行的策略：0表示——当前实例被结束（默认情况）1表示——回滚到上一个经办节点2表示——由审批人选择回滚到任意一个经办节点3表示——实例继续执行（某些情况下审批不同意任需执行）
		Version          sql.NullInt64  `db:"version"`
	}
)

func newAsProcNodeModel(conn sqlx.SqlConn, c cache.CacheConf) *defaultAsProcNodeModel {
	return &defaultAsProcNodeModel{
		CachedConn: sqlc.NewConn(conn, c),
		table:      "`as_proc_node`",
	}
}

func (m *defaultAsProcNodeModel) Insert(ctx context.Context, data *AsProcNode) (sql.Result, error) {
	assetAsProcNodeIdKey := fmt.Sprintf("%s%v", cacheAssetAsProcNodeIdPrefix, data.Id)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, asProcNodeRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.Id, data.ProcModelId, data.NodeId, data.NodeType, data.CandidateUser, data.CandidateGroup, data.LimitTime, data.OvertimeStrategy, data.SignStrategy, data.TodoStrategy, data.IfJointSign, data.ApproveType, data.Version)
	}, assetAsProcNodeIdKey)
	return ret, err
}

func (m *defaultAsProcNodeModel) FindOne(ctx context.Context, id string) (*AsProcNode, error) {
	assetAsProcNodeIdKey := fmt.Sprintf("%s%v", cacheAssetAsProcNodeIdPrefix, id)
	var resp AsProcNode
	err := m.QueryRowCtx(ctx, &resp, assetAsProcNodeIdKey, func(ctx context.Context, conn sqlx.SqlConn, v interface{}) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", asProcNodeRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultAsProcNodeModel) Update(ctx context.Context, data *AsProcNode) error {
	assetAsProcNodeIdKey := fmt.Sprintf("%s%v", cacheAssetAsProcNodeIdPrefix, data.Id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, asProcNodeRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, data.ProcModelId, data.NodeId, data.NodeType, data.CandidateUser, data.CandidateGroup, data.LimitTime, data.OvertimeStrategy, data.SignStrategy, data.TodoStrategy, data.IfJointSign, data.ApproveType, data.Version, data.Id)
	}, assetAsProcNodeIdKey)
	return err
}

func (m *defaultAsProcNodeModel) Delete(ctx context.Context, id string) error {
	assetAsProcNodeIdKey := fmt.Sprintf("%s%v", cacheAssetAsProcNodeIdPrefix, id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, assetAsProcNodeIdKey)
	return err
}

func (m *defaultAsProcNodeModel) formatPrimary(primary interface{}) string {
	return fmt.Sprintf("%s%v", cacheAssetAsProcNodeIdPrefix, primary)
}

func (m *defaultAsProcNodeModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary interface{}) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", asProcNodeRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultAsProcNodeModel) tableName() string {
	return m.table
}

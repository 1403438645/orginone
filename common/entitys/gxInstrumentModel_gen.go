// Code generated by goctl. DO NOT EDIT!

package entitys

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	gxInstrumentFieldNames          = builder.RawFieldNames(&GxInstrument{})
	gxInstrumentRows                = strings.Join(gxInstrumentFieldNames, ",")
	gxInstrumentRowsExpectAutoSet   = strings.Join(stringx.Remove(gxInstrumentFieldNames, "`create_time`", "`update_time`"), ",")
	gxInstrumentRowsWithPlaceHolder = strings.Join(stringx.Remove(gxInstrumentFieldNames, "`id`", "`create_time`", "`update_time`"), "=?,") + "=?"

	cacheAssetGxInstrumentIdPrefix = "cache:asset:gxInstrument:id:"
)

type (
	gxInstrumentModel interface {
		Insert(ctx context.Context, data *GxInstrument) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*GxInstrument, error)
		Update(ctx context.Context, data *GxInstrument) error
		Delete(ctx context.Context, id int64) error
	}

	defaultGxInstrumentModel struct {
		sqlc.CachedConn
		table string
	}

	GxInstrument struct {
		Id               int64     `db:"id"`
		Gs1Code          string    `db:"gs1_code"`
		Name             string    `db:"name"`
		EnglishName      string    `db:"english_name"`
		AssetCode        string    `db:"asset_code"`
		UniCode          string    `db:"uni_code"`
		OrgCode          string    `db:"org_code"`
		RgCode           string    `db:"rg_code"`
		InstrBelongsType string    `db:"instr_belongs_type"`
		InstrBelongsName string    `db:"instr_belongs_name"`
		InstrCategory    string    `db:"instr_category"`
		ResourceName     string    `db:"resource_name"`
		InstrSource      string    `db:"instr_source"`
		InstrSupervise   int64     `db:"instr_supervise"`
		OriginalValue    float64   `db:"original_value"`
		Nation           string    `db:"nation"`
		Manufacturer     string    `db:"manufacturer"`
		BeginDate        time.Time `db:"begin_date"`
		Tp               string    `db:"tp"`
		InstrVersion     string    `db:"instr_version"`
		Technical        string    `db:"technical"`
		Function         string    `db:"function"`
		Subject          string    `db:"subject"`
		ServiceContent   string    `db:"service_content"`
		Requirement      string    `db:"requirement"`
		Fee              string    `db:"fee"`
		ServiceUrl       string    `db:"service_url"`
		Province         string    `db:"province"`
		City             string    `db:"city"`
		County           string    `db:"county"`
		Street           string    `db:"street"`
		Username         string    `db:"username"`
		PostalCode       string    `db:"postal_code"`
		ImageUrl         string    `db:"image_url"`
		Funds            string    `db:"funds"`
		ProjectType      string    `db:"project_type"`
		ProjectName      string    `db:"project_name"`
		PorjectCode      string    `db:"porject_code"`
		InstrumenId      string    `db:"instrumen_id"`
		Institute        string    `db:"institute"`
		GmtCreate        time.Time `db:"gmt_create"`
		GmtModify        time.Time `db:"gmt_modify"`
		IsDelete         time.Time `db:"is_delete"`
	}
)

func newGxInstrumentModel(conn sqlx.SqlConn, c cache.CacheConf) *defaultGxInstrumentModel {
	return &defaultGxInstrumentModel{
		CachedConn: sqlc.NewConn(conn, c),
		table:      "`gx_instrument`",
	}
}

func (m *defaultGxInstrumentModel) Insert(ctx context.Context, data *GxInstrument) (sql.Result, error) {
	assetGxInstrumentIdKey := fmt.Sprintf("%s%v", cacheAssetGxInstrumentIdPrefix, data.Id)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, gxInstrumentRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.Id, data.Gs1Code, data.Name, data.EnglishName, data.AssetCode, data.UniCode, data.OrgCode, data.RgCode, data.InstrBelongsType, data.InstrBelongsName, data.InstrCategory, data.ResourceName, data.InstrSource, data.InstrSupervise, data.OriginalValue, data.Nation, data.Manufacturer, data.BeginDate, data.Tp, data.InstrVersion, data.Technical, data.Function, data.Subject, data.ServiceContent, data.Requirement, data.Fee, data.ServiceUrl, data.Province, data.City, data.County, data.Street, data.Username, data.PostalCode, data.ImageUrl, data.Funds, data.ProjectType, data.ProjectName, data.PorjectCode, data.InstrumenId, data.Institute, data.GmtCreate, data.GmtModify, data.IsDelete)
	}, assetGxInstrumentIdKey)
	return ret, err
}

func (m *defaultGxInstrumentModel) FindOne(ctx context.Context, id int64) (*GxInstrument, error) {
	assetGxInstrumentIdKey := fmt.Sprintf("%s%v", cacheAssetGxInstrumentIdPrefix, id)
	var resp GxInstrument
	err := m.QueryRowCtx(ctx, &resp, assetGxInstrumentIdKey, func(ctx context.Context, conn sqlx.SqlConn, v interface{}) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", gxInstrumentRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultGxInstrumentModel) Update(ctx context.Context, data *GxInstrument) error {
	assetGxInstrumentIdKey := fmt.Sprintf("%s%v", cacheAssetGxInstrumentIdPrefix, data.Id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, gxInstrumentRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, data.Gs1Code, data.Name, data.EnglishName, data.AssetCode, data.UniCode, data.OrgCode, data.RgCode, data.InstrBelongsType, data.InstrBelongsName, data.InstrCategory, data.ResourceName, data.InstrSource, data.InstrSupervise, data.OriginalValue, data.Nation, data.Manufacturer, data.BeginDate, data.Tp, data.InstrVersion, data.Technical, data.Function, data.Subject, data.ServiceContent, data.Requirement, data.Fee, data.ServiceUrl, data.Province, data.City, data.County, data.Street, data.Username, data.PostalCode, data.ImageUrl, data.Funds, data.ProjectType, data.ProjectName, data.PorjectCode, data.InstrumenId, data.Institute, data.GmtCreate, data.GmtModify, data.IsDelete, data.Id)
	}, assetGxInstrumentIdKey)
	return err
}

func (m *defaultGxInstrumentModel) Delete(ctx context.Context, id int64) error {
	assetGxInstrumentIdKey := fmt.Sprintf("%s%v", cacheAssetGxInstrumentIdPrefix, id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, assetGxInstrumentIdKey)
	return err
}

func (m *defaultGxInstrumentModel) formatPrimary(primary interface{}) string {
	return fmt.Sprintf("%s%v", cacheAssetGxInstrumentIdPrefix, primary)
}

func (m *defaultGxInstrumentModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary interface{}) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", gxInstrumentRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultGxInstrumentModel) tableName() string {
	return m.table
}

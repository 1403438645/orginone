// Code generated by entc, DO NOT EDIT.

package schema

import (
	"errors"
	"fmt"
	"orginone/common/schema/asallgroup"
	"orginone/common/schema/asappgroupdistributiondata"
	"orginone/common/schema/asdict"
	"orginone/common/schema/asgrouptenantrelations"
	"orginone/common/schema/asinneragency"
	"orginone/common/schema/asinputdata"
	"orginone/common/schema/asjob"
	"orginone/common/schema/aslayer"
	"orginone/common/schema/asmarketapp"
	"orginone/common/schema/asmarketappalert"
	"orginone/common/schema/asmarketappcomponent"
	"orginone/common/schema/asmarketappcomponenttemplate"
	"orginone/common/schema/asmarketappgroupdistribution"
	"orginone/common/schema/asmarketappgroupdistributionrelation"
	"orginone/common/schema/asmarketappkeysecret"
	"orginone/common/schema/asmarketappnotice"
	"orginone/common/schema/asmarketapppurchase"
	"orginone/common/schema/asmarketapprole"
	"orginone/common/schema/asmarketappusertemplate"
	"orginone/common/schema/asmarketmenu"
	"orginone/common/schema/asmarketmenuusersort"
	"orginone/common/schema/asmarketroledistribution"
	"orginone/common/schema/asmarketrolemenu"
	"orginone/common/schema/asmarketusedapp"
	"orginone/common/schema/asmenu"
	"orginone/common/schema/asperson"
	"orginone/common/schema/aspersonsingle"
	"orginone/common/schema/asproperties"
	"orginone/common/schema/aspropertiesdistribution"
	"orginone/common/schema/asredeploydata"
	"orginone/common/schema/asrole"
	"orginone/common/schema/astenant"
	"orginone/common/schema/astenantattr"
	"orginone/common/schema/astenantattrrole"
	"orginone/common/schema/astenanticon"
	"orginone/common/schema/asunit"
	"orginone/common/schema/asuser"
	"orginone/common/schema/asworkingdata"
	"orginone/common/schema/baseinfoadministrativeareaall"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// ent aliases to avoid import conflicts in user's code.
type (
	Op         = ent.Op
	Hook       = ent.Hook
	Value      = ent.Value
	Query      = ent.Query
	Policy     = ent.Policy
	Mutator    = ent.Mutator
	Mutation   = ent.Mutation
	MutateFunc = ent.MutateFunc
)

// OrderFunc applies an ordering on the sql selector.
type OrderFunc func(*sql.Selector)

// columnChecker returns a function indicates if the column exists in the given column.
func columnChecker(table string) func(string) error {
	checks := map[string]func(string) bool{
		asallgroup.Table:                           asallgroup.ValidColumn,
		asappgroupdistributiondata.Table:           asappgroupdistributiondata.ValidColumn,
		asdict.Table:                               asdict.ValidColumn,
		asgrouptenantrelations.Table:               asgrouptenantrelations.ValidColumn,
		asinneragency.Table:                        asinneragency.ValidColumn,
		asinputdata.Table:                          asinputdata.ValidColumn,
		asjob.Table:                                asjob.ValidColumn,
		aslayer.Table:                              aslayer.ValidColumn,
		asmarketapp.Table:                          asmarketapp.ValidColumn,
		asmarketappalert.Table:                     asmarketappalert.ValidColumn,
		asmarketappcomponent.Table:                 asmarketappcomponent.ValidColumn,
		asmarketappcomponenttemplate.Table:         asmarketappcomponenttemplate.ValidColumn,
		asmarketappgroupdistribution.Table:         asmarketappgroupdistribution.ValidColumn,
		asmarketappgroupdistributionrelation.Table: asmarketappgroupdistributionrelation.ValidColumn,
		asmarketappkeysecret.Table:                 asmarketappkeysecret.ValidColumn,
		asmarketappnotice.Table:                    asmarketappnotice.ValidColumn,
		asmarketapppurchase.Table:                  asmarketapppurchase.ValidColumn,
		asmarketapprole.Table:                      asmarketapprole.ValidColumn,
		asmarketappusertemplate.Table:              asmarketappusertemplate.ValidColumn,
		asmarketmenu.Table:                         asmarketmenu.ValidColumn,
		asmarketmenuusersort.Table:                 asmarketmenuusersort.ValidColumn,
		asmarketroledistribution.Table:             asmarketroledistribution.ValidColumn,
		asmarketrolemenu.Table:                     asmarketrolemenu.ValidColumn,
		asmarketusedapp.Table:                      asmarketusedapp.ValidColumn,
		asmenu.Table:                               asmenu.ValidColumn,
		asperson.Table:                             asperson.ValidColumn,
		aspersonsingle.Table:                       aspersonsingle.ValidColumn,
		asproperties.Table:                         asproperties.ValidColumn,
		aspropertiesdistribution.Table:             aspropertiesdistribution.ValidColumn,
		asredeploydata.Table:                       asredeploydata.ValidColumn,
		asrole.Table:                               asrole.ValidColumn,
		astenant.Table:                             astenant.ValidColumn,
		astenantattr.Table:                         astenantattr.ValidColumn,
		astenantattrrole.Table:                     astenantattrrole.ValidColumn,
		astenanticon.Table:                         astenanticon.ValidColumn,
		asunit.Table:                               asunit.ValidColumn,
		asuser.Table:                               asuser.ValidColumn,
		asworkingdata.Table:                        asworkingdata.ValidColumn,
		baseinfoadministrativeareaall.Table:        baseinfoadministrativeareaall.ValidColumn,
	}
	check, ok := checks[table]
	if !ok {
		return func(string) error {
			return fmt.Errorf("unknown table %q", table)
		}
	}
	return func(column string) error {
		if !check(column) {
			return fmt.Errorf("unknown column %q for table %q", column, table)
		}
		return nil
	}
}

// Asc applies the given fields in ASC order.
func Asc(fields ...string) OrderFunc {
	return func(s *sql.Selector) {
		check := columnChecker(s.TableName())
		for _, f := range fields {
			if err := check(f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("schema: %w", err)})
			}
			s.OrderBy(sql.Asc(s.C(f)))
		}
	}
}

// Desc applies the given fields in DESC order.
func Desc(fields ...string) OrderFunc {
	return func(s *sql.Selector) {
		check := columnChecker(s.TableName())
		for _, f := range fields {
			if err := check(f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("schema: %w", err)})
			}
			s.OrderBy(sql.Desc(s.C(f)))
		}
	}
}

// AggregateFunc applies an aggregation step on the group-by traversal/selector.
type AggregateFunc func(*sql.Selector) string

// As is a pseudo aggregation function for renaming another other functions with custom names. For example:
//
//	GroupBy(field1, field2).
//	Aggregate(schema.As(schema.Sum(field1), "sum_field1"), (schema.As(schema.Sum(field2), "sum_field2")).
//	Scan(ctx, &v)
//
func As(fn AggregateFunc, end string) AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.As(fn(s), end)
	}
}

// Count applies the "count" aggregation function on each group.
func Count() AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.Count("*")
	}
}

// Max applies the "max" aggregation function on the given field of each group.
func Max(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("schema: %w", err)})
			return ""
		}
		return sql.Max(s.C(field))
	}
}

// Mean applies the "mean" aggregation function on the given field of each group.
func Mean(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("schema: %w", err)})
			return ""
		}
		return sql.Avg(s.C(field))
	}
}

// Min applies the "min" aggregation function on the given field of each group.
func Min(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("schema: %w", err)})
			return ""
		}
		return sql.Min(s.C(field))
	}
}

// Sum applies the "sum" aggregation function on the given field of each group.
func Sum(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("schema: %w", err)})
			return ""
		}
		return sql.Sum(s.C(field))
	}
}

// ValidationError returns when validating a field or edge fails.
type ValidationError struct {
	Name string // Field or edge name.
	err  error
}

// Error implements the error interface.
func (e *ValidationError) Error() string {
	return e.err.Error()
}

// Unwrap implements the errors.Wrapper interface.
func (e *ValidationError) Unwrap() error {
	return e.err
}

// IsValidationError returns a boolean indicating whether the error is a validation error.
func IsValidationError(err error) bool {
	if err == nil {
		return false
	}
	var e *ValidationError
	return errors.As(err, &e)
}

// NotFoundError returns when trying to fetch a specific entity and it was not found in the database.
type NotFoundError struct {
	label string
}

// Error implements the error interface.
func (e *NotFoundError) Error() string {
	return "schema: " + e.label + " not found"
}

// IsNotFound returns a boolean indicating whether the error is a not found error.
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	var e *NotFoundError
	return errors.As(err, &e)
}

// MaskNotFound masks not found error.
func MaskNotFound(err error) error {
	if IsNotFound(err) {
		return nil
	}
	return err
}

// NotSingularError returns when trying to fetch a singular entity and more then one was found in the database.
type NotSingularError struct {
	label string
}

// Error implements the error interface.
func (e *NotSingularError) Error() string {
	return "schema: " + e.label + " not singular"
}

// IsNotSingular returns a boolean indicating whether the error is a not singular error.
func IsNotSingular(err error) bool {
	if err == nil {
		return false
	}
	var e *NotSingularError
	return errors.As(err, &e)
}

// NotLoadedError returns when trying to get a node that was not loaded by the query.
type NotLoadedError struct {
	edge string
}

// Error implements the error interface.
func (e *NotLoadedError) Error() string {
	return "schema: " + e.edge + " edge was not loaded"
}

// IsNotLoaded returns a boolean indicating whether the error is a not loaded error.
func IsNotLoaded(err error) bool {
	if err == nil {
		return false
	}
	var e *NotLoadedError
	return errors.As(err, &e)
}

// ConstraintError returns when trying to create/update one or more entities and
// one or more of their constraints failed. For example, violation of edge or
// field uniqueness.
type ConstraintError struct {
	msg  string
	wrap error
}

// Error implements the error interface.
func (e ConstraintError) Error() string {
	return "schema: constraint failed: " + e.msg
}

// Unwrap implements the errors.Wrapper interface.
func (e *ConstraintError) Unwrap() error {
	return e.wrap
}

// IsConstraintError returns a boolean indicating whether the error is a constraint failure.
func IsConstraintError(err error) bool {
	if err == nil {
		return false
	}
	var e *ConstraintError
	return errors.As(err, &e)
}

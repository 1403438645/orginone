// Code generated by entc, DO NOT EDIT.

package asmarketapp

import (
	"orginone/common/schema/predicate"
	"orginone/common/tools/date"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// ID filters vertices based on their ID field.
func ID(id int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// AppName applies equality check predicate on the "app_name" field. It's identical to AppNameEQ.
func AppName(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppName), v))
	})
}

// Icon applies equality check predicate on the "icon" field. It's identical to IconEQ.
func Icon(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIcon), v))
	})
}

// Version applies equality check predicate on the "version" field. It's identical to VersionEQ.
func Version(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldVersion), v))
	})
}

// Contact applies equality check predicate on the "contact" field. It's identical to ContactEQ.
func Contact(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldContact), v))
	})
}

// ContactName applies equality check predicate on the "contact_name" field. It's identical to ContactNameEQ.
func ContactName(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldContactName), v))
	})
}

// Description applies equality check predicate on the "description" field. It's identical to DescriptionEQ.
func Description(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDescription), v))
	})
}

// File applies equality check predicate on the "file" field. It's identical to FileEQ.
func File(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFile), v))
	})
}

// SaleStatus applies equality check predicate on the "sale_status" field. It's identical to SaleStatusEQ.
func SaleStatus(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSaleStatus), v))
	})
}

// TenantID applies equality check predicate on the "tenant_id" field. It's identical to TenantIDEQ.
func TenantID(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTenantID), v))
	})
}

// Platform applies equality check predicate on the "platform" field. It's identical to PlatformEQ.
func Platform(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPlatform), v))
	})
}

// TargetUser applies equality check predicate on the "target_user" field. It's identical to TargetUserEQ.
func TargetUser(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTargetUser), v))
	})
}

// DeployStatus applies equality check predicate on the "deploy_status" field. It's identical to DeployStatusEQ.
func DeployStatus(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeployStatus), v))
	})
}

// DeployAddress applies equality check predicate on the "deploy_address" field. It's identical to DeployAddressEQ.
func DeployAddress(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeployAddress), v))
	})
}

// DeployType applies equality check predicate on the "deploy_type" field. It's identical to DeployTypeEQ.
func DeployType(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeployType), v))
	})
}

// PublishTime applies equality check predicate on the "publish_time" field. It's identical to PublishTimeEQ.
func PublishTime(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPublishTime), vc))
	})
}

// AppType applies equality check predicate on the "app_type" field. It's identical to AppTypeEQ.
func AppType(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppType), v))
	})
}

// ApplyTime applies equality check predicate on the "apply_time" field. It's identical to ApplyTimeEQ.
func ApplyTime(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApplyTime), vc))
	})
}

// AppAddress applies equality check predicate on the "app_address" field. It's identical to AppAddressEQ.
func AppAddress(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppAddress), v))
	})
}

// AppMail applies equality check predicate on the "app_mail" field. It's identical to AppMailEQ.
func AppMail(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppMail), v))
	})
}

// AppPhoto applies equality check predicate on the "app_photo" field. It's identical to AppPhotoEQ.
func AppPhoto(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppPhoto), v))
	})
}

// AppField applies equality check predicate on the "app_field" field. It's identical to AppFieldEQ.
func AppField(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppField), v))
	})
}

// AppCategory applies equality check predicate on the "app_category" field. It's identical to AppCategoryEQ.
func AppCategory(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppCategory), v))
	})
}

// AppProjectSource applies equality check predicate on the "app_project_source" field. It's identical to AppProjectSourceEQ.
func AppProjectSource(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppProjectSource), v))
	})
}

// AppStar applies equality check predicate on the "app_star" field. It's identical to AppStarEQ.
func AppStar(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppStar), v))
	})
}

// AppFoundsSource applies equality check predicate on the "app_founds_source" field. It's identical to AppFoundsSourceEQ.
func AppFoundsSource(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppFoundsSource), v))
	})
}

// InnerURL applies equality check predicate on the "inner_url" field. It's identical to InnerURLEQ.
func InnerURL(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldInnerURL), v))
	})
}

// OutURL applies equality check predicate on the "out_url" field. It's identical to OutURLEQ.
func OutURL(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOutURL), v))
	})
}

// ReformStatus applies equality check predicate on the "reform_status" field. It's identical to ReformStatusEQ.
func ReformStatus(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReformStatus), v))
	})
}

// OutIPURL applies equality check predicate on the "out_ip_url" field. It's identical to OutIPURLEQ.
func OutIPURL(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOutIPURL), v))
	})
}

// IsDeleted applies equality check predicate on the "is_deleted" field. It's identical to IsDeletedEQ.
func IsDeleted(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIsDeleted), v))
	})
}

// Status applies equality check predicate on the "status" field. It's identical to StatusEQ.
func Status(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// CreateUser applies equality check predicate on the "create_user" field. It's identical to CreateUserEQ.
func CreateUser(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateUser), v))
	})
}

// UpdateUser applies equality check predicate on the "update_user" field. It's identical to UpdateUserEQ.
func UpdateUser(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateUser), v))
	})
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), vc))
	})
}

// UpdateTime applies equality check predicate on the "update_time" field. It's identical to UpdateTimeEQ.
func UpdateTime(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), vc))
	})
}

// AppNameEQ applies the EQ predicate on the "app_name" field.
func AppNameEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppName), v))
	})
}

// AppNameNEQ applies the NEQ predicate on the "app_name" field.
func AppNameNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAppName), v))
	})
}

// AppNameIn applies the In predicate on the "app_name" field.
func AppNameIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAppName), v...))
	})
}

// AppNameNotIn applies the NotIn predicate on the "app_name" field.
func AppNameNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAppName), v...))
	})
}

// AppNameGT applies the GT predicate on the "app_name" field.
func AppNameGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAppName), v))
	})
}

// AppNameGTE applies the GTE predicate on the "app_name" field.
func AppNameGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAppName), v))
	})
}

// AppNameLT applies the LT predicate on the "app_name" field.
func AppNameLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAppName), v))
	})
}

// AppNameLTE applies the LTE predicate on the "app_name" field.
func AppNameLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAppName), v))
	})
}

// AppNameContains applies the Contains predicate on the "app_name" field.
func AppNameContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAppName), v))
	})
}

// AppNameHasPrefix applies the HasPrefix predicate on the "app_name" field.
func AppNameHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAppName), v))
	})
}

// AppNameHasSuffix applies the HasSuffix predicate on the "app_name" field.
func AppNameHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAppName), v))
	})
}

// AppNameIsNil applies the IsNil predicate on the "app_name" field.
func AppNameIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAppName)))
	})
}

// AppNameNotNil applies the NotNil predicate on the "app_name" field.
func AppNameNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAppName)))
	})
}

// AppNameEqualFold applies the EqualFold predicate on the "app_name" field.
func AppNameEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAppName), v))
	})
}

// AppNameContainsFold applies the ContainsFold predicate on the "app_name" field.
func AppNameContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAppName), v))
	})
}

// IconEQ applies the EQ predicate on the "icon" field.
func IconEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIcon), v))
	})
}

// IconNEQ applies the NEQ predicate on the "icon" field.
func IconNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIcon), v))
	})
}

// IconIn applies the In predicate on the "icon" field.
func IconIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldIcon), v...))
	})
}

// IconNotIn applies the NotIn predicate on the "icon" field.
func IconNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldIcon), v...))
	})
}

// IconGT applies the GT predicate on the "icon" field.
func IconGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldIcon), v))
	})
}

// IconGTE applies the GTE predicate on the "icon" field.
func IconGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldIcon), v))
	})
}

// IconLT applies the LT predicate on the "icon" field.
func IconLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldIcon), v))
	})
}

// IconLTE applies the LTE predicate on the "icon" field.
func IconLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldIcon), v))
	})
}

// IconContains applies the Contains predicate on the "icon" field.
func IconContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldIcon), v))
	})
}

// IconHasPrefix applies the HasPrefix predicate on the "icon" field.
func IconHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldIcon), v))
	})
}

// IconHasSuffix applies the HasSuffix predicate on the "icon" field.
func IconHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldIcon), v))
	})
}

// IconIsNil applies the IsNil predicate on the "icon" field.
func IconIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldIcon)))
	})
}

// IconNotNil applies the NotNil predicate on the "icon" field.
func IconNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldIcon)))
	})
}

// IconEqualFold applies the EqualFold predicate on the "icon" field.
func IconEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldIcon), v))
	})
}

// IconContainsFold applies the ContainsFold predicate on the "icon" field.
func IconContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldIcon), v))
	})
}

// VersionEQ applies the EQ predicate on the "version" field.
func VersionEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldVersion), v))
	})
}

// VersionNEQ applies the NEQ predicate on the "version" field.
func VersionNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldVersion), v))
	})
}

// VersionIn applies the In predicate on the "version" field.
func VersionIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldVersion), v...))
	})
}

// VersionNotIn applies the NotIn predicate on the "version" field.
func VersionNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldVersion), v...))
	})
}

// VersionGT applies the GT predicate on the "version" field.
func VersionGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldVersion), v))
	})
}

// VersionGTE applies the GTE predicate on the "version" field.
func VersionGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldVersion), v))
	})
}

// VersionLT applies the LT predicate on the "version" field.
func VersionLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldVersion), v))
	})
}

// VersionLTE applies the LTE predicate on the "version" field.
func VersionLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldVersion), v))
	})
}

// VersionContains applies the Contains predicate on the "version" field.
func VersionContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldVersion), v))
	})
}

// VersionHasPrefix applies the HasPrefix predicate on the "version" field.
func VersionHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldVersion), v))
	})
}

// VersionHasSuffix applies the HasSuffix predicate on the "version" field.
func VersionHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldVersion), v))
	})
}

// VersionIsNil applies the IsNil predicate on the "version" field.
func VersionIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldVersion)))
	})
}

// VersionNotNil applies the NotNil predicate on the "version" field.
func VersionNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldVersion)))
	})
}

// VersionEqualFold applies the EqualFold predicate on the "version" field.
func VersionEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldVersion), v))
	})
}

// VersionContainsFold applies the ContainsFold predicate on the "version" field.
func VersionContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldVersion), v))
	})
}

// ContactEQ applies the EQ predicate on the "contact" field.
func ContactEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldContact), v))
	})
}

// ContactNEQ applies the NEQ predicate on the "contact" field.
func ContactNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldContact), v))
	})
}

// ContactIn applies the In predicate on the "contact" field.
func ContactIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldContact), v...))
	})
}

// ContactNotIn applies the NotIn predicate on the "contact" field.
func ContactNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldContact), v...))
	})
}

// ContactGT applies the GT predicate on the "contact" field.
func ContactGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldContact), v))
	})
}

// ContactGTE applies the GTE predicate on the "contact" field.
func ContactGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldContact), v))
	})
}

// ContactLT applies the LT predicate on the "contact" field.
func ContactLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldContact), v))
	})
}

// ContactLTE applies the LTE predicate on the "contact" field.
func ContactLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldContact), v))
	})
}

// ContactContains applies the Contains predicate on the "contact" field.
func ContactContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldContact), v))
	})
}

// ContactHasPrefix applies the HasPrefix predicate on the "contact" field.
func ContactHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldContact), v))
	})
}

// ContactHasSuffix applies the HasSuffix predicate on the "contact" field.
func ContactHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldContact), v))
	})
}

// ContactIsNil applies the IsNil predicate on the "contact" field.
func ContactIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldContact)))
	})
}

// ContactNotNil applies the NotNil predicate on the "contact" field.
func ContactNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldContact)))
	})
}

// ContactEqualFold applies the EqualFold predicate on the "contact" field.
func ContactEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldContact), v))
	})
}

// ContactContainsFold applies the ContainsFold predicate on the "contact" field.
func ContactContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldContact), v))
	})
}

// ContactNameEQ applies the EQ predicate on the "contact_name" field.
func ContactNameEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldContactName), v))
	})
}

// ContactNameNEQ applies the NEQ predicate on the "contact_name" field.
func ContactNameNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldContactName), v))
	})
}

// ContactNameIn applies the In predicate on the "contact_name" field.
func ContactNameIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldContactName), v...))
	})
}

// ContactNameNotIn applies the NotIn predicate on the "contact_name" field.
func ContactNameNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldContactName), v...))
	})
}

// ContactNameGT applies the GT predicate on the "contact_name" field.
func ContactNameGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldContactName), v))
	})
}

// ContactNameGTE applies the GTE predicate on the "contact_name" field.
func ContactNameGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldContactName), v))
	})
}

// ContactNameLT applies the LT predicate on the "contact_name" field.
func ContactNameLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldContactName), v))
	})
}

// ContactNameLTE applies the LTE predicate on the "contact_name" field.
func ContactNameLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldContactName), v))
	})
}

// ContactNameContains applies the Contains predicate on the "contact_name" field.
func ContactNameContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldContactName), v))
	})
}

// ContactNameHasPrefix applies the HasPrefix predicate on the "contact_name" field.
func ContactNameHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldContactName), v))
	})
}

// ContactNameHasSuffix applies the HasSuffix predicate on the "contact_name" field.
func ContactNameHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldContactName), v))
	})
}

// ContactNameIsNil applies the IsNil predicate on the "contact_name" field.
func ContactNameIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldContactName)))
	})
}

// ContactNameNotNil applies the NotNil predicate on the "contact_name" field.
func ContactNameNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldContactName)))
	})
}

// ContactNameEqualFold applies the EqualFold predicate on the "contact_name" field.
func ContactNameEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldContactName), v))
	})
}

// ContactNameContainsFold applies the ContainsFold predicate on the "contact_name" field.
func ContactNameContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldContactName), v))
	})
}

// DescriptionEQ applies the EQ predicate on the "description" field.
func DescriptionEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDescription), v))
	})
}

// DescriptionNEQ applies the NEQ predicate on the "description" field.
func DescriptionNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDescription), v))
	})
}

// DescriptionIn applies the In predicate on the "description" field.
func DescriptionIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDescription), v...))
	})
}

// DescriptionNotIn applies the NotIn predicate on the "description" field.
func DescriptionNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDescription), v...))
	})
}

// DescriptionGT applies the GT predicate on the "description" field.
func DescriptionGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDescription), v))
	})
}

// DescriptionGTE applies the GTE predicate on the "description" field.
func DescriptionGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDescription), v))
	})
}

// DescriptionLT applies the LT predicate on the "description" field.
func DescriptionLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDescription), v))
	})
}

// DescriptionLTE applies the LTE predicate on the "description" field.
func DescriptionLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDescription), v))
	})
}

// DescriptionContains applies the Contains predicate on the "description" field.
func DescriptionContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDescription), v))
	})
}

// DescriptionHasPrefix applies the HasPrefix predicate on the "description" field.
func DescriptionHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDescription), v))
	})
}

// DescriptionHasSuffix applies the HasSuffix predicate on the "description" field.
func DescriptionHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDescription), v))
	})
}

// DescriptionIsNil applies the IsNil predicate on the "description" field.
func DescriptionIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDescription)))
	})
}

// DescriptionNotNil applies the NotNil predicate on the "description" field.
func DescriptionNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDescription)))
	})
}

// DescriptionEqualFold applies the EqualFold predicate on the "description" field.
func DescriptionEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDescription), v))
	})
}

// DescriptionContainsFold applies the ContainsFold predicate on the "description" field.
func DescriptionContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDescription), v))
	})
}

// FileEQ applies the EQ predicate on the "file" field.
func FileEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFile), v))
	})
}

// FileNEQ applies the NEQ predicate on the "file" field.
func FileNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFile), v))
	})
}

// FileIn applies the In predicate on the "file" field.
func FileIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFile), v...))
	})
}

// FileNotIn applies the NotIn predicate on the "file" field.
func FileNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFile), v...))
	})
}

// FileGT applies the GT predicate on the "file" field.
func FileGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFile), v))
	})
}

// FileGTE applies the GTE predicate on the "file" field.
func FileGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFile), v))
	})
}

// FileLT applies the LT predicate on the "file" field.
func FileLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFile), v))
	})
}

// FileLTE applies the LTE predicate on the "file" field.
func FileLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFile), v))
	})
}

// FileContains applies the Contains predicate on the "file" field.
func FileContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFile), v))
	})
}

// FileHasPrefix applies the HasPrefix predicate on the "file" field.
func FileHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFile), v))
	})
}

// FileHasSuffix applies the HasSuffix predicate on the "file" field.
func FileHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFile), v))
	})
}

// FileIsNil applies the IsNil predicate on the "file" field.
func FileIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFile)))
	})
}

// FileNotNil applies the NotNil predicate on the "file" field.
func FileNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFile)))
	})
}

// FileEqualFold applies the EqualFold predicate on the "file" field.
func FileEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFile), v))
	})
}

// FileContainsFold applies the ContainsFold predicate on the "file" field.
func FileContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFile), v))
	})
}

// SaleStatusEQ applies the EQ predicate on the "sale_status" field.
func SaleStatusEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSaleStatus), v))
	})
}

// SaleStatusNEQ applies the NEQ predicate on the "sale_status" field.
func SaleStatusNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSaleStatus), v))
	})
}

// SaleStatusIn applies the In predicate on the "sale_status" field.
func SaleStatusIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSaleStatus), v...))
	})
}

// SaleStatusNotIn applies the NotIn predicate on the "sale_status" field.
func SaleStatusNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSaleStatus), v...))
	})
}

// SaleStatusGT applies the GT predicate on the "sale_status" field.
func SaleStatusGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSaleStatus), v))
	})
}

// SaleStatusGTE applies the GTE predicate on the "sale_status" field.
func SaleStatusGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSaleStatus), v))
	})
}

// SaleStatusLT applies the LT predicate on the "sale_status" field.
func SaleStatusLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSaleStatus), v))
	})
}

// SaleStatusLTE applies the LTE predicate on the "sale_status" field.
func SaleStatusLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSaleStatus), v))
	})
}

// SaleStatusIsNil applies the IsNil predicate on the "sale_status" field.
func SaleStatusIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSaleStatus)))
	})
}

// SaleStatusNotNil applies the NotNil predicate on the "sale_status" field.
func SaleStatusNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSaleStatus)))
	})
}

// TenantIDEQ applies the EQ predicate on the "tenant_id" field.
func TenantIDEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTenantID), v))
	})
}

// TenantIDNEQ applies the NEQ predicate on the "tenant_id" field.
func TenantIDNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTenantID), v))
	})
}

// TenantIDIn applies the In predicate on the "tenant_id" field.
func TenantIDIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTenantID), v...))
	})
}

// TenantIDNotIn applies the NotIn predicate on the "tenant_id" field.
func TenantIDNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTenantID), v...))
	})
}

// TenantIDGT applies the GT predicate on the "tenant_id" field.
func TenantIDGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTenantID), v))
	})
}

// TenantIDGTE applies the GTE predicate on the "tenant_id" field.
func TenantIDGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTenantID), v))
	})
}

// TenantIDLT applies the LT predicate on the "tenant_id" field.
func TenantIDLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTenantID), v))
	})
}

// TenantIDLTE applies the LTE predicate on the "tenant_id" field.
func TenantIDLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTenantID), v))
	})
}

// TenantIDContains applies the Contains predicate on the "tenant_id" field.
func TenantIDContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTenantID), v))
	})
}

// TenantIDHasPrefix applies the HasPrefix predicate on the "tenant_id" field.
func TenantIDHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTenantID), v))
	})
}

// TenantIDHasSuffix applies the HasSuffix predicate on the "tenant_id" field.
func TenantIDHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTenantID), v))
	})
}

// TenantIDIsNil applies the IsNil predicate on the "tenant_id" field.
func TenantIDIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTenantID)))
	})
}

// TenantIDNotNil applies the NotNil predicate on the "tenant_id" field.
func TenantIDNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTenantID)))
	})
}

// TenantIDEqualFold applies the EqualFold predicate on the "tenant_id" field.
func TenantIDEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTenantID), v))
	})
}

// TenantIDContainsFold applies the ContainsFold predicate on the "tenant_id" field.
func TenantIDContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTenantID), v))
	})
}

// PlatformEQ applies the EQ predicate on the "platform" field.
func PlatformEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPlatform), v))
	})
}

// PlatformNEQ applies the NEQ predicate on the "platform" field.
func PlatformNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPlatform), v))
	})
}

// PlatformIn applies the In predicate on the "platform" field.
func PlatformIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPlatform), v...))
	})
}

// PlatformNotIn applies the NotIn predicate on the "platform" field.
func PlatformNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPlatform), v...))
	})
}

// PlatformGT applies the GT predicate on the "platform" field.
func PlatformGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPlatform), v))
	})
}

// PlatformGTE applies the GTE predicate on the "platform" field.
func PlatformGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPlatform), v))
	})
}

// PlatformLT applies the LT predicate on the "platform" field.
func PlatformLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPlatform), v))
	})
}

// PlatformLTE applies the LTE predicate on the "platform" field.
func PlatformLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPlatform), v))
	})
}

// PlatformIsNil applies the IsNil predicate on the "platform" field.
func PlatformIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPlatform)))
	})
}

// PlatformNotNil applies the NotNil predicate on the "platform" field.
func PlatformNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPlatform)))
	})
}

// TargetUserEQ applies the EQ predicate on the "target_user" field.
func TargetUserEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTargetUser), v))
	})
}

// TargetUserNEQ applies the NEQ predicate on the "target_user" field.
func TargetUserNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTargetUser), v))
	})
}

// TargetUserIn applies the In predicate on the "target_user" field.
func TargetUserIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTargetUser), v...))
	})
}

// TargetUserNotIn applies the NotIn predicate on the "target_user" field.
func TargetUserNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTargetUser), v...))
	})
}

// TargetUserGT applies the GT predicate on the "target_user" field.
func TargetUserGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTargetUser), v))
	})
}

// TargetUserGTE applies the GTE predicate on the "target_user" field.
func TargetUserGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTargetUser), v))
	})
}

// TargetUserLT applies the LT predicate on the "target_user" field.
func TargetUserLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTargetUser), v))
	})
}

// TargetUserLTE applies the LTE predicate on the "target_user" field.
func TargetUserLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTargetUser), v))
	})
}

// TargetUserIsNil applies the IsNil predicate on the "target_user" field.
func TargetUserIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTargetUser)))
	})
}

// TargetUserNotNil applies the NotNil predicate on the "target_user" field.
func TargetUserNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTargetUser)))
	})
}

// DeployStatusEQ applies the EQ predicate on the "deploy_status" field.
func DeployStatusEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeployStatus), v))
	})
}

// DeployStatusNEQ applies the NEQ predicate on the "deploy_status" field.
func DeployStatusNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDeployStatus), v))
	})
}

// DeployStatusIn applies the In predicate on the "deploy_status" field.
func DeployStatusIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDeployStatus), v...))
	})
}

// DeployStatusNotIn applies the NotIn predicate on the "deploy_status" field.
func DeployStatusNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDeployStatus), v...))
	})
}

// DeployStatusGT applies the GT predicate on the "deploy_status" field.
func DeployStatusGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDeployStatus), v))
	})
}

// DeployStatusGTE applies the GTE predicate on the "deploy_status" field.
func DeployStatusGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDeployStatus), v))
	})
}

// DeployStatusLT applies the LT predicate on the "deploy_status" field.
func DeployStatusLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDeployStatus), v))
	})
}

// DeployStatusLTE applies the LTE predicate on the "deploy_status" field.
func DeployStatusLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDeployStatus), v))
	})
}

// DeployStatusIsNil applies the IsNil predicate on the "deploy_status" field.
func DeployStatusIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDeployStatus)))
	})
}

// DeployStatusNotNil applies the NotNil predicate on the "deploy_status" field.
func DeployStatusNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDeployStatus)))
	})
}

// DeployAddressEQ applies the EQ predicate on the "deploy_address" field.
func DeployAddressEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeployAddress), v))
	})
}

// DeployAddressNEQ applies the NEQ predicate on the "deploy_address" field.
func DeployAddressNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDeployAddress), v))
	})
}

// DeployAddressIn applies the In predicate on the "deploy_address" field.
func DeployAddressIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDeployAddress), v...))
	})
}

// DeployAddressNotIn applies the NotIn predicate on the "deploy_address" field.
func DeployAddressNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDeployAddress), v...))
	})
}

// DeployAddressGT applies the GT predicate on the "deploy_address" field.
func DeployAddressGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDeployAddress), v))
	})
}

// DeployAddressGTE applies the GTE predicate on the "deploy_address" field.
func DeployAddressGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDeployAddress), v))
	})
}

// DeployAddressLT applies the LT predicate on the "deploy_address" field.
func DeployAddressLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDeployAddress), v))
	})
}

// DeployAddressLTE applies the LTE predicate on the "deploy_address" field.
func DeployAddressLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDeployAddress), v))
	})
}

// DeployAddressContains applies the Contains predicate on the "deploy_address" field.
func DeployAddressContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDeployAddress), v))
	})
}

// DeployAddressHasPrefix applies the HasPrefix predicate on the "deploy_address" field.
func DeployAddressHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDeployAddress), v))
	})
}

// DeployAddressHasSuffix applies the HasSuffix predicate on the "deploy_address" field.
func DeployAddressHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDeployAddress), v))
	})
}

// DeployAddressIsNil applies the IsNil predicate on the "deploy_address" field.
func DeployAddressIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDeployAddress)))
	})
}

// DeployAddressNotNil applies the NotNil predicate on the "deploy_address" field.
func DeployAddressNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDeployAddress)))
	})
}

// DeployAddressEqualFold applies the EqualFold predicate on the "deploy_address" field.
func DeployAddressEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDeployAddress), v))
	})
}

// DeployAddressContainsFold applies the ContainsFold predicate on the "deploy_address" field.
func DeployAddressContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDeployAddress), v))
	})
}

// DeployTypeEQ applies the EQ predicate on the "deploy_type" field.
func DeployTypeEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDeployType), v))
	})
}

// DeployTypeNEQ applies the NEQ predicate on the "deploy_type" field.
func DeployTypeNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDeployType), v))
	})
}

// DeployTypeIn applies the In predicate on the "deploy_type" field.
func DeployTypeIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDeployType), v...))
	})
}

// DeployTypeNotIn applies the NotIn predicate on the "deploy_type" field.
func DeployTypeNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDeployType), v...))
	})
}

// DeployTypeGT applies the GT predicate on the "deploy_type" field.
func DeployTypeGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDeployType), v))
	})
}

// DeployTypeGTE applies the GTE predicate on the "deploy_type" field.
func DeployTypeGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDeployType), v))
	})
}

// DeployTypeLT applies the LT predicate on the "deploy_type" field.
func DeployTypeLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDeployType), v))
	})
}

// DeployTypeLTE applies the LTE predicate on the "deploy_type" field.
func DeployTypeLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDeployType), v))
	})
}

// DeployTypeIsNil applies the IsNil predicate on the "deploy_type" field.
func DeployTypeIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDeployType)))
	})
}

// DeployTypeNotNil applies the NotNil predicate on the "deploy_type" field.
func DeployTypeNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDeployType)))
	})
}

// PublishTimeEQ applies the EQ predicate on the "publish_time" field.
func PublishTimeEQ(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPublishTime), vc))
	})
}

// PublishTimeNEQ applies the NEQ predicate on the "publish_time" field.
func PublishTimeNEQ(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPublishTime), vc))
	})
}

// PublishTimeIn applies the In predicate on the "publish_time" field.
func PublishTimeIn(vs ...date.DateTime) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = time.Time(vs[i])
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPublishTime), v...))
	})
}

// PublishTimeNotIn applies the NotIn predicate on the "publish_time" field.
func PublishTimeNotIn(vs ...date.DateTime) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = time.Time(vs[i])
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPublishTime), v...))
	})
}

// PublishTimeGT applies the GT predicate on the "publish_time" field.
func PublishTimeGT(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPublishTime), vc))
	})
}

// PublishTimeGTE applies the GTE predicate on the "publish_time" field.
func PublishTimeGTE(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPublishTime), vc))
	})
}

// PublishTimeLT applies the LT predicate on the "publish_time" field.
func PublishTimeLT(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPublishTime), vc))
	})
}

// PublishTimeLTE applies the LTE predicate on the "publish_time" field.
func PublishTimeLTE(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPublishTime), vc))
	})
}

// PublishTimeIsNil applies the IsNil predicate on the "publish_time" field.
func PublishTimeIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPublishTime)))
	})
}

// PublishTimeNotNil applies the NotNil predicate on the "publish_time" field.
func PublishTimeNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPublishTime)))
	})
}

// AppTypeEQ applies the EQ predicate on the "app_type" field.
func AppTypeEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppType), v))
	})
}

// AppTypeNEQ applies the NEQ predicate on the "app_type" field.
func AppTypeNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAppType), v))
	})
}

// AppTypeIn applies the In predicate on the "app_type" field.
func AppTypeIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAppType), v...))
	})
}

// AppTypeNotIn applies the NotIn predicate on the "app_type" field.
func AppTypeNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAppType), v...))
	})
}

// AppTypeGT applies the GT predicate on the "app_type" field.
func AppTypeGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAppType), v))
	})
}

// AppTypeGTE applies the GTE predicate on the "app_type" field.
func AppTypeGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAppType), v))
	})
}

// AppTypeLT applies the LT predicate on the "app_type" field.
func AppTypeLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAppType), v))
	})
}

// AppTypeLTE applies the LTE predicate on the "app_type" field.
func AppTypeLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAppType), v))
	})
}

// AppTypeIsNil applies the IsNil predicate on the "app_type" field.
func AppTypeIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAppType)))
	})
}

// AppTypeNotNil applies the NotNil predicate on the "app_type" field.
func AppTypeNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAppType)))
	})
}

// ApplyTimeEQ applies the EQ predicate on the "apply_time" field.
func ApplyTimeEQ(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApplyTime), vc))
	})
}

// ApplyTimeNEQ applies the NEQ predicate on the "apply_time" field.
func ApplyTimeNEQ(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldApplyTime), vc))
	})
}

// ApplyTimeIn applies the In predicate on the "apply_time" field.
func ApplyTimeIn(vs ...date.DateTime) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = time.Time(vs[i])
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldApplyTime), v...))
	})
}

// ApplyTimeNotIn applies the NotIn predicate on the "apply_time" field.
func ApplyTimeNotIn(vs ...date.DateTime) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = time.Time(vs[i])
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldApplyTime), v...))
	})
}

// ApplyTimeGT applies the GT predicate on the "apply_time" field.
func ApplyTimeGT(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldApplyTime), vc))
	})
}

// ApplyTimeGTE applies the GTE predicate on the "apply_time" field.
func ApplyTimeGTE(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldApplyTime), vc))
	})
}

// ApplyTimeLT applies the LT predicate on the "apply_time" field.
func ApplyTimeLT(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldApplyTime), vc))
	})
}

// ApplyTimeLTE applies the LTE predicate on the "apply_time" field.
func ApplyTimeLTE(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldApplyTime), vc))
	})
}

// ApplyTimeIsNil applies the IsNil predicate on the "apply_time" field.
func ApplyTimeIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldApplyTime)))
	})
}

// ApplyTimeNotNil applies the NotNil predicate on the "apply_time" field.
func ApplyTimeNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldApplyTime)))
	})
}

// AppAddressEQ applies the EQ predicate on the "app_address" field.
func AppAddressEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppAddress), v))
	})
}

// AppAddressNEQ applies the NEQ predicate on the "app_address" field.
func AppAddressNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAppAddress), v))
	})
}

// AppAddressIn applies the In predicate on the "app_address" field.
func AppAddressIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAppAddress), v...))
	})
}

// AppAddressNotIn applies the NotIn predicate on the "app_address" field.
func AppAddressNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAppAddress), v...))
	})
}

// AppAddressGT applies the GT predicate on the "app_address" field.
func AppAddressGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAppAddress), v))
	})
}

// AppAddressGTE applies the GTE predicate on the "app_address" field.
func AppAddressGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAppAddress), v))
	})
}

// AppAddressLT applies the LT predicate on the "app_address" field.
func AppAddressLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAppAddress), v))
	})
}

// AppAddressLTE applies the LTE predicate on the "app_address" field.
func AppAddressLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAppAddress), v))
	})
}

// AppAddressContains applies the Contains predicate on the "app_address" field.
func AppAddressContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAppAddress), v))
	})
}

// AppAddressHasPrefix applies the HasPrefix predicate on the "app_address" field.
func AppAddressHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAppAddress), v))
	})
}

// AppAddressHasSuffix applies the HasSuffix predicate on the "app_address" field.
func AppAddressHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAppAddress), v))
	})
}

// AppAddressIsNil applies the IsNil predicate on the "app_address" field.
func AppAddressIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAppAddress)))
	})
}

// AppAddressNotNil applies the NotNil predicate on the "app_address" field.
func AppAddressNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAppAddress)))
	})
}

// AppAddressEqualFold applies the EqualFold predicate on the "app_address" field.
func AppAddressEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAppAddress), v))
	})
}

// AppAddressContainsFold applies the ContainsFold predicate on the "app_address" field.
func AppAddressContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAppAddress), v))
	})
}

// AppMailEQ applies the EQ predicate on the "app_mail" field.
func AppMailEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppMail), v))
	})
}

// AppMailNEQ applies the NEQ predicate on the "app_mail" field.
func AppMailNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAppMail), v))
	})
}

// AppMailIn applies the In predicate on the "app_mail" field.
func AppMailIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAppMail), v...))
	})
}

// AppMailNotIn applies the NotIn predicate on the "app_mail" field.
func AppMailNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAppMail), v...))
	})
}

// AppMailGT applies the GT predicate on the "app_mail" field.
func AppMailGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAppMail), v))
	})
}

// AppMailGTE applies the GTE predicate on the "app_mail" field.
func AppMailGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAppMail), v))
	})
}

// AppMailLT applies the LT predicate on the "app_mail" field.
func AppMailLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAppMail), v))
	})
}

// AppMailLTE applies the LTE predicate on the "app_mail" field.
func AppMailLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAppMail), v))
	})
}

// AppMailContains applies the Contains predicate on the "app_mail" field.
func AppMailContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAppMail), v))
	})
}

// AppMailHasPrefix applies the HasPrefix predicate on the "app_mail" field.
func AppMailHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAppMail), v))
	})
}

// AppMailHasSuffix applies the HasSuffix predicate on the "app_mail" field.
func AppMailHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAppMail), v))
	})
}

// AppMailIsNil applies the IsNil predicate on the "app_mail" field.
func AppMailIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAppMail)))
	})
}

// AppMailNotNil applies the NotNil predicate on the "app_mail" field.
func AppMailNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAppMail)))
	})
}

// AppMailEqualFold applies the EqualFold predicate on the "app_mail" field.
func AppMailEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAppMail), v))
	})
}

// AppMailContainsFold applies the ContainsFold predicate on the "app_mail" field.
func AppMailContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAppMail), v))
	})
}

// AppPhotoEQ applies the EQ predicate on the "app_photo" field.
func AppPhotoEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppPhoto), v))
	})
}

// AppPhotoNEQ applies the NEQ predicate on the "app_photo" field.
func AppPhotoNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAppPhoto), v))
	})
}

// AppPhotoIn applies the In predicate on the "app_photo" field.
func AppPhotoIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAppPhoto), v...))
	})
}

// AppPhotoNotIn applies the NotIn predicate on the "app_photo" field.
func AppPhotoNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAppPhoto), v...))
	})
}

// AppPhotoGT applies the GT predicate on the "app_photo" field.
func AppPhotoGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAppPhoto), v))
	})
}

// AppPhotoGTE applies the GTE predicate on the "app_photo" field.
func AppPhotoGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAppPhoto), v))
	})
}

// AppPhotoLT applies the LT predicate on the "app_photo" field.
func AppPhotoLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAppPhoto), v))
	})
}

// AppPhotoLTE applies the LTE predicate on the "app_photo" field.
func AppPhotoLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAppPhoto), v))
	})
}

// AppPhotoContains applies the Contains predicate on the "app_photo" field.
func AppPhotoContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAppPhoto), v))
	})
}

// AppPhotoHasPrefix applies the HasPrefix predicate on the "app_photo" field.
func AppPhotoHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAppPhoto), v))
	})
}

// AppPhotoHasSuffix applies the HasSuffix predicate on the "app_photo" field.
func AppPhotoHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAppPhoto), v))
	})
}

// AppPhotoIsNil applies the IsNil predicate on the "app_photo" field.
func AppPhotoIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAppPhoto)))
	})
}

// AppPhotoNotNil applies the NotNil predicate on the "app_photo" field.
func AppPhotoNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAppPhoto)))
	})
}

// AppPhotoEqualFold applies the EqualFold predicate on the "app_photo" field.
func AppPhotoEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAppPhoto), v))
	})
}

// AppPhotoContainsFold applies the ContainsFold predicate on the "app_photo" field.
func AppPhotoContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAppPhoto), v))
	})
}

// AppFieldEQ applies the EQ predicate on the "app_field" field.
func AppFieldEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppField), v))
	})
}

// AppFieldNEQ applies the NEQ predicate on the "app_field" field.
func AppFieldNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAppField), v))
	})
}

// AppFieldIn applies the In predicate on the "app_field" field.
func AppFieldIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAppField), v...))
	})
}

// AppFieldNotIn applies the NotIn predicate on the "app_field" field.
func AppFieldNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAppField), v...))
	})
}

// AppFieldGT applies the GT predicate on the "app_field" field.
func AppFieldGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAppField), v))
	})
}

// AppFieldGTE applies the GTE predicate on the "app_field" field.
func AppFieldGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAppField), v))
	})
}

// AppFieldLT applies the LT predicate on the "app_field" field.
func AppFieldLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAppField), v))
	})
}

// AppFieldLTE applies the LTE predicate on the "app_field" field.
func AppFieldLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAppField), v))
	})
}

// AppFieldIsNil applies the IsNil predicate on the "app_field" field.
func AppFieldIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAppField)))
	})
}

// AppFieldNotNil applies the NotNil predicate on the "app_field" field.
func AppFieldNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAppField)))
	})
}

// AppCategoryEQ applies the EQ predicate on the "app_category" field.
func AppCategoryEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppCategory), v))
	})
}

// AppCategoryNEQ applies the NEQ predicate on the "app_category" field.
func AppCategoryNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAppCategory), v))
	})
}

// AppCategoryIn applies the In predicate on the "app_category" field.
func AppCategoryIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAppCategory), v...))
	})
}

// AppCategoryNotIn applies the NotIn predicate on the "app_category" field.
func AppCategoryNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAppCategory), v...))
	})
}

// AppCategoryGT applies the GT predicate on the "app_category" field.
func AppCategoryGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAppCategory), v))
	})
}

// AppCategoryGTE applies the GTE predicate on the "app_category" field.
func AppCategoryGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAppCategory), v))
	})
}

// AppCategoryLT applies the LT predicate on the "app_category" field.
func AppCategoryLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAppCategory), v))
	})
}

// AppCategoryLTE applies the LTE predicate on the "app_category" field.
func AppCategoryLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAppCategory), v))
	})
}

// AppCategoryIsNil applies the IsNil predicate on the "app_category" field.
func AppCategoryIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAppCategory)))
	})
}

// AppCategoryNotNil applies the NotNil predicate on the "app_category" field.
func AppCategoryNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAppCategory)))
	})
}

// AppProjectSourceEQ applies the EQ predicate on the "app_project_source" field.
func AppProjectSourceEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppProjectSource), v))
	})
}

// AppProjectSourceNEQ applies the NEQ predicate on the "app_project_source" field.
func AppProjectSourceNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAppProjectSource), v))
	})
}

// AppProjectSourceIn applies the In predicate on the "app_project_source" field.
func AppProjectSourceIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAppProjectSource), v...))
	})
}

// AppProjectSourceNotIn applies the NotIn predicate on the "app_project_source" field.
func AppProjectSourceNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAppProjectSource), v...))
	})
}

// AppProjectSourceGT applies the GT predicate on the "app_project_source" field.
func AppProjectSourceGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAppProjectSource), v))
	})
}

// AppProjectSourceGTE applies the GTE predicate on the "app_project_source" field.
func AppProjectSourceGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAppProjectSource), v))
	})
}

// AppProjectSourceLT applies the LT predicate on the "app_project_source" field.
func AppProjectSourceLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAppProjectSource), v))
	})
}

// AppProjectSourceLTE applies the LTE predicate on the "app_project_source" field.
func AppProjectSourceLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAppProjectSource), v))
	})
}

// AppProjectSourceIsNil applies the IsNil predicate on the "app_project_source" field.
func AppProjectSourceIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAppProjectSource)))
	})
}

// AppProjectSourceNotNil applies the NotNil predicate on the "app_project_source" field.
func AppProjectSourceNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAppProjectSource)))
	})
}

// AppStarEQ applies the EQ predicate on the "app_star" field.
func AppStarEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppStar), v))
	})
}

// AppStarNEQ applies the NEQ predicate on the "app_star" field.
func AppStarNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAppStar), v))
	})
}

// AppStarIn applies the In predicate on the "app_star" field.
func AppStarIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAppStar), v...))
	})
}

// AppStarNotIn applies the NotIn predicate on the "app_star" field.
func AppStarNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAppStar), v...))
	})
}

// AppStarGT applies the GT predicate on the "app_star" field.
func AppStarGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAppStar), v))
	})
}

// AppStarGTE applies the GTE predicate on the "app_star" field.
func AppStarGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAppStar), v))
	})
}

// AppStarLT applies the LT predicate on the "app_star" field.
func AppStarLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAppStar), v))
	})
}

// AppStarLTE applies the LTE predicate on the "app_star" field.
func AppStarLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAppStar), v))
	})
}

// AppFoundsSourceEQ applies the EQ predicate on the "app_founds_source" field.
func AppFoundsSourceEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAppFoundsSource), v))
	})
}

// AppFoundsSourceNEQ applies the NEQ predicate on the "app_founds_source" field.
func AppFoundsSourceNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAppFoundsSource), v))
	})
}

// AppFoundsSourceIn applies the In predicate on the "app_founds_source" field.
func AppFoundsSourceIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAppFoundsSource), v...))
	})
}

// AppFoundsSourceNotIn applies the NotIn predicate on the "app_founds_source" field.
func AppFoundsSourceNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAppFoundsSource), v...))
	})
}

// AppFoundsSourceGT applies the GT predicate on the "app_founds_source" field.
func AppFoundsSourceGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAppFoundsSource), v))
	})
}

// AppFoundsSourceGTE applies the GTE predicate on the "app_founds_source" field.
func AppFoundsSourceGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAppFoundsSource), v))
	})
}

// AppFoundsSourceLT applies the LT predicate on the "app_founds_source" field.
func AppFoundsSourceLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAppFoundsSource), v))
	})
}

// AppFoundsSourceLTE applies the LTE predicate on the "app_founds_source" field.
func AppFoundsSourceLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAppFoundsSource), v))
	})
}

// AppFoundsSourceIsNil applies the IsNil predicate on the "app_founds_source" field.
func AppFoundsSourceIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAppFoundsSource)))
	})
}

// AppFoundsSourceNotNil applies the NotNil predicate on the "app_founds_source" field.
func AppFoundsSourceNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAppFoundsSource)))
	})
}

// InnerURLEQ applies the EQ predicate on the "inner_url" field.
func InnerURLEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldInnerURL), v))
	})
}

// InnerURLNEQ applies the NEQ predicate on the "inner_url" field.
func InnerURLNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldInnerURL), v))
	})
}

// InnerURLIn applies the In predicate on the "inner_url" field.
func InnerURLIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldInnerURL), v...))
	})
}

// InnerURLNotIn applies the NotIn predicate on the "inner_url" field.
func InnerURLNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldInnerURL), v...))
	})
}

// InnerURLGT applies the GT predicate on the "inner_url" field.
func InnerURLGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldInnerURL), v))
	})
}

// InnerURLGTE applies the GTE predicate on the "inner_url" field.
func InnerURLGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldInnerURL), v))
	})
}

// InnerURLLT applies the LT predicate on the "inner_url" field.
func InnerURLLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldInnerURL), v))
	})
}

// InnerURLLTE applies the LTE predicate on the "inner_url" field.
func InnerURLLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldInnerURL), v))
	})
}

// InnerURLContains applies the Contains predicate on the "inner_url" field.
func InnerURLContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldInnerURL), v))
	})
}

// InnerURLHasPrefix applies the HasPrefix predicate on the "inner_url" field.
func InnerURLHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldInnerURL), v))
	})
}

// InnerURLHasSuffix applies the HasSuffix predicate on the "inner_url" field.
func InnerURLHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldInnerURL), v))
	})
}

// InnerURLIsNil applies the IsNil predicate on the "inner_url" field.
func InnerURLIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldInnerURL)))
	})
}

// InnerURLNotNil applies the NotNil predicate on the "inner_url" field.
func InnerURLNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldInnerURL)))
	})
}

// InnerURLEqualFold applies the EqualFold predicate on the "inner_url" field.
func InnerURLEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldInnerURL), v))
	})
}

// InnerURLContainsFold applies the ContainsFold predicate on the "inner_url" field.
func InnerURLContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldInnerURL), v))
	})
}

// OutURLEQ applies the EQ predicate on the "out_url" field.
func OutURLEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOutURL), v))
	})
}

// OutURLNEQ applies the NEQ predicate on the "out_url" field.
func OutURLNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOutURL), v))
	})
}

// OutURLIn applies the In predicate on the "out_url" field.
func OutURLIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOutURL), v...))
	})
}

// OutURLNotIn applies the NotIn predicate on the "out_url" field.
func OutURLNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOutURL), v...))
	})
}

// OutURLGT applies the GT predicate on the "out_url" field.
func OutURLGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOutURL), v))
	})
}

// OutURLGTE applies the GTE predicate on the "out_url" field.
func OutURLGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOutURL), v))
	})
}

// OutURLLT applies the LT predicate on the "out_url" field.
func OutURLLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOutURL), v))
	})
}

// OutURLLTE applies the LTE predicate on the "out_url" field.
func OutURLLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOutURL), v))
	})
}

// OutURLContains applies the Contains predicate on the "out_url" field.
func OutURLContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldOutURL), v))
	})
}

// OutURLHasPrefix applies the HasPrefix predicate on the "out_url" field.
func OutURLHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldOutURL), v))
	})
}

// OutURLHasSuffix applies the HasSuffix predicate on the "out_url" field.
func OutURLHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldOutURL), v))
	})
}

// OutURLIsNil applies the IsNil predicate on the "out_url" field.
func OutURLIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldOutURL)))
	})
}

// OutURLNotNil applies the NotNil predicate on the "out_url" field.
func OutURLNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldOutURL)))
	})
}

// OutURLEqualFold applies the EqualFold predicate on the "out_url" field.
func OutURLEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldOutURL), v))
	})
}

// OutURLContainsFold applies the ContainsFold predicate on the "out_url" field.
func OutURLContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldOutURL), v))
	})
}

// ReformStatusEQ applies the EQ predicate on the "reform_status" field.
func ReformStatusEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReformStatus), v))
	})
}

// ReformStatusNEQ applies the NEQ predicate on the "reform_status" field.
func ReformStatusNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldReformStatus), v))
	})
}

// ReformStatusIn applies the In predicate on the "reform_status" field.
func ReformStatusIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldReformStatus), v...))
	})
}

// ReformStatusNotIn applies the NotIn predicate on the "reform_status" field.
func ReformStatusNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldReformStatus), v...))
	})
}

// ReformStatusGT applies the GT predicate on the "reform_status" field.
func ReformStatusGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldReformStatus), v))
	})
}

// ReformStatusGTE applies the GTE predicate on the "reform_status" field.
func ReformStatusGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldReformStatus), v))
	})
}

// ReformStatusLT applies the LT predicate on the "reform_status" field.
func ReformStatusLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldReformStatus), v))
	})
}

// ReformStatusLTE applies the LTE predicate on the "reform_status" field.
func ReformStatusLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldReformStatus), v))
	})
}

// OutIPURLEQ applies the EQ predicate on the "out_ip_url" field.
func OutIPURLEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOutIPURL), v))
	})
}

// OutIPURLNEQ applies the NEQ predicate on the "out_ip_url" field.
func OutIPURLNEQ(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOutIPURL), v))
	})
}

// OutIPURLIn applies the In predicate on the "out_ip_url" field.
func OutIPURLIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOutIPURL), v...))
	})
}

// OutIPURLNotIn applies the NotIn predicate on the "out_ip_url" field.
func OutIPURLNotIn(vs ...string) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOutIPURL), v...))
	})
}

// OutIPURLGT applies the GT predicate on the "out_ip_url" field.
func OutIPURLGT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOutIPURL), v))
	})
}

// OutIPURLGTE applies the GTE predicate on the "out_ip_url" field.
func OutIPURLGTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOutIPURL), v))
	})
}

// OutIPURLLT applies the LT predicate on the "out_ip_url" field.
func OutIPURLLT(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOutIPURL), v))
	})
}

// OutIPURLLTE applies the LTE predicate on the "out_ip_url" field.
func OutIPURLLTE(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOutIPURL), v))
	})
}

// OutIPURLContains applies the Contains predicate on the "out_ip_url" field.
func OutIPURLContains(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldOutIPURL), v))
	})
}

// OutIPURLHasPrefix applies the HasPrefix predicate on the "out_ip_url" field.
func OutIPURLHasPrefix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldOutIPURL), v))
	})
}

// OutIPURLHasSuffix applies the HasSuffix predicate on the "out_ip_url" field.
func OutIPURLHasSuffix(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldOutIPURL), v))
	})
}

// OutIPURLIsNil applies the IsNil predicate on the "out_ip_url" field.
func OutIPURLIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldOutIPURL)))
	})
}

// OutIPURLNotNil applies the NotNil predicate on the "out_ip_url" field.
func OutIPURLNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldOutIPURL)))
	})
}

// OutIPURLEqualFold applies the EqualFold predicate on the "out_ip_url" field.
func OutIPURLEqualFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldOutIPURL), v))
	})
}

// OutIPURLContainsFold applies the ContainsFold predicate on the "out_ip_url" field.
func OutIPURLContainsFold(v string) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldOutIPURL), v))
	})
}

// IsDeletedEQ applies the EQ predicate on the "is_deleted" field.
func IsDeletedEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIsDeleted), v))
	})
}

// IsDeletedNEQ applies the NEQ predicate on the "is_deleted" field.
func IsDeletedNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIsDeleted), v))
	})
}

// IsDeletedIn applies the In predicate on the "is_deleted" field.
func IsDeletedIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldIsDeleted), v...))
	})
}

// IsDeletedNotIn applies the NotIn predicate on the "is_deleted" field.
func IsDeletedNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldIsDeleted), v...))
	})
}

// IsDeletedGT applies the GT predicate on the "is_deleted" field.
func IsDeletedGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldIsDeleted), v))
	})
}

// IsDeletedGTE applies the GTE predicate on the "is_deleted" field.
func IsDeletedGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldIsDeleted), v))
	})
}

// IsDeletedLT applies the LT predicate on the "is_deleted" field.
func IsDeletedLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldIsDeleted), v))
	})
}

// IsDeletedLTE applies the LTE predicate on the "is_deleted" field.
func IsDeletedLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldIsDeleted), v))
	})
}

// StatusEQ applies the EQ predicate on the "status" field.
func StatusEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// StatusNEQ applies the NEQ predicate on the "status" field.
func StatusNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatus), v))
	})
}

// StatusIn applies the In predicate on the "status" field.
func StatusIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStatus), v...))
	})
}

// StatusNotIn applies the NotIn predicate on the "status" field.
func StatusNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStatus), v...))
	})
}

// StatusGT applies the GT predicate on the "status" field.
func StatusGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStatus), v))
	})
}

// StatusGTE applies the GTE predicate on the "status" field.
func StatusGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStatus), v))
	})
}

// StatusLT applies the LT predicate on the "status" field.
func StatusLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStatus), v))
	})
}

// StatusLTE applies the LTE predicate on the "status" field.
func StatusLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStatus), v))
	})
}

// StatusIsNil applies the IsNil predicate on the "status" field.
func StatusIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStatus)))
	})
}

// StatusNotNil applies the NotNil predicate on the "status" field.
func StatusNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStatus)))
	})
}

// CreateUserEQ applies the EQ predicate on the "create_user" field.
func CreateUserEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateUser), v))
	})
}

// CreateUserNEQ applies the NEQ predicate on the "create_user" field.
func CreateUserNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreateUser), v))
	})
}

// CreateUserIn applies the In predicate on the "create_user" field.
func CreateUserIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreateUser), v...))
	})
}

// CreateUserNotIn applies the NotIn predicate on the "create_user" field.
func CreateUserNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreateUser), v...))
	})
}

// CreateUserGT applies the GT predicate on the "create_user" field.
func CreateUserGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreateUser), v))
	})
}

// CreateUserGTE applies the GTE predicate on the "create_user" field.
func CreateUserGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreateUser), v))
	})
}

// CreateUserLT applies the LT predicate on the "create_user" field.
func CreateUserLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreateUser), v))
	})
}

// CreateUserLTE applies the LTE predicate on the "create_user" field.
func CreateUserLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreateUser), v))
	})
}

// CreateUserIsNil applies the IsNil predicate on the "create_user" field.
func CreateUserIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCreateUser)))
	})
}

// CreateUserNotNil applies the NotNil predicate on the "create_user" field.
func CreateUserNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCreateUser)))
	})
}

// UpdateUserEQ applies the EQ predicate on the "update_user" field.
func UpdateUserEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateUser), v))
	})
}

// UpdateUserNEQ applies the NEQ predicate on the "update_user" field.
func UpdateUserNEQ(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateUser), v))
	})
}

// UpdateUserIn applies the In predicate on the "update_user" field.
func UpdateUserIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateUser), v...))
	})
}

// UpdateUserNotIn applies the NotIn predicate on the "update_user" field.
func UpdateUserNotIn(vs ...int64) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateUser), v...))
	})
}

// UpdateUserGT applies the GT predicate on the "update_user" field.
func UpdateUserGT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateUser), v))
	})
}

// UpdateUserGTE applies the GTE predicate on the "update_user" field.
func UpdateUserGTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateUser), v))
	})
}

// UpdateUserLT applies the LT predicate on the "update_user" field.
func UpdateUserLT(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateUser), v))
	})
}

// UpdateUserLTE applies the LTE predicate on the "update_user" field.
func UpdateUserLTE(v int64) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateUser), v))
	})
}

// UpdateUserIsNil applies the IsNil predicate on the "update_user" field.
func UpdateUserIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUpdateUser)))
	})
}

// UpdateUserNotNil applies the NotNil predicate on the "update_user" field.
func UpdateUserNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUpdateUser)))
	})
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), vc))
	})
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreateTime), vc))
	})
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...date.DateTime) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = time.Time(vs[i])
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...date.DateTime) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = time.Time(vs[i])
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreateTime), vc))
	})
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreateTime), vc))
	})
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreateTime), vc))
	})
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreateTime), vc))
	})
}

// CreateTimeIsNil applies the IsNil predicate on the "create_time" field.
func CreateTimeIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCreateTime)))
	})
}

// CreateTimeNotNil applies the NotNil predicate on the "create_time" field.
func CreateTimeNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCreateTime)))
	})
}

// UpdateTimeEQ applies the EQ predicate on the "update_time" field.
func UpdateTimeEQ(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), vc))
	})
}

// UpdateTimeNEQ applies the NEQ predicate on the "update_time" field.
func UpdateTimeNEQ(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateTime), vc))
	})
}

// UpdateTimeIn applies the In predicate on the "update_time" field.
func UpdateTimeIn(vs ...date.DateTime) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = time.Time(vs[i])
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeNotIn applies the NotIn predicate on the "update_time" field.
func UpdateTimeNotIn(vs ...date.DateTime) predicate.AsMarketApp {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = time.Time(vs[i])
	}
	return predicate.AsMarketApp(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeGT applies the GT predicate on the "update_time" field.
func UpdateTimeGT(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateTime), vc))
	})
}

// UpdateTimeGTE applies the GTE predicate on the "update_time" field.
func UpdateTimeGTE(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateTime), vc))
	})
}

// UpdateTimeLT applies the LT predicate on the "update_time" field.
func UpdateTimeLT(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateTime), vc))
	})
}

// UpdateTimeLTE applies the LTE predicate on the "update_time" field.
func UpdateTimeLTE(v date.DateTime) predicate.AsMarketApp {
	vc := time.Time(v)
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateTime), vc))
	})
}

// UpdateTimeIsNil applies the IsNil predicate on the "update_time" field.
func UpdateTimeIsNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUpdateTime)))
	})
}

// UpdateTimeNotNil applies the NotNil predicate on the "update_time" field.
func UpdateTimeNotNil() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUpdateTime)))
	})
}

// HasAppMenus applies the HasEdge predicate on the "appMenus" edge.
func HasAppMenus() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppMenusTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppMenusTable, AppMenusColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppMenusWith applies the HasEdge predicate on the "appMenus" edge with a given conditions (other predicates).
func HasAppMenusWith(preds ...predicate.AsMarketMenu) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppMenusInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppMenusTable, AppMenusColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAppRoles applies the HasEdge predicate on the "appRoles" edge.
func HasAppRoles() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppRolesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppRolesTable, AppRolesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppRolesWith applies the HasEdge predicate on the "appRoles" edge with a given conditions (other predicates).
func HasAppRolesWith(preds ...predicate.AsMarketAppRole) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppRolesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppRolesTable, AppRolesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasUseds applies the HasEdge predicate on the "useds" edge.
func HasUseds() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UsedsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, UsedsTable, UsedsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUsedsWith applies the HasEdge predicate on the "useds" edge with a given conditions (other predicates).
func HasUsedsWith(preds ...predicate.AsMarketUsedApp) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UsedsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, UsedsTable, UsedsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAppAlerts applies the HasEdge predicate on the "appAlerts" edge.
func HasAppAlerts() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppAlertsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppAlertsTable, AppAlertsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppAlertsWith applies the HasEdge predicate on the "appAlerts" edge with a given conditions (other predicates).
func HasAppAlertsWith(preds ...predicate.AsMarketAppAlert) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppAlertsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppAlertsTable, AppAlertsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAppRedeploys applies the HasEdge predicate on the "appRedeploys" edge.
func HasAppRedeploys() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppRedeploysTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppRedeploysTable, AppRedeploysColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppRedeploysWith applies the HasEdge predicate on the "appRedeploys" edge with a given conditions (other predicates).
func HasAppRedeploysWith(preds ...predicate.AsRedeployData) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppRedeploysInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppRedeploysTable, AppRedeploysColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAppKeys applies the HasEdge predicate on the "appKeys" edge.
func HasAppKeys() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppKeysTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppKeysTable, AppKeysColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppKeysWith applies the HasEdge predicate on the "appKeys" edge with a given conditions (other predicates).
func HasAppKeysWith(preds ...predicate.AsMarketAppKeySecret) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppKeysInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppKeysTable, AppKeysColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAppPurchases applies the HasEdge predicate on the "appPurchases" edge.
func HasAppPurchases() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppPurchasesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppPurchasesTable, AppPurchasesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppPurchasesWith applies the HasEdge predicate on the "appPurchases" edge with a given conditions (other predicates).
func HasAppPurchasesWith(preds ...predicate.AsMarketAppPurchase) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppPurchasesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppPurchasesTable, AppPurchasesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAppComponents applies the HasEdge predicate on the "appComponents" edge.
func HasAppComponents() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppComponentsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppComponentsTable, AppComponentsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppComponentsWith applies the HasEdge predicate on the "appComponents" edge with a given conditions (other predicates).
func HasAppComponentsWith(preds ...predicate.AsMarketAppComponent) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppComponentsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppComponentsTable, AppComponentsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAppGroupDistribs applies the HasEdge predicate on the "appGroupDistribs" edge.
func HasAppGroupDistribs() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppGroupDistribsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppGroupDistribsTable, AppGroupDistribsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppGroupDistribsWith applies the HasEdge predicate on the "appGroupDistribs" edge with a given conditions (other predicates).
func HasAppGroupDistribsWith(preds ...predicate.AsMarketAppGroupDistribution) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppGroupDistribsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppGroupDistribsTable, AppGroupDistribsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAppGroupDistribConfigs applies the HasEdge predicate on the "appGroupDistribConfigs" edge.
func HasAppGroupDistribConfigs() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppGroupDistribConfigsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppGroupDistribConfigsTable, AppGroupDistribConfigsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppGroupDistribConfigsWith applies the HasEdge predicate on the "appGroupDistribConfigs" edge with a given conditions (other predicates).
func HasAppGroupDistribConfigsWith(preds ...predicate.AsAppGroupDistributionData) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppGroupDistribConfigsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppGroupDistribConfigsTable, AppGroupDistribConfigsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAppGroupDistribsRelation applies the HasEdge predicate on the "appGroupDistribsRelation" edge.
func HasAppGroupDistribsRelation() predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppGroupDistribsRelationTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppGroupDistribsRelationTable, AppGroupDistribsRelationColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAppGroupDistribsRelationWith applies the HasEdge predicate on the "appGroupDistribsRelation" edge with a given conditions (other predicates).
func HasAppGroupDistribsRelationWith(preds ...predicate.AsMarketAppGroupDistributionRelation) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AppGroupDistribsRelationInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AppGroupDistribsRelationTable, AppGroupDistribsRelationColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.AsMarketApp) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.AsMarketApp) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.AsMarketApp) predicate.AsMarketApp {
	return predicate.AsMarketApp(func(s *sql.Selector) {
		p(s.Not())
	})
}

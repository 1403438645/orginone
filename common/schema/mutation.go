// Code generated by entc, DO NOT EDIT.

package schema

import (
	"context"
	"errors"
	"fmt"
	"orginone/common/schema/asallgroup"
	"orginone/common/schema/asappgroupdistributiondata"
	"orginone/common/schema/asdict"
	"orginone/common/schema/asgrouptenantrelations"
	"orginone/common/schema/asinneragency"
	"orginone/common/schema/asinputdata"
	"orginone/common/schema/asjob"
	"orginone/common/schema/aslayer"
	"orginone/common/schema/asmarketapp"
	"orginone/common/schema/asmarketappalert"
	"orginone/common/schema/asmarketappcomponent"
	"orginone/common/schema/asmarketappcomponenttemplate"
	"orginone/common/schema/asmarketappgroupdistribution"
	"orginone/common/schema/asmarketappgroupdistributionrelation"
	"orginone/common/schema/asmarketappkeysecret"
	"orginone/common/schema/asmarketappnotice"
	"orginone/common/schema/asmarketapppurchase"
	"orginone/common/schema/asmarketapprole"
	"orginone/common/schema/asmarketappusertemplate"
	"orginone/common/schema/asmarketmenu"
	"orginone/common/schema/asmarketmenuusersort"
	"orginone/common/schema/asmarketroledistribution"
	"orginone/common/schema/asmarketrolemenu"
	"orginone/common/schema/asmarketusedapp"
	"orginone/common/schema/asmenu"
	"orginone/common/schema/asperson"
	"orginone/common/schema/aspersonsingle"
	"orginone/common/schema/asproperties"
	"orginone/common/schema/aspropertiesdistribution"
	"orginone/common/schema/asredeploydata"
	"orginone/common/schema/asrole"
	"orginone/common/schema/astenant"
	"orginone/common/schema/astenantattr"
	"orginone/common/schema/astenantattrrole"
	"orginone/common/schema/astenanticon"
	"orginone/common/schema/asunit"
	"orginone/common/schema/asuser"
	"orginone/common/schema/asworkingdata"
	"orginone/common/schema/baseinfoadministrativeareaall"
	"orginone/common/schema/predicate"
	"orginone/common/tools/date"
	"sync"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAsAllGroup                           = "AsAllGroup"
	TypeAsAppGroupDistributionData           = "AsAppGroupDistributionData"
	TypeAsDict                               = "AsDict"
	TypeAsGroupTenantRelations               = "AsGroupTenantRelations"
	TypeAsInnerAgency                        = "AsInnerAgency"
	TypeAsInputData                          = "AsInputData"
	TypeAsJob                                = "AsJob"
	TypeAsLayer                              = "AsLayer"
	TypeAsMarketApp                          = "AsMarketApp"
	TypeAsMarketAppAlert                     = "AsMarketAppAlert"
	TypeAsMarketAppComponent                 = "AsMarketAppComponent"
	TypeAsMarketAppComponentTemplate         = "AsMarketAppComponentTemplate"
	TypeAsMarketAppGroupDistribution         = "AsMarketAppGroupDistribution"
	TypeAsMarketAppGroupDistributionRelation = "AsMarketAppGroupDistributionRelation"
	TypeAsMarketAppKeySecret                 = "AsMarketAppKeySecret"
	TypeAsMarketAppNotice                    = "AsMarketAppNotice"
	TypeAsMarketAppPurchase                  = "AsMarketAppPurchase"
	TypeAsMarketAppRole                      = "AsMarketAppRole"
	TypeAsMarketAppUserTemplate              = "AsMarketAppUserTemplate"
	TypeAsMarketMenu                         = "AsMarketMenu"
	TypeAsMarketMenuUserSort                 = "AsMarketMenuUserSort"
	TypeAsMarketRoleDistribution             = "AsMarketRoleDistribution"
	TypeAsMarketRoleMenu                     = "AsMarketRoleMenu"
	TypeAsMarketUsedApp                      = "AsMarketUsedApp"
	TypeAsMenu                               = "AsMenu"
	TypeAsPerson                             = "AsPerson"
	TypeAsPersonSingle                       = "AsPersonSingle"
	TypeAsProperties                         = "AsProperties"
	TypeAsPropertiesDistribution             = "AsPropertiesDistribution"
	TypeAsRedeployData                       = "AsRedeployData"
	TypeAsRole                               = "AsRole"
	TypeAsTenant                             = "AsTenant"
	TypeAsTenantAttr                         = "AsTenantAttr"
	TypeAsTenantAttrRole                     = "AsTenantAttrRole"
	TypeAsTenantIcon                         = "AsTenantIcon"
	TypeAsUnit                               = "AsUnit"
	TypeAsUser                               = "AsUser"
	TypeAsWorkingData                        = "AsWorkingData"
	TypeBaseinfoadministrativeareaall        = "Baseinfoadministrativeareaall"
)

// AsAllGroupMutation represents an operation that mutates the AsAllGroup nodes in the graph.
type AsAllGroupMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int64
	tenant_code                     *string
	group_name                      *string
	group_description               *string
	group_code                      *string
	depth                           *int64
	adddepth                        *int64
	_type                           *int64
	add_type                        *int64
	social_credit_code              *string
	is_deleted                      *int64
	addis_deleted                   *int64
	status                          *int64
	addstatus                       *int64
	create_user                     *int64
	addcreate_user                  *int64
	update_user                     *int64
	addupdate_user                  *int64
	create_time                     *date.DateTime
	update_time                     *date.DateTime
	clearedFields                   map[string]struct{}
	allLayer                        map[int64]struct{}
	removedallLayer                 map[int64]struct{}
	clearedallLayer                 bool
	appPurchases                    map[int64]struct{}
	removedappPurchases             map[int64]struct{}
	clearedappPurchases             bool
	allTenants                      map[int64]struct{}
	removedallTenants               map[int64]struct{}
	clearedallTenants               bool
	appGroupDistribs                map[int64]struct{}
	removedappGroupDistribs         map[int64]struct{}
	clearedappGroupDistribs         bool
	appGroupDistribConfigs          map[int64]struct{}
	removedappGroupDistribConfigs   map[int64]struct{}
	clearedappGroupDistribConfigs   bool
	appGroupDistribsRelation        map[int64]struct{}
	removedappGroupDistribsRelation map[int64]struct{}
	clearedappGroupDistribsRelation bool
	done                            bool
	oldValue                        func(context.Context) (*AsAllGroup, error)
	predicates                      []predicate.AsAllGroup
}

var _ ent.Mutation = (*AsAllGroupMutation)(nil)

// asallgroupOption allows management of the mutation configuration using functional options.
type asallgroupOption func(*AsAllGroupMutation)

// newAsAllGroupMutation creates new mutation for the AsAllGroup entity.
func newAsAllGroupMutation(c config, op Op, opts ...asallgroupOption) *AsAllGroupMutation {
	m := &AsAllGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeAsAllGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsAllGroupID sets the ID field of the mutation.
func withAsAllGroupID(id int64) asallgroupOption {
	return func(m *AsAllGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *AsAllGroup
		)
		m.oldValue = func(ctx context.Context) (*AsAllGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsAllGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsAllGroup sets the old AsAllGroup of the mutation.
func withAsAllGroup(node *AsAllGroup) asallgroupOption {
	return func(m *AsAllGroupMutation) {
		m.oldValue = func(context.Context) (*AsAllGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsAllGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsAllGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsAllGroup entities.
func (m *AsAllGroupMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsAllGroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsAllGroupMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsAllGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantCode sets the "tenant_code" field.
func (m *AsAllGroupMutation) SetTenantCode(s string) {
	m.tenant_code = &s
}

// TenantCode returns the value of the "tenant_code" field in the mutation.
func (m *AsAllGroupMutation) TenantCode() (r string, exists bool) {
	v := m.tenant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantCode returns the old "tenant_code" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldTenantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantCode: %w", err)
	}
	return oldValue.TenantCode, nil
}

// ClearTenantCode clears the value of the "tenant_code" field.
func (m *AsAllGroupMutation) ClearTenantCode() {
	m.tenant_code = nil
	m.clearedFields[asallgroup.FieldTenantCode] = struct{}{}
}

// TenantCodeCleared returns if the "tenant_code" field was cleared in this mutation.
func (m *AsAllGroupMutation) TenantCodeCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldTenantCode]
	return ok
}

// ResetTenantCode resets all changes to the "tenant_code" field.
func (m *AsAllGroupMutation) ResetTenantCode() {
	m.tenant_code = nil
	delete(m.clearedFields, asallgroup.FieldTenantCode)
}

// SetGroupName sets the "group_name" field.
func (m *AsAllGroupMutation) SetGroupName(s string) {
	m.group_name = &s
}

// GroupName returns the value of the "group_name" field in the mutation.
func (m *AsAllGroupMutation) GroupName() (r string, exists bool) {
	v := m.group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupName returns the old "group_name" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupName: %w", err)
	}
	return oldValue.GroupName, nil
}

// ClearGroupName clears the value of the "group_name" field.
func (m *AsAllGroupMutation) ClearGroupName() {
	m.group_name = nil
	m.clearedFields[asallgroup.FieldGroupName] = struct{}{}
}

// GroupNameCleared returns if the "group_name" field was cleared in this mutation.
func (m *AsAllGroupMutation) GroupNameCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldGroupName]
	return ok
}

// ResetGroupName resets all changes to the "group_name" field.
func (m *AsAllGroupMutation) ResetGroupName() {
	m.group_name = nil
	delete(m.clearedFields, asallgroup.FieldGroupName)
}

// SetGroupDescription sets the "group_description" field.
func (m *AsAllGroupMutation) SetGroupDescription(s string) {
	m.group_description = &s
}

// GroupDescription returns the value of the "group_description" field in the mutation.
func (m *AsAllGroupMutation) GroupDescription() (r string, exists bool) {
	v := m.group_description
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupDescription returns the old "group_description" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldGroupDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupDescription: %w", err)
	}
	return oldValue.GroupDescription, nil
}

// ClearGroupDescription clears the value of the "group_description" field.
func (m *AsAllGroupMutation) ClearGroupDescription() {
	m.group_description = nil
	m.clearedFields[asallgroup.FieldGroupDescription] = struct{}{}
}

// GroupDescriptionCleared returns if the "group_description" field was cleared in this mutation.
func (m *AsAllGroupMutation) GroupDescriptionCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldGroupDescription]
	return ok
}

// ResetGroupDescription resets all changes to the "group_description" field.
func (m *AsAllGroupMutation) ResetGroupDescription() {
	m.group_description = nil
	delete(m.clearedFields, asallgroup.FieldGroupDescription)
}

// SetGroupCode sets the "group_code" field.
func (m *AsAllGroupMutation) SetGroupCode(s string) {
	m.group_code = &s
}

// GroupCode returns the value of the "group_code" field in the mutation.
func (m *AsAllGroupMutation) GroupCode() (r string, exists bool) {
	v := m.group_code
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupCode returns the old "group_code" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldGroupCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupCode: %w", err)
	}
	return oldValue.GroupCode, nil
}

// ClearGroupCode clears the value of the "group_code" field.
func (m *AsAllGroupMutation) ClearGroupCode() {
	m.group_code = nil
	m.clearedFields[asallgroup.FieldGroupCode] = struct{}{}
}

// GroupCodeCleared returns if the "group_code" field was cleared in this mutation.
func (m *AsAllGroupMutation) GroupCodeCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldGroupCode]
	return ok
}

// ResetGroupCode resets all changes to the "group_code" field.
func (m *AsAllGroupMutation) ResetGroupCode() {
	m.group_code = nil
	delete(m.clearedFields, asallgroup.FieldGroupCode)
}

// SetDepth sets the "depth" field.
func (m *AsAllGroupMutation) SetDepth(i int64) {
	m.depth = &i
	m.adddepth = nil
}

// Depth returns the value of the "depth" field in the mutation.
func (m *AsAllGroupMutation) Depth() (r int64, exists bool) {
	v := m.depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "depth" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldDepth(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds i to the "depth" field.
func (m *AsAllGroupMutation) AddDepth(i int64) {
	if m.adddepth != nil {
		*m.adddepth += i
	} else {
		m.adddepth = &i
	}
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *AsAllGroupMutation) AddedDepth() (r int64, exists bool) {
	v := m.adddepth
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepth clears the value of the "depth" field.
func (m *AsAllGroupMutation) ClearDepth() {
	m.depth = nil
	m.adddepth = nil
	m.clearedFields[asallgroup.FieldDepth] = struct{}{}
}

// DepthCleared returns if the "depth" field was cleared in this mutation.
func (m *AsAllGroupMutation) DepthCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldDepth]
	return ok
}

// ResetDepth resets all changes to the "depth" field.
func (m *AsAllGroupMutation) ResetDepth() {
	m.depth = nil
	m.adddepth = nil
	delete(m.clearedFields, asallgroup.FieldDepth)
}

// SetType sets the "type" field.
func (m *AsAllGroupMutation) SetType(i int64) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *AsAllGroupMutation) GetType() (r int64, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *AsAllGroupMutation) AddType(i int64) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *AsAllGroupMutation) AddedType() (r int64, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *AsAllGroupMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[asallgroup.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *AsAllGroupMutation) TypeCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *AsAllGroupMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, asallgroup.FieldType)
}

// SetSocialCreditCode sets the "social_credit_code" field.
func (m *AsAllGroupMutation) SetSocialCreditCode(s string) {
	m.social_credit_code = &s
}

// SocialCreditCode returns the value of the "social_credit_code" field in the mutation.
func (m *AsAllGroupMutation) SocialCreditCode() (r string, exists bool) {
	v := m.social_credit_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialCreditCode returns the old "social_credit_code" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldSocialCreditCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialCreditCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialCreditCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialCreditCode: %w", err)
	}
	return oldValue.SocialCreditCode, nil
}

// ClearSocialCreditCode clears the value of the "social_credit_code" field.
func (m *AsAllGroupMutation) ClearSocialCreditCode() {
	m.social_credit_code = nil
	m.clearedFields[asallgroup.FieldSocialCreditCode] = struct{}{}
}

// SocialCreditCodeCleared returns if the "social_credit_code" field was cleared in this mutation.
func (m *AsAllGroupMutation) SocialCreditCodeCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldSocialCreditCode]
	return ok
}

// ResetSocialCreditCode resets all changes to the "social_credit_code" field.
func (m *AsAllGroupMutation) ResetSocialCreditCode() {
	m.social_credit_code = nil
	delete(m.clearedFields, asallgroup.FieldSocialCreditCode)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsAllGroupMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsAllGroupMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsAllGroupMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsAllGroupMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsAllGroupMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsAllGroupMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsAllGroupMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsAllGroupMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsAllGroupMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsAllGroupMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asallgroup.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsAllGroupMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsAllGroupMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asallgroup.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsAllGroupMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsAllGroupMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsAllGroupMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsAllGroupMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsAllGroupMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asallgroup.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsAllGroupMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsAllGroupMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asallgroup.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsAllGroupMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsAllGroupMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsAllGroupMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsAllGroupMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsAllGroupMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asallgroup.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsAllGroupMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsAllGroupMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asallgroup.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsAllGroupMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsAllGroupMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsAllGroupMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asallgroup.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsAllGroupMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsAllGroupMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asallgroup.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsAllGroupMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsAllGroupMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsAllGroup entity.
// If the AsAllGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAllGroupMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsAllGroupMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asallgroup.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsAllGroupMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asallgroup.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsAllGroupMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asallgroup.FieldUpdateTime)
}

// AddAllLayerIDs adds the "allLayer" edge to the AsLayer entity by ids.
func (m *AsAllGroupMutation) AddAllLayerIDs(ids ...int64) {
	if m.allLayer == nil {
		m.allLayer = make(map[int64]struct{})
	}
	for i := range ids {
		m.allLayer[ids[i]] = struct{}{}
	}
}

// ClearAllLayer clears the "allLayer" edge to the AsLayer entity.
func (m *AsAllGroupMutation) ClearAllLayer() {
	m.clearedallLayer = true
}

// AllLayerCleared reports if the "allLayer" edge to the AsLayer entity was cleared.
func (m *AsAllGroupMutation) AllLayerCleared() bool {
	return m.clearedallLayer
}

// RemoveAllLayerIDs removes the "allLayer" edge to the AsLayer entity by IDs.
func (m *AsAllGroupMutation) RemoveAllLayerIDs(ids ...int64) {
	if m.removedallLayer == nil {
		m.removedallLayer = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allLayer, ids[i])
		m.removedallLayer[ids[i]] = struct{}{}
	}
}

// RemovedAllLayer returns the removed IDs of the "allLayer" edge to the AsLayer entity.
func (m *AsAllGroupMutation) RemovedAllLayerIDs() (ids []int64) {
	for id := range m.removedallLayer {
		ids = append(ids, id)
	}
	return
}

// AllLayerIDs returns the "allLayer" edge IDs in the mutation.
func (m *AsAllGroupMutation) AllLayerIDs() (ids []int64) {
	for id := range m.allLayer {
		ids = append(ids, id)
	}
	return
}

// ResetAllLayer resets all changes to the "allLayer" edge.
func (m *AsAllGroupMutation) ResetAllLayer() {
	m.allLayer = nil
	m.clearedallLayer = false
	m.removedallLayer = nil
}

// AddAppPurchaseIDs adds the "appPurchases" edge to the AsMarketAppPurchase entity by ids.
func (m *AsAllGroupMutation) AddAppPurchaseIDs(ids ...int64) {
	if m.appPurchases == nil {
		m.appPurchases = make(map[int64]struct{})
	}
	for i := range ids {
		m.appPurchases[ids[i]] = struct{}{}
	}
}

// ClearAppPurchases clears the "appPurchases" edge to the AsMarketAppPurchase entity.
func (m *AsAllGroupMutation) ClearAppPurchases() {
	m.clearedappPurchases = true
}

// AppPurchasesCleared reports if the "appPurchases" edge to the AsMarketAppPurchase entity was cleared.
func (m *AsAllGroupMutation) AppPurchasesCleared() bool {
	return m.clearedappPurchases
}

// RemoveAppPurchaseIDs removes the "appPurchases" edge to the AsMarketAppPurchase entity by IDs.
func (m *AsAllGroupMutation) RemoveAppPurchaseIDs(ids ...int64) {
	if m.removedappPurchases == nil {
		m.removedappPurchases = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appPurchases, ids[i])
		m.removedappPurchases[ids[i]] = struct{}{}
	}
}

// RemovedAppPurchases returns the removed IDs of the "appPurchases" edge to the AsMarketAppPurchase entity.
func (m *AsAllGroupMutation) RemovedAppPurchasesIDs() (ids []int64) {
	for id := range m.removedappPurchases {
		ids = append(ids, id)
	}
	return
}

// AppPurchasesIDs returns the "appPurchases" edge IDs in the mutation.
func (m *AsAllGroupMutation) AppPurchasesIDs() (ids []int64) {
	for id := range m.appPurchases {
		ids = append(ids, id)
	}
	return
}

// ResetAppPurchases resets all changes to the "appPurchases" edge.
func (m *AsAllGroupMutation) ResetAppPurchases() {
	m.appPurchases = nil
	m.clearedappPurchases = false
	m.removedappPurchases = nil
}

// AddAllTenantIDs adds the "allTenants" edge to the AsGroupTenantRelations entity by ids.
func (m *AsAllGroupMutation) AddAllTenantIDs(ids ...int64) {
	if m.allTenants == nil {
		m.allTenants = make(map[int64]struct{})
	}
	for i := range ids {
		m.allTenants[ids[i]] = struct{}{}
	}
}

// ClearAllTenants clears the "allTenants" edge to the AsGroupTenantRelations entity.
func (m *AsAllGroupMutation) ClearAllTenants() {
	m.clearedallTenants = true
}

// AllTenantsCleared reports if the "allTenants" edge to the AsGroupTenantRelations entity was cleared.
func (m *AsAllGroupMutation) AllTenantsCleared() bool {
	return m.clearedallTenants
}

// RemoveAllTenantIDs removes the "allTenants" edge to the AsGroupTenantRelations entity by IDs.
func (m *AsAllGroupMutation) RemoveAllTenantIDs(ids ...int64) {
	if m.removedallTenants == nil {
		m.removedallTenants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allTenants, ids[i])
		m.removedallTenants[ids[i]] = struct{}{}
	}
}

// RemovedAllTenants returns the removed IDs of the "allTenants" edge to the AsGroupTenantRelations entity.
func (m *AsAllGroupMutation) RemovedAllTenantsIDs() (ids []int64) {
	for id := range m.removedallTenants {
		ids = append(ids, id)
	}
	return
}

// AllTenantsIDs returns the "allTenants" edge IDs in the mutation.
func (m *AsAllGroupMutation) AllTenantsIDs() (ids []int64) {
	for id := range m.allTenants {
		ids = append(ids, id)
	}
	return
}

// ResetAllTenants resets all changes to the "allTenants" edge.
func (m *AsAllGroupMutation) ResetAllTenants() {
	m.allTenants = nil
	m.clearedallTenants = false
	m.removedallTenants = nil
}

// AddAppGroupDistribIDs adds the "appGroupDistribs" edge to the AsMarketAppGroupDistribution entity by ids.
func (m *AsAllGroupMutation) AddAppGroupDistribIDs(ids ...int64) {
	if m.appGroupDistribs == nil {
		m.appGroupDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		m.appGroupDistribs[ids[i]] = struct{}{}
	}
}

// ClearAppGroupDistribs clears the "appGroupDistribs" edge to the AsMarketAppGroupDistribution entity.
func (m *AsAllGroupMutation) ClearAppGroupDistribs() {
	m.clearedappGroupDistribs = true
}

// AppGroupDistribsCleared reports if the "appGroupDistribs" edge to the AsMarketAppGroupDistribution entity was cleared.
func (m *AsAllGroupMutation) AppGroupDistribsCleared() bool {
	return m.clearedappGroupDistribs
}

// RemoveAppGroupDistribIDs removes the "appGroupDistribs" edge to the AsMarketAppGroupDistribution entity by IDs.
func (m *AsAllGroupMutation) RemoveAppGroupDistribIDs(ids ...int64) {
	if m.removedappGroupDistribs == nil {
		m.removedappGroupDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appGroupDistribs, ids[i])
		m.removedappGroupDistribs[ids[i]] = struct{}{}
	}
}

// RemovedAppGroupDistribs returns the removed IDs of the "appGroupDistribs" edge to the AsMarketAppGroupDistribution entity.
func (m *AsAllGroupMutation) RemovedAppGroupDistribsIDs() (ids []int64) {
	for id := range m.removedappGroupDistribs {
		ids = append(ids, id)
	}
	return
}

// AppGroupDistribsIDs returns the "appGroupDistribs" edge IDs in the mutation.
func (m *AsAllGroupMutation) AppGroupDistribsIDs() (ids []int64) {
	for id := range m.appGroupDistribs {
		ids = append(ids, id)
	}
	return
}

// ResetAppGroupDistribs resets all changes to the "appGroupDistribs" edge.
func (m *AsAllGroupMutation) ResetAppGroupDistribs() {
	m.appGroupDistribs = nil
	m.clearedappGroupDistribs = false
	m.removedappGroupDistribs = nil
}

// AddAppGroupDistribConfigIDs adds the "appGroupDistribConfigs" edge to the AsAppGroupDistributionData entity by ids.
func (m *AsAllGroupMutation) AddAppGroupDistribConfigIDs(ids ...int64) {
	if m.appGroupDistribConfigs == nil {
		m.appGroupDistribConfigs = make(map[int64]struct{})
	}
	for i := range ids {
		m.appGroupDistribConfigs[ids[i]] = struct{}{}
	}
}

// ClearAppGroupDistribConfigs clears the "appGroupDistribConfigs" edge to the AsAppGroupDistributionData entity.
func (m *AsAllGroupMutation) ClearAppGroupDistribConfigs() {
	m.clearedappGroupDistribConfigs = true
}

// AppGroupDistribConfigsCleared reports if the "appGroupDistribConfigs" edge to the AsAppGroupDistributionData entity was cleared.
func (m *AsAllGroupMutation) AppGroupDistribConfigsCleared() bool {
	return m.clearedappGroupDistribConfigs
}

// RemoveAppGroupDistribConfigIDs removes the "appGroupDistribConfigs" edge to the AsAppGroupDistributionData entity by IDs.
func (m *AsAllGroupMutation) RemoveAppGroupDistribConfigIDs(ids ...int64) {
	if m.removedappGroupDistribConfigs == nil {
		m.removedappGroupDistribConfigs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appGroupDistribConfigs, ids[i])
		m.removedappGroupDistribConfigs[ids[i]] = struct{}{}
	}
}

// RemovedAppGroupDistribConfigs returns the removed IDs of the "appGroupDistribConfigs" edge to the AsAppGroupDistributionData entity.
func (m *AsAllGroupMutation) RemovedAppGroupDistribConfigsIDs() (ids []int64) {
	for id := range m.removedappGroupDistribConfigs {
		ids = append(ids, id)
	}
	return
}

// AppGroupDistribConfigsIDs returns the "appGroupDistribConfigs" edge IDs in the mutation.
func (m *AsAllGroupMutation) AppGroupDistribConfigsIDs() (ids []int64) {
	for id := range m.appGroupDistribConfigs {
		ids = append(ids, id)
	}
	return
}

// ResetAppGroupDistribConfigs resets all changes to the "appGroupDistribConfigs" edge.
func (m *AsAllGroupMutation) ResetAppGroupDistribConfigs() {
	m.appGroupDistribConfigs = nil
	m.clearedappGroupDistribConfigs = false
	m.removedappGroupDistribConfigs = nil
}

// AddAppGroupDistribsRelationIDs adds the "appGroupDistribsRelation" edge to the AsMarketAppGroupDistributionRelation entity by ids.
func (m *AsAllGroupMutation) AddAppGroupDistribsRelationIDs(ids ...int64) {
	if m.appGroupDistribsRelation == nil {
		m.appGroupDistribsRelation = make(map[int64]struct{})
	}
	for i := range ids {
		m.appGroupDistribsRelation[ids[i]] = struct{}{}
	}
}

// ClearAppGroupDistribsRelation clears the "appGroupDistribsRelation" edge to the AsMarketAppGroupDistributionRelation entity.
func (m *AsAllGroupMutation) ClearAppGroupDistribsRelation() {
	m.clearedappGroupDistribsRelation = true
}

// AppGroupDistribsRelationCleared reports if the "appGroupDistribsRelation" edge to the AsMarketAppGroupDistributionRelation entity was cleared.
func (m *AsAllGroupMutation) AppGroupDistribsRelationCleared() bool {
	return m.clearedappGroupDistribsRelation
}

// RemoveAppGroupDistribsRelationIDs removes the "appGroupDistribsRelation" edge to the AsMarketAppGroupDistributionRelation entity by IDs.
func (m *AsAllGroupMutation) RemoveAppGroupDistribsRelationIDs(ids ...int64) {
	if m.removedappGroupDistribsRelation == nil {
		m.removedappGroupDistribsRelation = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appGroupDistribsRelation, ids[i])
		m.removedappGroupDistribsRelation[ids[i]] = struct{}{}
	}
}

// RemovedAppGroupDistribsRelation returns the removed IDs of the "appGroupDistribsRelation" edge to the AsMarketAppGroupDistributionRelation entity.
func (m *AsAllGroupMutation) RemovedAppGroupDistribsRelationIDs() (ids []int64) {
	for id := range m.removedappGroupDistribsRelation {
		ids = append(ids, id)
	}
	return
}

// AppGroupDistribsRelationIDs returns the "appGroupDistribsRelation" edge IDs in the mutation.
func (m *AsAllGroupMutation) AppGroupDistribsRelationIDs() (ids []int64) {
	for id := range m.appGroupDistribsRelation {
		ids = append(ids, id)
	}
	return
}

// ResetAppGroupDistribsRelation resets all changes to the "appGroupDistribsRelation" edge.
func (m *AsAllGroupMutation) ResetAppGroupDistribsRelation() {
	m.appGroupDistribsRelation = nil
	m.clearedappGroupDistribsRelation = false
	m.removedappGroupDistribsRelation = nil
}

// Where appends a list predicates to the AsAllGroupMutation builder.
func (m *AsAllGroupMutation) Where(ps ...predicate.AsAllGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsAllGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsAllGroup).
func (m *AsAllGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsAllGroupMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.tenant_code != nil {
		fields = append(fields, asallgroup.FieldTenantCode)
	}
	if m.group_name != nil {
		fields = append(fields, asallgroup.FieldGroupName)
	}
	if m.group_description != nil {
		fields = append(fields, asallgroup.FieldGroupDescription)
	}
	if m.group_code != nil {
		fields = append(fields, asallgroup.FieldGroupCode)
	}
	if m.depth != nil {
		fields = append(fields, asallgroup.FieldDepth)
	}
	if m._type != nil {
		fields = append(fields, asallgroup.FieldType)
	}
	if m.social_credit_code != nil {
		fields = append(fields, asallgroup.FieldSocialCreditCode)
	}
	if m.is_deleted != nil {
		fields = append(fields, asallgroup.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asallgroup.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asallgroup.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asallgroup.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asallgroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asallgroup.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsAllGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asallgroup.FieldTenantCode:
		return m.TenantCode()
	case asallgroup.FieldGroupName:
		return m.GroupName()
	case asallgroup.FieldGroupDescription:
		return m.GroupDescription()
	case asallgroup.FieldGroupCode:
		return m.GroupCode()
	case asallgroup.FieldDepth:
		return m.Depth()
	case asallgroup.FieldType:
		return m.GetType()
	case asallgroup.FieldSocialCreditCode:
		return m.SocialCreditCode()
	case asallgroup.FieldIsDeleted:
		return m.IsDeleted()
	case asallgroup.FieldStatus:
		return m.Status()
	case asallgroup.FieldCreateUser:
		return m.CreateUser()
	case asallgroup.FieldUpdateUser:
		return m.UpdateUser()
	case asallgroup.FieldCreateTime:
		return m.CreateTime()
	case asallgroup.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsAllGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asallgroup.FieldTenantCode:
		return m.OldTenantCode(ctx)
	case asallgroup.FieldGroupName:
		return m.OldGroupName(ctx)
	case asallgroup.FieldGroupDescription:
		return m.OldGroupDescription(ctx)
	case asallgroup.FieldGroupCode:
		return m.OldGroupCode(ctx)
	case asallgroup.FieldDepth:
		return m.OldDepth(ctx)
	case asallgroup.FieldType:
		return m.OldType(ctx)
	case asallgroup.FieldSocialCreditCode:
		return m.OldSocialCreditCode(ctx)
	case asallgroup.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asallgroup.FieldStatus:
		return m.OldStatus(ctx)
	case asallgroup.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asallgroup.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asallgroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asallgroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsAllGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsAllGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asallgroup.FieldTenantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantCode(v)
		return nil
	case asallgroup.FieldGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupName(v)
		return nil
	case asallgroup.FieldGroupDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupDescription(v)
		return nil
	case asallgroup.FieldGroupCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupCode(v)
		return nil
	case asallgroup.FieldDepth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	case asallgroup.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case asallgroup.FieldSocialCreditCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialCreditCode(v)
		return nil
	case asallgroup.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asallgroup.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asallgroup.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asallgroup.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asallgroup.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asallgroup.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsAllGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsAllGroupMutation) AddedFields() []string {
	var fields []string
	if m.adddepth != nil {
		fields = append(fields, asallgroup.FieldDepth)
	}
	if m.add_type != nil {
		fields = append(fields, asallgroup.FieldType)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asallgroup.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asallgroup.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asallgroup.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asallgroup.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsAllGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asallgroup.FieldDepth:
		return m.AddedDepth()
	case asallgroup.FieldType:
		return m.AddedType()
	case asallgroup.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asallgroup.FieldStatus:
		return m.AddedStatus()
	case asallgroup.FieldCreateUser:
		return m.AddedCreateUser()
	case asallgroup.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsAllGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asallgroup.FieldDepth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	case asallgroup.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case asallgroup.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asallgroup.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asallgroup.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asallgroup.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsAllGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsAllGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asallgroup.FieldTenantCode) {
		fields = append(fields, asallgroup.FieldTenantCode)
	}
	if m.FieldCleared(asallgroup.FieldGroupName) {
		fields = append(fields, asallgroup.FieldGroupName)
	}
	if m.FieldCleared(asallgroup.FieldGroupDescription) {
		fields = append(fields, asallgroup.FieldGroupDescription)
	}
	if m.FieldCleared(asallgroup.FieldGroupCode) {
		fields = append(fields, asallgroup.FieldGroupCode)
	}
	if m.FieldCleared(asallgroup.FieldDepth) {
		fields = append(fields, asallgroup.FieldDepth)
	}
	if m.FieldCleared(asallgroup.FieldType) {
		fields = append(fields, asallgroup.FieldType)
	}
	if m.FieldCleared(asallgroup.FieldSocialCreditCode) {
		fields = append(fields, asallgroup.FieldSocialCreditCode)
	}
	if m.FieldCleared(asallgroup.FieldStatus) {
		fields = append(fields, asallgroup.FieldStatus)
	}
	if m.FieldCleared(asallgroup.FieldCreateUser) {
		fields = append(fields, asallgroup.FieldCreateUser)
	}
	if m.FieldCleared(asallgroup.FieldUpdateUser) {
		fields = append(fields, asallgroup.FieldUpdateUser)
	}
	if m.FieldCleared(asallgroup.FieldCreateTime) {
		fields = append(fields, asallgroup.FieldCreateTime)
	}
	if m.FieldCleared(asallgroup.FieldUpdateTime) {
		fields = append(fields, asallgroup.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsAllGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsAllGroupMutation) ClearField(name string) error {
	switch name {
	case asallgroup.FieldTenantCode:
		m.ClearTenantCode()
		return nil
	case asallgroup.FieldGroupName:
		m.ClearGroupName()
		return nil
	case asallgroup.FieldGroupDescription:
		m.ClearGroupDescription()
		return nil
	case asallgroup.FieldGroupCode:
		m.ClearGroupCode()
		return nil
	case asallgroup.FieldDepth:
		m.ClearDepth()
		return nil
	case asallgroup.FieldType:
		m.ClearType()
		return nil
	case asallgroup.FieldSocialCreditCode:
		m.ClearSocialCreditCode()
		return nil
	case asallgroup.FieldStatus:
		m.ClearStatus()
		return nil
	case asallgroup.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asallgroup.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asallgroup.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asallgroup.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsAllGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsAllGroupMutation) ResetField(name string) error {
	switch name {
	case asallgroup.FieldTenantCode:
		m.ResetTenantCode()
		return nil
	case asallgroup.FieldGroupName:
		m.ResetGroupName()
		return nil
	case asallgroup.FieldGroupDescription:
		m.ResetGroupDescription()
		return nil
	case asallgroup.FieldGroupCode:
		m.ResetGroupCode()
		return nil
	case asallgroup.FieldDepth:
		m.ResetDepth()
		return nil
	case asallgroup.FieldType:
		m.ResetType()
		return nil
	case asallgroup.FieldSocialCreditCode:
		m.ResetSocialCreditCode()
		return nil
	case asallgroup.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asallgroup.FieldStatus:
		m.ResetStatus()
		return nil
	case asallgroup.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asallgroup.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asallgroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asallgroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsAllGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsAllGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.allLayer != nil {
		edges = append(edges, asallgroup.EdgeAllLayer)
	}
	if m.appPurchases != nil {
		edges = append(edges, asallgroup.EdgeAppPurchases)
	}
	if m.allTenants != nil {
		edges = append(edges, asallgroup.EdgeAllTenants)
	}
	if m.appGroupDistribs != nil {
		edges = append(edges, asallgroup.EdgeAppGroupDistribs)
	}
	if m.appGroupDistribConfigs != nil {
		edges = append(edges, asallgroup.EdgeAppGroupDistribConfigs)
	}
	if m.appGroupDistribsRelation != nil {
		edges = append(edges, asallgroup.EdgeAppGroupDistribsRelation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsAllGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asallgroup.EdgeAllLayer:
		ids := make([]ent.Value, 0, len(m.allLayer))
		for id := range m.allLayer {
			ids = append(ids, id)
		}
		return ids
	case asallgroup.EdgeAppPurchases:
		ids := make([]ent.Value, 0, len(m.appPurchases))
		for id := range m.appPurchases {
			ids = append(ids, id)
		}
		return ids
	case asallgroup.EdgeAllTenants:
		ids := make([]ent.Value, 0, len(m.allTenants))
		for id := range m.allTenants {
			ids = append(ids, id)
		}
		return ids
	case asallgroup.EdgeAppGroupDistribs:
		ids := make([]ent.Value, 0, len(m.appGroupDistribs))
		for id := range m.appGroupDistribs {
			ids = append(ids, id)
		}
		return ids
	case asallgroup.EdgeAppGroupDistribConfigs:
		ids := make([]ent.Value, 0, len(m.appGroupDistribConfigs))
		for id := range m.appGroupDistribConfigs {
			ids = append(ids, id)
		}
		return ids
	case asallgroup.EdgeAppGroupDistribsRelation:
		ids := make([]ent.Value, 0, len(m.appGroupDistribsRelation))
		for id := range m.appGroupDistribsRelation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsAllGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedallLayer != nil {
		edges = append(edges, asallgroup.EdgeAllLayer)
	}
	if m.removedappPurchases != nil {
		edges = append(edges, asallgroup.EdgeAppPurchases)
	}
	if m.removedallTenants != nil {
		edges = append(edges, asallgroup.EdgeAllTenants)
	}
	if m.removedappGroupDistribs != nil {
		edges = append(edges, asallgroup.EdgeAppGroupDistribs)
	}
	if m.removedappGroupDistribConfigs != nil {
		edges = append(edges, asallgroup.EdgeAppGroupDistribConfigs)
	}
	if m.removedappGroupDistribsRelation != nil {
		edges = append(edges, asallgroup.EdgeAppGroupDistribsRelation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsAllGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asallgroup.EdgeAllLayer:
		ids := make([]ent.Value, 0, len(m.removedallLayer))
		for id := range m.removedallLayer {
			ids = append(ids, id)
		}
		return ids
	case asallgroup.EdgeAppPurchases:
		ids := make([]ent.Value, 0, len(m.removedappPurchases))
		for id := range m.removedappPurchases {
			ids = append(ids, id)
		}
		return ids
	case asallgroup.EdgeAllTenants:
		ids := make([]ent.Value, 0, len(m.removedallTenants))
		for id := range m.removedallTenants {
			ids = append(ids, id)
		}
		return ids
	case asallgroup.EdgeAppGroupDistribs:
		ids := make([]ent.Value, 0, len(m.removedappGroupDistribs))
		for id := range m.removedappGroupDistribs {
			ids = append(ids, id)
		}
		return ids
	case asallgroup.EdgeAppGroupDistribConfigs:
		ids := make([]ent.Value, 0, len(m.removedappGroupDistribConfigs))
		for id := range m.removedappGroupDistribConfigs {
			ids = append(ids, id)
		}
		return ids
	case asallgroup.EdgeAppGroupDistribsRelation:
		ids := make([]ent.Value, 0, len(m.removedappGroupDistribsRelation))
		for id := range m.removedappGroupDistribsRelation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsAllGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedallLayer {
		edges = append(edges, asallgroup.EdgeAllLayer)
	}
	if m.clearedappPurchases {
		edges = append(edges, asallgroup.EdgeAppPurchases)
	}
	if m.clearedallTenants {
		edges = append(edges, asallgroup.EdgeAllTenants)
	}
	if m.clearedappGroupDistribs {
		edges = append(edges, asallgroup.EdgeAppGroupDistribs)
	}
	if m.clearedappGroupDistribConfigs {
		edges = append(edges, asallgroup.EdgeAppGroupDistribConfigs)
	}
	if m.clearedappGroupDistribsRelation {
		edges = append(edges, asallgroup.EdgeAppGroupDistribsRelation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsAllGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case asallgroup.EdgeAllLayer:
		return m.clearedallLayer
	case asallgroup.EdgeAppPurchases:
		return m.clearedappPurchases
	case asallgroup.EdgeAllTenants:
		return m.clearedallTenants
	case asallgroup.EdgeAppGroupDistribs:
		return m.clearedappGroupDistribs
	case asallgroup.EdgeAppGroupDistribConfigs:
		return m.clearedappGroupDistribConfigs
	case asallgroup.EdgeAppGroupDistribsRelation:
		return m.clearedappGroupDistribsRelation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsAllGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AsAllGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsAllGroupMutation) ResetEdge(name string) error {
	switch name {
	case asallgroup.EdgeAllLayer:
		m.ResetAllLayer()
		return nil
	case asallgroup.EdgeAppPurchases:
		m.ResetAppPurchases()
		return nil
	case asallgroup.EdgeAllTenants:
		m.ResetAllTenants()
		return nil
	case asallgroup.EdgeAppGroupDistribs:
		m.ResetAppGroupDistribs()
		return nil
	case asallgroup.EdgeAppGroupDistribConfigs:
		m.ResetAppGroupDistribConfigs()
		return nil
	case asallgroup.EdgeAppGroupDistribsRelation:
		m.ResetAppGroupDistribsRelation()
		return nil
	}
	return fmt.Errorf("unknown AsAllGroup edge %s", name)
}

// AsAppGroupDistributionDataMutation represents an operation that mutates the AsAppGroupDistributionData nodes in the graph.
type AsAppGroupDistributionDataMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	_config        *string
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	appx           *int64
	clearedappx    bool
	groupx         *int64
	clearedgroupx  bool
	done           bool
	oldValue       func(context.Context) (*AsAppGroupDistributionData, error)
	predicates     []predicate.AsAppGroupDistributionData
}

var _ ent.Mutation = (*AsAppGroupDistributionDataMutation)(nil)

// asappgroupdistributiondataOption allows management of the mutation configuration using functional options.
type asappgroupdistributiondataOption func(*AsAppGroupDistributionDataMutation)

// newAsAppGroupDistributionDataMutation creates new mutation for the AsAppGroupDistributionData entity.
func newAsAppGroupDistributionDataMutation(c config, op Op, opts ...asappgroupdistributiondataOption) *AsAppGroupDistributionDataMutation {
	m := &AsAppGroupDistributionDataMutation{
		config:        c,
		op:            op,
		typ:           TypeAsAppGroupDistributionData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsAppGroupDistributionDataID sets the ID field of the mutation.
func withAsAppGroupDistributionDataID(id int64) asappgroupdistributiondataOption {
	return func(m *AsAppGroupDistributionDataMutation) {
		var (
			err   error
			once  sync.Once
			value *AsAppGroupDistributionData
		)
		m.oldValue = func(ctx context.Context) (*AsAppGroupDistributionData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsAppGroupDistributionData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsAppGroupDistributionData sets the old AsAppGroupDistributionData of the mutation.
func withAsAppGroupDistributionData(node *AsAppGroupDistributionData) asappgroupdistributiondataOption {
	return func(m *AsAppGroupDistributionDataMutation) {
		m.oldValue = func(context.Context) (*AsAppGroupDistributionData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsAppGroupDistributionDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsAppGroupDistributionDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsAppGroupDistributionData entities.
func (m *AsAppGroupDistributionDataMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsAppGroupDistributionDataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsAppGroupDistributionDataMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsAppGroupDistributionData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AsAppGroupDistributionDataMutation) SetAppID(i int64) {
	m.appx = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsAppGroupDistributionDataMutation) AppID() (r int64, exists bool) {
	v := m.appx
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsAppGroupDistributionData entity.
// If the AsAppGroupDistributionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAppGroupDistributionDataMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AsAppGroupDistributionDataMutation) ClearAppID() {
	m.appx = nil
	m.clearedFields[asappgroupdistributiondata.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[asappgroupdistributiondata.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsAppGroupDistributionDataMutation) ResetAppID() {
	m.appx = nil
	delete(m.clearedFields, asappgroupdistributiondata.FieldAppID)
}

// SetGroupID sets the "group_id" field.
func (m *AsAppGroupDistributionDataMutation) SetGroupID(i int64) {
	m.groupx = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *AsAppGroupDistributionDataMutation) GroupID() (r int64, exists bool) {
	v := m.groupx
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the AsAppGroupDistributionData entity.
// If the AsAppGroupDistributionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAppGroupDistributionDataMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *AsAppGroupDistributionDataMutation) ClearGroupID() {
	m.groupx = nil
	m.clearedFields[asappgroupdistributiondata.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[asappgroupdistributiondata.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *AsAppGroupDistributionDataMutation) ResetGroupID() {
	m.groupx = nil
	delete(m.clearedFields, asappgroupdistributiondata.FieldGroupID)
}

// SetConfig sets the "config" field.
func (m *AsAppGroupDistributionDataMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *AsAppGroupDistributionDataMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the AsAppGroupDistributionData entity.
// If the AsAppGroupDistributionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAppGroupDistributionDataMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *AsAppGroupDistributionDataMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[asappgroupdistributiondata.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[asappgroupdistributiondata.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *AsAppGroupDistributionDataMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, asappgroupdistributiondata.FieldConfig)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsAppGroupDistributionDataMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsAppGroupDistributionDataMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsAppGroupDistributionData entity.
// If the AsAppGroupDistributionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAppGroupDistributionDataMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsAppGroupDistributionDataMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsAppGroupDistributionDataMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsAppGroupDistributionDataMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsAppGroupDistributionDataMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsAppGroupDistributionDataMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsAppGroupDistributionData entity.
// If the AsAppGroupDistributionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAppGroupDistributionDataMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsAppGroupDistributionDataMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsAppGroupDistributionDataMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsAppGroupDistributionDataMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asappgroupdistributiondata.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asappgroupdistributiondata.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsAppGroupDistributionDataMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asappgroupdistributiondata.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsAppGroupDistributionDataMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsAppGroupDistributionDataMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsAppGroupDistributionData entity.
// If the AsAppGroupDistributionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAppGroupDistributionDataMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsAppGroupDistributionDataMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsAppGroupDistributionDataMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsAppGroupDistributionDataMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asappgroupdistributiondata.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asappgroupdistributiondata.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsAppGroupDistributionDataMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asappgroupdistributiondata.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsAppGroupDistributionDataMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsAppGroupDistributionDataMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsAppGroupDistributionData entity.
// If the AsAppGroupDistributionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAppGroupDistributionDataMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsAppGroupDistributionDataMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsAppGroupDistributionDataMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsAppGroupDistributionDataMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asappgroupdistributiondata.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asappgroupdistributiondata.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsAppGroupDistributionDataMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asappgroupdistributiondata.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsAppGroupDistributionDataMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsAppGroupDistributionDataMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsAppGroupDistributionData entity.
// If the AsAppGroupDistributionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAppGroupDistributionDataMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsAppGroupDistributionDataMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asappgroupdistributiondata.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asappgroupdistributiondata.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsAppGroupDistributionDataMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asappgroupdistributiondata.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsAppGroupDistributionDataMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsAppGroupDistributionDataMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsAppGroupDistributionData entity.
// If the AsAppGroupDistributionData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsAppGroupDistributionDataMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsAppGroupDistributionDataMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asappgroupdistributiondata.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asappgroupdistributiondata.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsAppGroupDistributionDataMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asappgroupdistributiondata.FieldUpdateTime)
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsAppGroupDistributionDataMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsAppGroupDistributionDataMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsAppGroupDistributionDataMutation) AppxCleared() bool {
	return m.AppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsAppGroupDistributionDataMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsAppGroupDistributionDataMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsAppGroupDistributionDataMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// SetGroupxID sets the "groupx" edge to the AsAllGroup entity by id.
func (m *AsAppGroupDistributionDataMutation) SetGroupxID(id int64) {
	m.groupx = &id
}

// ClearGroupx clears the "groupx" edge to the AsAllGroup entity.
func (m *AsAppGroupDistributionDataMutation) ClearGroupx() {
	m.clearedgroupx = true
}

// GroupxCleared reports if the "groupx" edge to the AsAllGroup entity was cleared.
func (m *AsAppGroupDistributionDataMutation) GroupxCleared() bool {
	return m.GroupIDCleared() || m.clearedgroupx
}

// GroupxID returns the "groupx" edge ID in the mutation.
func (m *AsAppGroupDistributionDataMutation) GroupxID() (id int64, exists bool) {
	if m.groupx != nil {
		return *m.groupx, true
	}
	return
}

// GroupxIDs returns the "groupx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupxID instead. It exists only for internal usage by the builders.
func (m *AsAppGroupDistributionDataMutation) GroupxIDs() (ids []int64) {
	if id := m.groupx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupx resets all changes to the "groupx" edge.
func (m *AsAppGroupDistributionDataMutation) ResetGroupx() {
	m.groupx = nil
	m.clearedgroupx = false
}

// Where appends a list predicates to the AsAppGroupDistributionDataMutation builder.
func (m *AsAppGroupDistributionDataMutation) Where(ps ...predicate.AsAppGroupDistributionData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsAppGroupDistributionDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsAppGroupDistributionData).
func (m *AsAppGroupDistributionDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsAppGroupDistributionDataMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.appx != nil {
		fields = append(fields, asappgroupdistributiondata.FieldAppID)
	}
	if m.groupx != nil {
		fields = append(fields, asappgroupdistributiondata.FieldGroupID)
	}
	if m._config != nil {
		fields = append(fields, asappgroupdistributiondata.FieldConfig)
	}
	if m.is_deleted != nil {
		fields = append(fields, asappgroupdistributiondata.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asappgroupdistributiondata.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asappgroupdistributiondata.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asappgroupdistributiondata.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asappgroupdistributiondata.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asappgroupdistributiondata.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsAppGroupDistributionDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asappgroupdistributiondata.FieldAppID:
		return m.AppID()
	case asappgroupdistributiondata.FieldGroupID:
		return m.GroupID()
	case asappgroupdistributiondata.FieldConfig:
		return m.Config()
	case asappgroupdistributiondata.FieldIsDeleted:
		return m.IsDeleted()
	case asappgroupdistributiondata.FieldStatus:
		return m.Status()
	case asappgroupdistributiondata.FieldCreateUser:
		return m.CreateUser()
	case asappgroupdistributiondata.FieldUpdateUser:
		return m.UpdateUser()
	case asappgroupdistributiondata.FieldCreateTime:
		return m.CreateTime()
	case asappgroupdistributiondata.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsAppGroupDistributionDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asappgroupdistributiondata.FieldAppID:
		return m.OldAppID(ctx)
	case asappgroupdistributiondata.FieldGroupID:
		return m.OldGroupID(ctx)
	case asappgroupdistributiondata.FieldConfig:
		return m.OldConfig(ctx)
	case asappgroupdistributiondata.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asappgroupdistributiondata.FieldStatus:
		return m.OldStatus(ctx)
	case asappgroupdistributiondata.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asappgroupdistributiondata.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asappgroupdistributiondata.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asappgroupdistributiondata.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsAppGroupDistributionData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsAppGroupDistributionDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asappgroupdistributiondata.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asappgroupdistributiondata.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case asappgroupdistributiondata.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case asappgroupdistributiondata.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asappgroupdistributiondata.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asappgroupdistributiondata.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asappgroupdistributiondata.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asappgroupdistributiondata.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asappgroupdistributiondata.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsAppGroupDistributionData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsAppGroupDistributionDataMutation) AddedFields() []string {
	var fields []string
	if m.addis_deleted != nil {
		fields = append(fields, asappgroupdistributiondata.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asappgroupdistributiondata.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asappgroupdistributiondata.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asappgroupdistributiondata.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsAppGroupDistributionDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asappgroupdistributiondata.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asappgroupdistributiondata.FieldStatus:
		return m.AddedStatus()
	case asappgroupdistributiondata.FieldCreateUser:
		return m.AddedCreateUser()
	case asappgroupdistributiondata.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsAppGroupDistributionDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asappgroupdistributiondata.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asappgroupdistributiondata.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asappgroupdistributiondata.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asappgroupdistributiondata.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsAppGroupDistributionData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsAppGroupDistributionDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asappgroupdistributiondata.FieldAppID) {
		fields = append(fields, asappgroupdistributiondata.FieldAppID)
	}
	if m.FieldCleared(asappgroupdistributiondata.FieldGroupID) {
		fields = append(fields, asappgroupdistributiondata.FieldGroupID)
	}
	if m.FieldCleared(asappgroupdistributiondata.FieldConfig) {
		fields = append(fields, asappgroupdistributiondata.FieldConfig)
	}
	if m.FieldCleared(asappgroupdistributiondata.FieldStatus) {
		fields = append(fields, asappgroupdistributiondata.FieldStatus)
	}
	if m.FieldCleared(asappgroupdistributiondata.FieldCreateUser) {
		fields = append(fields, asappgroupdistributiondata.FieldCreateUser)
	}
	if m.FieldCleared(asappgroupdistributiondata.FieldUpdateUser) {
		fields = append(fields, asappgroupdistributiondata.FieldUpdateUser)
	}
	if m.FieldCleared(asappgroupdistributiondata.FieldCreateTime) {
		fields = append(fields, asappgroupdistributiondata.FieldCreateTime)
	}
	if m.FieldCleared(asappgroupdistributiondata.FieldUpdateTime) {
		fields = append(fields, asappgroupdistributiondata.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsAppGroupDistributionDataMutation) ClearField(name string) error {
	switch name {
	case asappgroupdistributiondata.FieldAppID:
		m.ClearAppID()
		return nil
	case asappgroupdistributiondata.FieldGroupID:
		m.ClearGroupID()
		return nil
	case asappgroupdistributiondata.FieldConfig:
		m.ClearConfig()
		return nil
	case asappgroupdistributiondata.FieldStatus:
		m.ClearStatus()
		return nil
	case asappgroupdistributiondata.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asappgroupdistributiondata.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asappgroupdistributiondata.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asappgroupdistributiondata.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsAppGroupDistributionData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsAppGroupDistributionDataMutation) ResetField(name string) error {
	switch name {
	case asappgroupdistributiondata.FieldAppID:
		m.ResetAppID()
		return nil
	case asappgroupdistributiondata.FieldGroupID:
		m.ResetGroupID()
		return nil
	case asappgroupdistributiondata.FieldConfig:
		m.ResetConfig()
		return nil
	case asappgroupdistributiondata.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asappgroupdistributiondata.FieldStatus:
		m.ResetStatus()
		return nil
	case asappgroupdistributiondata.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asappgroupdistributiondata.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asappgroupdistributiondata.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asappgroupdistributiondata.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsAppGroupDistributionData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsAppGroupDistributionDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.appx != nil {
		edges = append(edges, asappgroupdistributiondata.EdgeAppx)
	}
	if m.groupx != nil {
		edges = append(edges, asappgroupdistributiondata.EdgeGroupx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsAppGroupDistributionDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asappgroupdistributiondata.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	case asappgroupdistributiondata.EdgeGroupx:
		if id := m.groupx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsAppGroupDistributionDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsAppGroupDistributionDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedappx {
		edges = append(edges, asappgroupdistributiondata.EdgeAppx)
	}
	if m.clearedgroupx {
		edges = append(edges, asappgroupdistributiondata.EdgeGroupx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsAppGroupDistributionDataMutation) EdgeCleared(name string) bool {
	switch name {
	case asappgroupdistributiondata.EdgeAppx:
		return m.clearedappx
	case asappgroupdistributiondata.EdgeGroupx:
		return m.clearedgroupx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsAppGroupDistributionDataMutation) ClearEdge(name string) error {
	switch name {
	case asappgroupdistributiondata.EdgeAppx:
		m.ClearAppx()
		return nil
	case asappgroupdistributiondata.EdgeGroupx:
		m.ClearGroupx()
		return nil
	}
	return fmt.Errorf("unknown AsAppGroupDistributionData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsAppGroupDistributionDataMutation) ResetEdge(name string) error {
	switch name {
	case asappgroupdistributiondata.EdgeAppx:
		m.ResetAppx()
		return nil
	case asappgroupdistributiondata.EdgeGroupx:
		m.ResetGroupx()
		return nil
	}
	return fmt.Errorf("unknown AsAppGroupDistributionData edge %s", name)
}

// AsDictMutation represents an operation that mutates the AsDict nodes in the graph.
type AsDictMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	code             *string
	dict_key         *int64
	adddict_key      *int64
	dict_value       *string
	sort             *int64
	addsort          *int64
	remark           *string
	currversion      *int64
	addcurrversion   *int64
	version          *int64
	addversion       *int64
	dictparent_id    *int64
	adddictparent_id *int64
	is_deleted       *int64
	addis_deleted    *int64
	status           *int64
	addstatus        *int64
	create_user      *int64
	addcreate_user   *int64
	update_user      *int64
	addupdate_user   *int64
	create_time      *date.DateTime
	update_time      *date.DateTime
	clearedFields    map[string]struct{}
	parentx          *int64
	clearedparentx   bool
	childrens        map[int64]struct{}
	removedchildrens map[int64]struct{}
	clearedchildrens bool
	done             bool
	oldValue         func(context.Context) (*AsDict, error)
	predicates       []predicate.AsDict
}

var _ ent.Mutation = (*AsDictMutation)(nil)

// asdictOption allows management of the mutation configuration using functional options.
type asdictOption func(*AsDictMutation)

// newAsDictMutation creates new mutation for the AsDict entity.
func newAsDictMutation(c config, op Op, opts ...asdictOption) *AsDictMutation {
	m := &AsDictMutation{
		config:        c,
		op:            op,
		typ:           TypeAsDict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsDictID sets the ID field of the mutation.
func withAsDictID(id int64) asdictOption {
	return func(m *AsDictMutation) {
		var (
			err   error
			once  sync.Once
			value *AsDict
		)
		m.oldValue = func(ctx context.Context) (*AsDict, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsDict.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsDict sets the old AsDict of the mutation.
func withAsDict(node *AsDict) asdictOption {
	return func(m *AsDictMutation) {
		m.oldValue = func(context.Context) (*AsDict, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsDictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsDictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsDict entities.
func (m *AsDictMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsDictMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsDictMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsDict.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetParentID sets the "parent_id" field.
func (m *AsDictMutation) SetParentID(i int64) {
	m.parentx = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *AsDictMutation) ParentID() (r int64, exists bool) {
	v := m.parentx
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *AsDictMutation) ClearParentID() {
	m.parentx = nil
	m.clearedFields[asdict.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *AsDictMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[asdict.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *AsDictMutation) ResetParentID() {
	m.parentx = nil
	delete(m.clearedFields, asdict.FieldParentID)
}

// SetCode sets the "code" field.
func (m *AsDictMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AsDictMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *AsDictMutation) ClearCode() {
	m.code = nil
	m.clearedFields[asdict.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *AsDictMutation) CodeCleared() bool {
	_, ok := m.clearedFields[asdict.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *AsDictMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, asdict.FieldCode)
}

// SetDictKey sets the "dict_key" field.
func (m *AsDictMutation) SetDictKey(i int64) {
	m.dict_key = &i
	m.adddict_key = nil
}

// DictKey returns the value of the "dict_key" field in the mutation.
func (m *AsDictMutation) DictKey() (r int64, exists bool) {
	v := m.dict_key
	if v == nil {
		return
	}
	return *v, true
}

// OldDictKey returns the old "dict_key" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldDictKey(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictKey: %w", err)
	}
	return oldValue.DictKey, nil
}

// AddDictKey adds i to the "dict_key" field.
func (m *AsDictMutation) AddDictKey(i int64) {
	if m.adddict_key != nil {
		*m.adddict_key += i
	} else {
		m.adddict_key = &i
	}
}

// AddedDictKey returns the value that was added to the "dict_key" field in this mutation.
func (m *AsDictMutation) AddedDictKey() (r int64, exists bool) {
	v := m.adddict_key
	if v == nil {
		return
	}
	return *v, true
}

// ClearDictKey clears the value of the "dict_key" field.
func (m *AsDictMutation) ClearDictKey() {
	m.dict_key = nil
	m.adddict_key = nil
	m.clearedFields[asdict.FieldDictKey] = struct{}{}
}

// DictKeyCleared returns if the "dict_key" field was cleared in this mutation.
func (m *AsDictMutation) DictKeyCleared() bool {
	_, ok := m.clearedFields[asdict.FieldDictKey]
	return ok
}

// ResetDictKey resets all changes to the "dict_key" field.
func (m *AsDictMutation) ResetDictKey() {
	m.dict_key = nil
	m.adddict_key = nil
	delete(m.clearedFields, asdict.FieldDictKey)
}

// SetDictValue sets the "dict_value" field.
func (m *AsDictMutation) SetDictValue(s string) {
	m.dict_value = &s
}

// DictValue returns the value of the "dict_value" field in the mutation.
func (m *AsDictMutation) DictValue() (r string, exists bool) {
	v := m.dict_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDictValue returns the old "dict_value" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldDictValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictValue: %w", err)
	}
	return oldValue.DictValue, nil
}

// ClearDictValue clears the value of the "dict_value" field.
func (m *AsDictMutation) ClearDictValue() {
	m.dict_value = nil
	m.clearedFields[asdict.FieldDictValue] = struct{}{}
}

// DictValueCleared returns if the "dict_value" field was cleared in this mutation.
func (m *AsDictMutation) DictValueCleared() bool {
	_, ok := m.clearedFields[asdict.FieldDictValue]
	return ok
}

// ResetDictValue resets all changes to the "dict_value" field.
func (m *AsDictMutation) ResetDictValue() {
	m.dict_value = nil
	delete(m.clearedFields, asdict.FieldDictValue)
}

// SetSort sets the "sort" field.
func (m *AsDictMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AsDictMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AsDictMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AsDictMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *AsDictMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[asdict.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *AsDictMutation) SortCleared() bool {
	_, ok := m.clearedFields[asdict.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *AsDictMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, asdict.FieldSort)
}

// SetRemark sets the "remark" field.
func (m *AsDictMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AsDictMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AsDictMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[asdict.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AsDictMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[asdict.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AsDictMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, asdict.FieldRemark)
}

// SetCurrversion sets the "currversion" field.
func (m *AsDictMutation) SetCurrversion(i int64) {
	m.currversion = &i
	m.addcurrversion = nil
}

// Currversion returns the value of the "currversion" field in the mutation.
func (m *AsDictMutation) Currversion() (r int64, exists bool) {
	v := m.currversion
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrversion returns the old "currversion" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldCurrversion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrversion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrversion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrversion: %w", err)
	}
	return oldValue.Currversion, nil
}

// AddCurrversion adds i to the "currversion" field.
func (m *AsDictMutation) AddCurrversion(i int64) {
	if m.addcurrversion != nil {
		*m.addcurrversion += i
	} else {
		m.addcurrversion = &i
	}
}

// AddedCurrversion returns the value that was added to the "currversion" field in this mutation.
func (m *AsDictMutation) AddedCurrversion() (r int64, exists bool) {
	v := m.addcurrversion
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrversion clears the value of the "currversion" field.
func (m *AsDictMutation) ClearCurrversion() {
	m.currversion = nil
	m.addcurrversion = nil
	m.clearedFields[asdict.FieldCurrversion] = struct{}{}
}

// CurrversionCleared returns if the "currversion" field was cleared in this mutation.
func (m *AsDictMutation) CurrversionCleared() bool {
	_, ok := m.clearedFields[asdict.FieldCurrversion]
	return ok
}

// ResetCurrversion resets all changes to the "currversion" field.
func (m *AsDictMutation) ResetCurrversion() {
	m.currversion = nil
	m.addcurrversion = nil
	delete(m.clearedFields, asdict.FieldCurrversion)
}

// SetVersion sets the "version" field.
func (m *AsDictMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *AsDictMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *AsDictMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *AsDictMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersion clears the value of the "version" field.
func (m *AsDictMutation) ClearVersion() {
	m.version = nil
	m.addversion = nil
	m.clearedFields[asdict.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *AsDictMutation) VersionCleared() bool {
	_, ok := m.clearedFields[asdict.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *AsDictMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
	delete(m.clearedFields, asdict.FieldVersion)
}

// SetDictparentID sets the "dictparent_id" field.
func (m *AsDictMutation) SetDictparentID(i int64) {
	m.dictparent_id = &i
	m.adddictparent_id = nil
}

// DictparentID returns the value of the "dictparent_id" field in the mutation.
func (m *AsDictMutation) DictparentID() (r int64, exists bool) {
	v := m.dictparent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDictparentID returns the old "dictparent_id" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldDictparentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictparentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictparentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictparentID: %w", err)
	}
	return oldValue.DictparentID, nil
}

// AddDictparentID adds i to the "dictparent_id" field.
func (m *AsDictMutation) AddDictparentID(i int64) {
	if m.adddictparent_id != nil {
		*m.adddictparent_id += i
	} else {
		m.adddictparent_id = &i
	}
}

// AddedDictparentID returns the value that was added to the "dictparent_id" field in this mutation.
func (m *AsDictMutation) AddedDictparentID() (r int64, exists bool) {
	v := m.adddictparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDictparentID clears the value of the "dictparent_id" field.
func (m *AsDictMutation) ClearDictparentID() {
	m.dictparent_id = nil
	m.adddictparent_id = nil
	m.clearedFields[asdict.FieldDictparentID] = struct{}{}
}

// DictparentIDCleared returns if the "dictparent_id" field was cleared in this mutation.
func (m *AsDictMutation) DictparentIDCleared() bool {
	_, ok := m.clearedFields[asdict.FieldDictparentID]
	return ok
}

// ResetDictparentID resets all changes to the "dictparent_id" field.
func (m *AsDictMutation) ResetDictparentID() {
	m.dictparent_id = nil
	m.adddictparent_id = nil
	delete(m.clearedFields, asdict.FieldDictparentID)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsDictMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsDictMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsDictMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsDictMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsDictMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsDictMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsDictMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsDictMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsDictMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsDictMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asdict.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsDictMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asdict.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsDictMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asdict.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsDictMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsDictMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsDictMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsDictMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsDictMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asdict.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsDictMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asdict.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsDictMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asdict.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsDictMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsDictMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsDictMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsDictMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsDictMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asdict.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsDictMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asdict.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsDictMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asdict.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsDictMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsDictMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsDictMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asdict.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsDictMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asdict.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsDictMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asdict.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsDictMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsDictMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsDict entity.
// If the AsDict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsDictMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsDictMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asdict.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsDictMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asdict.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsDictMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asdict.FieldUpdateTime)
}

// SetParentxID sets the "parentx" edge to the AsDict entity by id.
func (m *AsDictMutation) SetParentxID(id int64) {
	m.parentx = &id
}

// ClearParentx clears the "parentx" edge to the AsDict entity.
func (m *AsDictMutation) ClearParentx() {
	m.clearedparentx = true
}

// ParentxCleared reports if the "parentx" edge to the AsDict entity was cleared.
func (m *AsDictMutation) ParentxCleared() bool {
	return m.ParentIDCleared() || m.clearedparentx
}

// ParentxID returns the "parentx" edge ID in the mutation.
func (m *AsDictMutation) ParentxID() (id int64, exists bool) {
	if m.parentx != nil {
		return *m.parentx, true
	}
	return
}

// ParentxIDs returns the "parentx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentxID instead. It exists only for internal usage by the builders.
func (m *AsDictMutation) ParentxIDs() (ids []int64) {
	if id := m.parentx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentx resets all changes to the "parentx" edge.
func (m *AsDictMutation) ResetParentx() {
	m.parentx = nil
	m.clearedparentx = false
}

// AddChildrenIDs adds the "childrens" edge to the AsDict entity by ids.
func (m *AsDictMutation) AddChildrenIDs(ids ...int64) {
	if m.childrens == nil {
		m.childrens = make(map[int64]struct{})
	}
	for i := range ids {
		m.childrens[ids[i]] = struct{}{}
	}
}

// ClearChildrens clears the "childrens" edge to the AsDict entity.
func (m *AsDictMutation) ClearChildrens() {
	m.clearedchildrens = true
}

// ChildrensCleared reports if the "childrens" edge to the AsDict entity was cleared.
func (m *AsDictMutation) ChildrensCleared() bool {
	return m.clearedchildrens
}

// RemoveChildrenIDs removes the "childrens" edge to the AsDict entity by IDs.
func (m *AsDictMutation) RemoveChildrenIDs(ids ...int64) {
	if m.removedchildrens == nil {
		m.removedchildrens = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.childrens, ids[i])
		m.removedchildrens[ids[i]] = struct{}{}
	}
}

// RemovedChildrens returns the removed IDs of the "childrens" edge to the AsDict entity.
func (m *AsDictMutation) RemovedChildrensIDs() (ids []int64) {
	for id := range m.removedchildrens {
		ids = append(ids, id)
	}
	return
}

// ChildrensIDs returns the "childrens" edge IDs in the mutation.
func (m *AsDictMutation) ChildrensIDs() (ids []int64) {
	for id := range m.childrens {
		ids = append(ids, id)
	}
	return
}

// ResetChildrens resets all changes to the "childrens" edge.
func (m *AsDictMutation) ResetChildrens() {
	m.childrens = nil
	m.clearedchildrens = false
	m.removedchildrens = nil
}

// Where appends a list predicates to the AsDictMutation builder.
func (m *AsDictMutation) Where(ps ...predicate.AsDict) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsDictMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsDict).
func (m *AsDictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsDictMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.parentx != nil {
		fields = append(fields, asdict.FieldParentID)
	}
	if m.code != nil {
		fields = append(fields, asdict.FieldCode)
	}
	if m.dict_key != nil {
		fields = append(fields, asdict.FieldDictKey)
	}
	if m.dict_value != nil {
		fields = append(fields, asdict.FieldDictValue)
	}
	if m.sort != nil {
		fields = append(fields, asdict.FieldSort)
	}
	if m.remark != nil {
		fields = append(fields, asdict.FieldRemark)
	}
	if m.currversion != nil {
		fields = append(fields, asdict.FieldCurrversion)
	}
	if m.version != nil {
		fields = append(fields, asdict.FieldVersion)
	}
	if m.dictparent_id != nil {
		fields = append(fields, asdict.FieldDictparentID)
	}
	if m.is_deleted != nil {
		fields = append(fields, asdict.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asdict.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asdict.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asdict.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asdict.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asdict.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsDictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asdict.FieldParentID:
		return m.ParentID()
	case asdict.FieldCode:
		return m.Code()
	case asdict.FieldDictKey:
		return m.DictKey()
	case asdict.FieldDictValue:
		return m.DictValue()
	case asdict.FieldSort:
		return m.Sort()
	case asdict.FieldRemark:
		return m.Remark()
	case asdict.FieldCurrversion:
		return m.Currversion()
	case asdict.FieldVersion:
		return m.Version()
	case asdict.FieldDictparentID:
		return m.DictparentID()
	case asdict.FieldIsDeleted:
		return m.IsDeleted()
	case asdict.FieldStatus:
		return m.Status()
	case asdict.FieldCreateUser:
		return m.CreateUser()
	case asdict.FieldUpdateUser:
		return m.UpdateUser()
	case asdict.FieldCreateTime:
		return m.CreateTime()
	case asdict.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsDictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asdict.FieldParentID:
		return m.OldParentID(ctx)
	case asdict.FieldCode:
		return m.OldCode(ctx)
	case asdict.FieldDictKey:
		return m.OldDictKey(ctx)
	case asdict.FieldDictValue:
		return m.OldDictValue(ctx)
	case asdict.FieldSort:
		return m.OldSort(ctx)
	case asdict.FieldRemark:
		return m.OldRemark(ctx)
	case asdict.FieldCurrversion:
		return m.OldCurrversion(ctx)
	case asdict.FieldVersion:
		return m.OldVersion(ctx)
	case asdict.FieldDictparentID:
		return m.OldDictparentID(ctx)
	case asdict.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asdict.FieldStatus:
		return m.OldStatus(ctx)
	case asdict.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asdict.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asdict.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asdict.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsDict field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsDictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asdict.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case asdict.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case asdict.FieldDictKey:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictKey(v)
		return nil
	case asdict.FieldDictValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictValue(v)
		return nil
	case asdict.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case asdict.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case asdict.FieldCurrversion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrversion(v)
		return nil
	case asdict.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case asdict.FieldDictparentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictparentID(v)
		return nil
	case asdict.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asdict.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asdict.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asdict.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asdict.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asdict.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsDict field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsDictMutation) AddedFields() []string {
	var fields []string
	if m.adddict_key != nil {
		fields = append(fields, asdict.FieldDictKey)
	}
	if m.addsort != nil {
		fields = append(fields, asdict.FieldSort)
	}
	if m.addcurrversion != nil {
		fields = append(fields, asdict.FieldCurrversion)
	}
	if m.addversion != nil {
		fields = append(fields, asdict.FieldVersion)
	}
	if m.adddictparent_id != nil {
		fields = append(fields, asdict.FieldDictparentID)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asdict.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asdict.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asdict.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asdict.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsDictMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asdict.FieldDictKey:
		return m.AddedDictKey()
	case asdict.FieldSort:
		return m.AddedSort()
	case asdict.FieldCurrversion:
		return m.AddedCurrversion()
	case asdict.FieldVersion:
		return m.AddedVersion()
	case asdict.FieldDictparentID:
		return m.AddedDictparentID()
	case asdict.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asdict.FieldStatus:
		return m.AddedStatus()
	case asdict.FieldCreateUser:
		return m.AddedCreateUser()
	case asdict.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsDictMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asdict.FieldDictKey:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDictKey(v)
		return nil
	case asdict.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case asdict.FieldCurrversion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrversion(v)
		return nil
	case asdict.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case asdict.FieldDictparentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDictparentID(v)
		return nil
	case asdict.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asdict.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asdict.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asdict.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsDict numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsDictMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asdict.FieldParentID) {
		fields = append(fields, asdict.FieldParentID)
	}
	if m.FieldCleared(asdict.FieldCode) {
		fields = append(fields, asdict.FieldCode)
	}
	if m.FieldCleared(asdict.FieldDictKey) {
		fields = append(fields, asdict.FieldDictKey)
	}
	if m.FieldCleared(asdict.FieldDictValue) {
		fields = append(fields, asdict.FieldDictValue)
	}
	if m.FieldCleared(asdict.FieldSort) {
		fields = append(fields, asdict.FieldSort)
	}
	if m.FieldCleared(asdict.FieldRemark) {
		fields = append(fields, asdict.FieldRemark)
	}
	if m.FieldCleared(asdict.FieldCurrversion) {
		fields = append(fields, asdict.FieldCurrversion)
	}
	if m.FieldCleared(asdict.FieldVersion) {
		fields = append(fields, asdict.FieldVersion)
	}
	if m.FieldCleared(asdict.FieldDictparentID) {
		fields = append(fields, asdict.FieldDictparentID)
	}
	if m.FieldCleared(asdict.FieldStatus) {
		fields = append(fields, asdict.FieldStatus)
	}
	if m.FieldCleared(asdict.FieldCreateUser) {
		fields = append(fields, asdict.FieldCreateUser)
	}
	if m.FieldCleared(asdict.FieldUpdateUser) {
		fields = append(fields, asdict.FieldUpdateUser)
	}
	if m.FieldCleared(asdict.FieldCreateTime) {
		fields = append(fields, asdict.FieldCreateTime)
	}
	if m.FieldCleared(asdict.FieldUpdateTime) {
		fields = append(fields, asdict.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsDictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsDictMutation) ClearField(name string) error {
	switch name {
	case asdict.FieldParentID:
		m.ClearParentID()
		return nil
	case asdict.FieldCode:
		m.ClearCode()
		return nil
	case asdict.FieldDictKey:
		m.ClearDictKey()
		return nil
	case asdict.FieldDictValue:
		m.ClearDictValue()
		return nil
	case asdict.FieldSort:
		m.ClearSort()
		return nil
	case asdict.FieldRemark:
		m.ClearRemark()
		return nil
	case asdict.FieldCurrversion:
		m.ClearCurrversion()
		return nil
	case asdict.FieldVersion:
		m.ClearVersion()
		return nil
	case asdict.FieldDictparentID:
		m.ClearDictparentID()
		return nil
	case asdict.FieldStatus:
		m.ClearStatus()
		return nil
	case asdict.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asdict.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asdict.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asdict.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsDict nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsDictMutation) ResetField(name string) error {
	switch name {
	case asdict.FieldParentID:
		m.ResetParentID()
		return nil
	case asdict.FieldCode:
		m.ResetCode()
		return nil
	case asdict.FieldDictKey:
		m.ResetDictKey()
		return nil
	case asdict.FieldDictValue:
		m.ResetDictValue()
		return nil
	case asdict.FieldSort:
		m.ResetSort()
		return nil
	case asdict.FieldRemark:
		m.ResetRemark()
		return nil
	case asdict.FieldCurrversion:
		m.ResetCurrversion()
		return nil
	case asdict.FieldVersion:
		m.ResetVersion()
		return nil
	case asdict.FieldDictparentID:
		m.ResetDictparentID()
		return nil
	case asdict.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asdict.FieldStatus:
		m.ResetStatus()
		return nil
	case asdict.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asdict.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asdict.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asdict.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsDict field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsDictMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parentx != nil {
		edges = append(edges, asdict.EdgeParentx)
	}
	if m.childrens != nil {
		edges = append(edges, asdict.EdgeChildrens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsDictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asdict.EdgeParentx:
		if id := m.parentx; id != nil {
			return []ent.Value{*id}
		}
	case asdict.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.childrens))
		for id := range m.childrens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsDictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchildrens != nil {
		edges = append(edges, asdict.EdgeChildrens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsDictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asdict.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.removedchildrens))
		for id := range m.removedchildrens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsDictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparentx {
		edges = append(edges, asdict.EdgeParentx)
	}
	if m.clearedchildrens {
		edges = append(edges, asdict.EdgeChildrens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsDictMutation) EdgeCleared(name string) bool {
	switch name {
	case asdict.EdgeParentx:
		return m.clearedparentx
	case asdict.EdgeChildrens:
		return m.clearedchildrens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsDictMutation) ClearEdge(name string) error {
	switch name {
	case asdict.EdgeParentx:
		m.ClearParentx()
		return nil
	}
	return fmt.Errorf("unknown AsDict unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsDictMutation) ResetEdge(name string) error {
	switch name {
	case asdict.EdgeParentx:
		m.ResetParentx()
		return nil
	case asdict.EdgeChildrens:
		m.ResetChildrens()
		return nil
	}
	return fmt.Errorf("unknown AsDict edge %s", name)
}

// AsGroupTenantRelationsMutation represents an operation that mutates the AsGroupTenantRelations nodes in the graph.
type AsGroupTenantRelationsMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	_type          *int64
	add_type       *int64
	sort           *int64
	addsort        *int64
	serial         *int64
	addserial      *int64
	group_code     *string
	expires_time   *date.DateTime
	is_hide        *int64
	addis_hide     *int64
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	group          *int64
	clearedgroup   bool
	tenant         *int64
	clearedtenant  bool
	done           bool
	oldValue       func(context.Context) (*AsGroupTenantRelations, error)
	predicates     []predicate.AsGroupTenantRelations
}

var _ ent.Mutation = (*AsGroupTenantRelationsMutation)(nil)

// asgrouptenantrelationsOption allows management of the mutation configuration using functional options.
type asgrouptenantrelationsOption func(*AsGroupTenantRelationsMutation)

// newAsGroupTenantRelationsMutation creates new mutation for the AsGroupTenantRelations entity.
func newAsGroupTenantRelationsMutation(c config, op Op, opts ...asgrouptenantrelationsOption) *AsGroupTenantRelationsMutation {
	m := &AsGroupTenantRelationsMutation{
		config:        c,
		op:            op,
		typ:           TypeAsGroupTenantRelations,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsGroupTenantRelationsID sets the ID field of the mutation.
func withAsGroupTenantRelationsID(id int64) asgrouptenantrelationsOption {
	return func(m *AsGroupTenantRelationsMutation) {
		var (
			err   error
			once  sync.Once
			value *AsGroupTenantRelations
		)
		m.oldValue = func(ctx context.Context) (*AsGroupTenantRelations, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsGroupTenantRelations.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsGroupTenantRelations sets the old AsGroupTenantRelations of the mutation.
func withAsGroupTenantRelations(node *AsGroupTenantRelations) asgrouptenantrelationsOption {
	return func(m *AsGroupTenantRelationsMutation) {
		m.oldValue = func(context.Context) (*AsGroupTenantRelations, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsGroupTenantRelationsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsGroupTenantRelationsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsGroupTenantRelations entities.
func (m *AsGroupTenantRelationsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsGroupTenantRelationsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsGroupTenantRelationsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsGroupTenantRelations.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetParentID sets the "parent_id" field.
func (m *AsGroupTenantRelationsMutation) SetParentID(i int64) {
	m.group = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *AsGroupTenantRelationsMutation) ParentID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *AsGroupTenantRelationsMutation) ClearParentID() {
	m.group = nil
	m.clearedFields[asgrouptenantrelations.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *AsGroupTenantRelationsMutation) ResetParentID() {
	m.group = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldParentID)
}

// SetSonID sets the "son_id" field.
func (m *AsGroupTenantRelationsMutation) SetSonID(i int64) {
	m.tenant = &i
}

// SonID returns the value of the "son_id" field in the mutation.
func (m *AsGroupTenantRelationsMutation) SonID() (r int64, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldSonID returns the old "son_id" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldSonID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSonID: %w", err)
	}
	return oldValue.SonID, nil
}

// ClearSonID clears the value of the "son_id" field.
func (m *AsGroupTenantRelationsMutation) ClearSonID() {
	m.tenant = nil
	m.clearedFields[asgrouptenantrelations.FieldSonID] = struct{}{}
}

// SonIDCleared returns if the "son_id" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) SonIDCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldSonID]
	return ok
}

// ResetSonID resets all changes to the "son_id" field.
func (m *AsGroupTenantRelationsMutation) ResetSonID() {
	m.tenant = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldSonID)
}

// SetType sets the "type" field.
func (m *AsGroupTenantRelationsMutation) SetType(i int64) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *AsGroupTenantRelationsMutation) GetType() (r int64, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *AsGroupTenantRelationsMutation) AddType(i int64) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *AsGroupTenantRelationsMutation) AddedType() (r int64, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *AsGroupTenantRelationsMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[asgrouptenantrelations.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) TypeCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *AsGroupTenantRelationsMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldType)
}

// SetSort sets the "sort" field.
func (m *AsGroupTenantRelationsMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AsGroupTenantRelationsMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AsGroupTenantRelationsMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AsGroupTenantRelationsMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *AsGroupTenantRelationsMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[asgrouptenantrelations.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) SortCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *AsGroupTenantRelationsMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldSort)
}

// SetSerial sets the "serial" field.
func (m *AsGroupTenantRelationsMutation) SetSerial(i int64) {
	m.serial = &i
	m.addserial = nil
}

// Serial returns the value of the "serial" field in the mutation.
func (m *AsGroupTenantRelationsMutation) Serial() (r int64, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldSerial(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// AddSerial adds i to the "serial" field.
func (m *AsGroupTenantRelationsMutation) AddSerial(i int64) {
	if m.addserial != nil {
		*m.addserial += i
	} else {
		m.addserial = &i
	}
}

// AddedSerial returns the value that was added to the "serial" field in this mutation.
func (m *AsGroupTenantRelationsMutation) AddedSerial() (r int64, exists bool) {
	v := m.addserial
	if v == nil {
		return
	}
	return *v, true
}

// ClearSerial clears the value of the "serial" field.
func (m *AsGroupTenantRelationsMutation) ClearSerial() {
	m.serial = nil
	m.addserial = nil
	m.clearedFields[asgrouptenantrelations.FieldSerial] = struct{}{}
}

// SerialCleared returns if the "serial" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) SerialCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldSerial]
	return ok
}

// ResetSerial resets all changes to the "serial" field.
func (m *AsGroupTenantRelationsMutation) ResetSerial() {
	m.serial = nil
	m.addserial = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldSerial)
}

// SetGroupCode sets the "group_code" field.
func (m *AsGroupTenantRelationsMutation) SetGroupCode(s string) {
	m.group_code = &s
}

// GroupCode returns the value of the "group_code" field in the mutation.
func (m *AsGroupTenantRelationsMutation) GroupCode() (r string, exists bool) {
	v := m.group_code
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupCode returns the old "group_code" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldGroupCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupCode: %w", err)
	}
	return oldValue.GroupCode, nil
}

// ClearGroupCode clears the value of the "group_code" field.
func (m *AsGroupTenantRelationsMutation) ClearGroupCode() {
	m.group_code = nil
	m.clearedFields[asgrouptenantrelations.FieldGroupCode] = struct{}{}
}

// GroupCodeCleared returns if the "group_code" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) GroupCodeCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldGroupCode]
	return ok
}

// ResetGroupCode resets all changes to the "group_code" field.
func (m *AsGroupTenantRelationsMutation) ResetGroupCode() {
	m.group_code = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldGroupCode)
}

// SetExpiresTime sets the "expires_time" field.
func (m *AsGroupTenantRelationsMutation) SetExpiresTime(dt date.DateTime) {
	m.expires_time = &dt
}

// ExpiresTime returns the value of the "expires_time" field in the mutation.
func (m *AsGroupTenantRelationsMutation) ExpiresTime() (r date.DateTime, exists bool) {
	v := m.expires_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresTime returns the old "expires_time" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldExpiresTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresTime: %w", err)
	}
	return oldValue.ExpiresTime, nil
}

// ClearExpiresTime clears the value of the "expires_time" field.
func (m *AsGroupTenantRelationsMutation) ClearExpiresTime() {
	m.expires_time = nil
	m.clearedFields[asgrouptenantrelations.FieldExpiresTime] = struct{}{}
}

// ExpiresTimeCleared returns if the "expires_time" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) ExpiresTimeCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldExpiresTime]
	return ok
}

// ResetExpiresTime resets all changes to the "expires_time" field.
func (m *AsGroupTenantRelationsMutation) ResetExpiresTime() {
	m.expires_time = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldExpiresTime)
}

// SetIsHide sets the "is_hide" field.
func (m *AsGroupTenantRelationsMutation) SetIsHide(i int64) {
	m.is_hide = &i
	m.addis_hide = nil
}

// IsHide returns the value of the "is_hide" field in the mutation.
func (m *AsGroupTenantRelationsMutation) IsHide() (r int64, exists bool) {
	v := m.is_hide
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHide returns the old "is_hide" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldIsHide(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHide is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHide requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHide: %w", err)
	}
	return oldValue.IsHide, nil
}

// AddIsHide adds i to the "is_hide" field.
func (m *AsGroupTenantRelationsMutation) AddIsHide(i int64) {
	if m.addis_hide != nil {
		*m.addis_hide += i
	} else {
		m.addis_hide = &i
	}
}

// AddedIsHide returns the value that was added to the "is_hide" field in this mutation.
func (m *AsGroupTenantRelationsMutation) AddedIsHide() (r int64, exists bool) {
	v := m.addis_hide
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsHide clears the value of the "is_hide" field.
func (m *AsGroupTenantRelationsMutation) ClearIsHide() {
	m.is_hide = nil
	m.addis_hide = nil
	m.clearedFields[asgrouptenantrelations.FieldIsHide] = struct{}{}
}

// IsHideCleared returns if the "is_hide" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) IsHideCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldIsHide]
	return ok
}

// ResetIsHide resets all changes to the "is_hide" field.
func (m *AsGroupTenantRelationsMutation) ResetIsHide() {
	m.is_hide = nil
	m.addis_hide = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldIsHide)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsGroupTenantRelationsMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsGroupTenantRelationsMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsGroupTenantRelationsMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsGroupTenantRelationsMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsGroupTenantRelationsMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsGroupTenantRelationsMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsGroupTenantRelationsMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsGroupTenantRelationsMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsGroupTenantRelationsMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsGroupTenantRelationsMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asgrouptenantrelations.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsGroupTenantRelationsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsGroupTenantRelationsMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsGroupTenantRelationsMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsGroupTenantRelationsMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsGroupTenantRelationsMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsGroupTenantRelationsMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asgrouptenantrelations.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsGroupTenantRelationsMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsGroupTenantRelationsMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsGroupTenantRelationsMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsGroupTenantRelationsMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsGroupTenantRelationsMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsGroupTenantRelationsMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asgrouptenantrelations.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsGroupTenantRelationsMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsGroupTenantRelationsMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsGroupTenantRelationsMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsGroupTenantRelationsMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asgrouptenantrelations.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsGroupTenantRelationsMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsGroupTenantRelationsMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsGroupTenantRelationsMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsGroupTenantRelations entity.
// If the AsGroupTenantRelations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsGroupTenantRelationsMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsGroupTenantRelationsMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asgrouptenantrelations.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asgrouptenantrelations.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsGroupTenantRelationsMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asgrouptenantrelations.FieldUpdateTime)
}

// SetGroupID sets the "group" edge to the AsAllGroup entity by id.
func (m *AsGroupTenantRelationsMutation) SetGroupID(id int64) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the AsAllGroup entity.
func (m *AsGroupTenantRelationsMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the AsAllGroup entity was cleared.
func (m *AsGroupTenantRelationsMutation) GroupCleared() bool {
	return m.ParentIDCleared() || m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *AsGroupTenantRelationsMutation) GroupID() (id int64, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *AsGroupTenantRelationsMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *AsGroupTenantRelationsMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// SetTenantID sets the "tenant" edge to the AsTenant entity by id.
func (m *AsGroupTenantRelationsMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the AsTenant entity.
func (m *AsGroupTenantRelationsMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the AsTenant entity was cleared.
func (m *AsGroupTenantRelationsMutation) TenantCleared() bool {
	return m.SonIDCleared() || m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *AsGroupTenantRelationsMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AsGroupTenantRelationsMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AsGroupTenantRelationsMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the AsGroupTenantRelationsMutation builder.
func (m *AsGroupTenantRelationsMutation) Where(ps ...predicate.AsGroupTenantRelations) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsGroupTenantRelationsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsGroupTenantRelations).
func (m *AsGroupTenantRelationsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsGroupTenantRelationsMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.group != nil {
		fields = append(fields, asgrouptenantrelations.FieldParentID)
	}
	if m.tenant != nil {
		fields = append(fields, asgrouptenantrelations.FieldSonID)
	}
	if m._type != nil {
		fields = append(fields, asgrouptenantrelations.FieldType)
	}
	if m.sort != nil {
		fields = append(fields, asgrouptenantrelations.FieldSort)
	}
	if m.serial != nil {
		fields = append(fields, asgrouptenantrelations.FieldSerial)
	}
	if m.group_code != nil {
		fields = append(fields, asgrouptenantrelations.FieldGroupCode)
	}
	if m.expires_time != nil {
		fields = append(fields, asgrouptenantrelations.FieldExpiresTime)
	}
	if m.is_hide != nil {
		fields = append(fields, asgrouptenantrelations.FieldIsHide)
	}
	if m.is_deleted != nil {
		fields = append(fields, asgrouptenantrelations.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asgrouptenantrelations.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asgrouptenantrelations.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asgrouptenantrelations.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asgrouptenantrelations.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asgrouptenantrelations.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsGroupTenantRelationsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asgrouptenantrelations.FieldParentID:
		return m.ParentID()
	case asgrouptenantrelations.FieldSonID:
		return m.SonID()
	case asgrouptenantrelations.FieldType:
		return m.GetType()
	case asgrouptenantrelations.FieldSort:
		return m.Sort()
	case asgrouptenantrelations.FieldSerial:
		return m.Serial()
	case asgrouptenantrelations.FieldGroupCode:
		return m.GroupCode()
	case asgrouptenantrelations.FieldExpiresTime:
		return m.ExpiresTime()
	case asgrouptenantrelations.FieldIsHide:
		return m.IsHide()
	case asgrouptenantrelations.FieldIsDeleted:
		return m.IsDeleted()
	case asgrouptenantrelations.FieldStatus:
		return m.Status()
	case asgrouptenantrelations.FieldCreateUser:
		return m.CreateUser()
	case asgrouptenantrelations.FieldUpdateUser:
		return m.UpdateUser()
	case asgrouptenantrelations.FieldCreateTime:
		return m.CreateTime()
	case asgrouptenantrelations.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsGroupTenantRelationsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asgrouptenantrelations.FieldParentID:
		return m.OldParentID(ctx)
	case asgrouptenantrelations.FieldSonID:
		return m.OldSonID(ctx)
	case asgrouptenantrelations.FieldType:
		return m.OldType(ctx)
	case asgrouptenantrelations.FieldSort:
		return m.OldSort(ctx)
	case asgrouptenantrelations.FieldSerial:
		return m.OldSerial(ctx)
	case asgrouptenantrelations.FieldGroupCode:
		return m.OldGroupCode(ctx)
	case asgrouptenantrelations.FieldExpiresTime:
		return m.OldExpiresTime(ctx)
	case asgrouptenantrelations.FieldIsHide:
		return m.OldIsHide(ctx)
	case asgrouptenantrelations.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asgrouptenantrelations.FieldStatus:
		return m.OldStatus(ctx)
	case asgrouptenantrelations.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asgrouptenantrelations.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asgrouptenantrelations.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asgrouptenantrelations.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsGroupTenantRelations field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsGroupTenantRelationsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asgrouptenantrelations.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case asgrouptenantrelations.FieldSonID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSonID(v)
		return nil
	case asgrouptenantrelations.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case asgrouptenantrelations.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case asgrouptenantrelations.FieldSerial:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case asgrouptenantrelations.FieldGroupCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupCode(v)
		return nil
	case asgrouptenantrelations.FieldExpiresTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresTime(v)
		return nil
	case asgrouptenantrelations.FieldIsHide:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHide(v)
		return nil
	case asgrouptenantrelations.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asgrouptenantrelations.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asgrouptenantrelations.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asgrouptenantrelations.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asgrouptenantrelations.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asgrouptenantrelations.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsGroupTenantRelations field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsGroupTenantRelationsMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, asgrouptenantrelations.FieldType)
	}
	if m.addsort != nil {
		fields = append(fields, asgrouptenantrelations.FieldSort)
	}
	if m.addserial != nil {
		fields = append(fields, asgrouptenantrelations.FieldSerial)
	}
	if m.addis_hide != nil {
		fields = append(fields, asgrouptenantrelations.FieldIsHide)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asgrouptenantrelations.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asgrouptenantrelations.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asgrouptenantrelations.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asgrouptenantrelations.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsGroupTenantRelationsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asgrouptenantrelations.FieldType:
		return m.AddedType()
	case asgrouptenantrelations.FieldSort:
		return m.AddedSort()
	case asgrouptenantrelations.FieldSerial:
		return m.AddedSerial()
	case asgrouptenantrelations.FieldIsHide:
		return m.AddedIsHide()
	case asgrouptenantrelations.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asgrouptenantrelations.FieldStatus:
		return m.AddedStatus()
	case asgrouptenantrelations.FieldCreateUser:
		return m.AddedCreateUser()
	case asgrouptenantrelations.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsGroupTenantRelationsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asgrouptenantrelations.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case asgrouptenantrelations.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case asgrouptenantrelations.FieldSerial:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSerial(v)
		return nil
	case asgrouptenantrelations.FieldIsHide:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsHide(v)
		return nil
	case asgrouptenantrelations.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asgrouptenantrelations.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asgrouptenantrelations.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asgrouptenantrelations.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsGroupTenantRelations numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsGroupTenantRelationsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asgrouptenantrelations.FieldParentID) {
		fields = append(fields, asgrouptenantrelations.FieldParentID)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldSonID) {
		fields = append(fields, asgrouptenantrelations.FieldSonID)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldType) {
		fields = append(fields, asgrouptenantrelations.FieldType)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldSort) {
		fields = append(fields, asgrouptenantrelations.FieldSort)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldSerial) {
		fields = append(fields, asgrouptenantrelations.FieldSerial)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldGroupCode) {
		fields = append(fields, asgrouptenantrelations.FieldGroupCode)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldExpiresTime) {
		fields = append(fields, asgrouptenantrelations.FieldExpiresTime)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldIsHide) {
		fields = append(fields, asgrouptenantrelations.FieldIsHide)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldStatus) {
		fields = append(fields, asgrouptenantrelations.FieldStatus)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldCreateUser) {
		fields = append(fields, asgrouptenantrelations.FieldCreateUser)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldUpdateUser) {
		fields = append(fields, asgrouptenantrelations.FieldUpdateUser)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldCreateTime) {
		fields = append(fields, asgrouptenantrelations.FieldCreateTime)
	}
	if m.FieldCleared(asgrouptenantrelations.FieldUpdateTime) {
		fields = append(fields, asgrouptenantrelations.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsGroupTenantRelationsMutation) ClearField(name string) error {
	switch name {
	case asgrouptenantrelations.FieldParentID:
		m.ClearParentID()
		return nil
	case asgrouptenantrelations.FieldSonID:
		m.ClearSonID()
		return nil
	case asgrouptenantrelations.FieldType:
		m.ClearType()
		return nil
	case asgrouptenantrelations.FieldSort:
		m.ClearSort()
		return nil
	case asgrouptenantrelations.FieldSerial:
		m.ClearSerial()
		return nil
	case asgrouptenantrelations.FieldGroupCode:
		m.ClearGroupCode()
		return nil
	case asgrouptenantrelations.FieldExpiresTime:
		m.ClearExpiresTime()
		return nil
	case asgrouptenantrelations.FieldIsHide:
		m.ClearIsHide()
		return nil
	case asgrouptenantrelations.FieldStatus:
		m.ClearStatus()
		return nil
	case asgrouptenantrelations.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asgrouptenantrelations.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asgrouptenantrelations.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asgrouptenantrelations.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsGroupTenantRelations nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsGroupTenantRelationsMutation) ResetField(name string) error {
	switch name {
	case asgrouptenantrelations.FieldParentID:
		m.ResetParentID()
		return nil
	case asgrouptenantrelations.FieldSonID:
		m.ResetSonID()
		return nil
	case asgrouptenantrelations.FieldType:
		m.ResetType()
		return nil
	case asgrouptenantrelations.FieldSort:
		m.ResetSort()
		return nil
	case asgrouptenantrelations.FieldSerial:
		m.ResetSerial()
		return nil
	case asgrouptenantrelations.FieldGroupCode:
		m.ResetGroupCode()
		return nil
	case asgrouptenantrelations.FieldExpiresTime:
		m.ResetExpiresTime()
		return nil
	case asgrouptenantrelations.FieldIsHide:
		m.ResetIsHide()
		return nil
	case asgrouptenantrelations.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asgrouptenantrelations.FieldStatus:
		m.ResetStatus()
		return nil
	case asgrouptenantrelations.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asgrouptenantrelations.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asgrouptenantrelations.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asgrouptenantrelations.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsGroupTenantRelations field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsGroupTenantRelationsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, asgrouptenantrelations.EdgeGroup)
	}
	if m.tenant != nil {
		edges = append(edges, asgrouptenantrelations.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsGroupTenantRelationsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asgrouptenantrelations.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case asgrouptenantrelations.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsGroupTenantRelationsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsGroupTenantRelationsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, asgrouptenantrelations.EdgeGroup)
	}
	if m.clearedtenant {
		edges = append(edges, asgrouptenantrelations.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsGroupTenantRelationsMutation) EdgeCleared(name string) bool {
	switch name {
	case asgrouptenantrelations.EdgeGroup:
		return m.clearedgroup
	case asgrouptenantrelations.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsGroupTenantRelationsMutation) ClearEdge(name string) error {
	switch name {
	case asgrouptenantrelations.EdgeGroup:
		m.ClearGroup()
		return nil
	case asgrouptenantrelations.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown AsGroupTenantRelations unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsGroupTenantRelationsMutation) ResetEdge(name string) error {
	switch name {
	case asgrouptenantrelations.EdgeGroup:
		m.ResetGroup()
		return nil
	case asgrouptenantrelations.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown AsGroupTenantRelations edge %s", name)
}

// AsInnerAgencyMutation represents an operation that mutates the AsInnerAgency nodes in the graph.
type AsInnerAgencyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	agency_name         *string
	agency_code         *string
	tenant_code         *string
	is_deleted          *int64
	addis_deleted       *int64
	status              *int64
	addstatus           *int64
	create_user         *int64
	addcreate_user      *int64
	update_user         *int64
	addupdate_user      *int64
	create_time         *date.DateTime
	update_time         *date.DateTime
	clearedFields       map[string]struct{}
	parent              *int64
	clearedparent       bool
	childrens           map[int64]struct{}
	removedchildrens    map[int64]struct{}
	clearedchildrens    bool
	jobs                map[int64]struct{}
	removedjobs         map[int64]struct{}
	clearedjobs         bool
	users               map[int64]struct{}
	removedusers        map[int64]struct{}
	clearedusers        bool
	persons             map[int64]struct{}
	removedpersons      map[int64]struct{}
	clearedpersons      bool
	roleDistribs        map[int64]struct{}
	removedroleDistribs map[int64]struct{}
	clearedroleDistribs bool
	done                bool
	oldValue            func(context.Context) (*AsInnerAgency, error)
	predicates          []predicate.AsInnerAgency
}

var _ ent.Mutation = (*AsInnerAgencyMutation)(nil)

// asinneragencyOption allows management of the mutation configuration using functional options.
type asinneragencyOption func(*AsInnerAgencyMutation)

// newAsInnerAgencyMutation creates new mutation for the AsInnerAgency entity.
func newAsInnerAgencyMutation(c config, op Op, opts ...asinneragencyOption) *AsInnerAgencyMutation {
	m := &AsInnerAgencyMutation{
		config:        c,
		op:            op,
		typ:           TypeAsInnerAgency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsInnerAgencyID sets the ID field of the mutation.
func withAsInnerAgencyID(id int64) asinneragencyOption {
	return func(m *AsInnerAgencyMutation) {
		var (
			err   error
			once  sync.Once
			value *AsInnerAgency
		)
		m.oldValue = func(ctx context.Context) (*AsInnerAgency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsInnerAgency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsInnerAgency sets the old AsInnerAgency of the mutation.
func withAsInnerAgency(node *AsInnerAgency) asinneragencyOption {
	return func(m *AsInnerAgencyMutation) {
		m.oldValue = func(context.Context) (*AsInnerAgency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsInnerAgencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsInnerAgencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsInnerAgency entities.
func (m *AsInnerAgencyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsInnerAgencyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsInnerAgencyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsInnerAgency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAgencyName sets the "agency_name" field.
func (m *AsInnerAgencyMutation) SetAgencyName(s string) {
	m.agency_name = &s
}

// AgencyName returns the value of the "agency_name" field in the mutation.
func (m *AsInnerAgencyMutation) AgencyName() (r string, exists bool) {
	v := m.agency_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAgencyName returns the old "agency_name" field's value of the AsInnerAgency entity.
// If the AsInnerAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInnerAgencyMutation) OldAgencyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgencyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgencyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgencyName: %w", err)
	}
	return oldValue.AgencyName, nil
}

// ResetAgencyName resets all changes to the "agency_name" field.
func (m *AsInnerAgencyMutation) ResetAgencyName() {
	m.agency_name = nil
}

// SetAgencyCode sets the "agency_code" field.
func (m *AsInnerAgencyMutation) SetAgencyCode(s string) {
	m.agency_code = &s
}

// AgencyCode returns the value of the "agency_code" field in the mutation.
func (m *AsInnerAgencyMutation) AgencyCode() (r string, exists bool) {
	v := m.agency_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAgencyCode returns the old "agency_code" field's value of the AsInnerAgency entity.
// If the AsInnerAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInnerAgencyMutation) OldAgencyCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgencyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgencyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgencyCode: %w", err)
	}
	return oldValue.AgencyCode, nil
}

// ClearAgencyCode clears the value of the "agency_code" field.
func (m *AsInnerAgencyMutation) ClearAgencyCode() {
	m.agency_code = nil
	m.clearedFields[asinneragency.FieldAgencyCode] = struct{}{}
}

// AgencyCodeCleared returns if the "agency_code" field was cleared in this mutation.
func (m *AsInnerAgencyMutation) AgencyCodeCleared() bool {
	_, ok := m.clearedFields[asinneragency.FieldAgencyCode]
	return ok
}

// ResetAgencyCode resets all changes to the "agency_code" field.
func (m *AsInnerAgencyMutation) ResetAgencyCode() {
	m.agency_code = nil
	delete(m.clearedFields, asinneragency.FieldAgencyCode)
}

// SetTenantCode sets the "tenant_code" field.
func (m *AsInnerAgencyMutation) SetTenantCode(s string) {
	m.tenant_code = &s
}

// TenantCode returns the value of the "tenant_code" field in the mutation.
func (m *AsInnerAgencyMutation) TenantCode() (r string, exists bool) {
	v := m.tenant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantCode returns the old "tenant_code" field's value of the AsInnerAgency entity.
// If the AsInnerAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInnerAgencyMutation) OldTenantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantCode: %w", err)
	}
	return oldValue.TenantCode, nil
}

// ResetTenantCode resets all changes to the "tenant_code" field.
func (m *AsInnerAgencyMutation) ResetTenantCode() {
	m.tenant_code = nil
}

// SetParentID sets the "parent_id" field.
func (m *AsInnerAgencyMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *AsInnerAgencyMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the AsInnerAgency entity.
// If the AsInnerAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInnerAgencyMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *AsInnerAgencyMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[asinneragency.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *AsInnerAgencyMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[asinneragency.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *AsInnerAgencyMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, asinneragency.FieldParentID)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsInnerAgencyMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsInnerAgencyMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsInnerAgency entity.
// If the AsInnerAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInnerAgencyMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsInnerAgencyMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsInnerAgencyMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsInnerAgencyMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsInnerAgencyMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsInnerAgencyMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsInnerAgency entity.
// If the AsInnerAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInnerAgencyMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsInnerAgencyMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsInnerAgencyMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsInnerAgencyMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asinneragency.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsInnerAgencyMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asinneragency.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsInnerAgencyMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asinneragency.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsInnerAgencyMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsInnerAgencyMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsInnerAgency entity.
// If the AsInnerAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInnerAgencyMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsInnerAgencyMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsInnerAgencyMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsInnerAgencyMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asinneragency.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsInnerAgencyMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asinneragency.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsInnerAgencyMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asinneragency.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsInnerAgencyMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsInnerAgencyMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsInnerAgency entity.
// If the AsInnerAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInnerAgencyMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsInnerAgencyMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsInnerAgencyMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsInnerAgencyMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asinneragency.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsInnerAgencyMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asinneragency.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsInnerAgencyMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asinneragency.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsInnerAgencyMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsInnerAgencyMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsInnerAgency entity.
// If the AsInnerAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInnerAgencyMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsInnerAgencyMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asinneragency.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsInnerAgencyMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asinneragency.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsInnerAgencyMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asinneragency.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsInnerAgencyMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsInnerAgencyMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsInnerAgency entity.
// If the AsInnerAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInnerAgencyMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsInnerAgencyMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asinneragency.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsInnerAgencyMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asinneragency.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsInnerAgencyMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asinneragency.FieldUpdateTime)
}

// ClearParent clears the "parent" edge to the AsInnerAgency entity.
func (m *AsInnerAgencyMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the AsInnerAgency entity was cleared.
func (m *AsInnerAgencyMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *AsInnerAgencyMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *AsInnerAgencyMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildrenIDs adds the "childrens" edge to the AsInnerAgency entity by ids.
func (m *AsInnerAgencyMutation) AddChildrenIDs(ids ...int64) {
	if m.childrens == nil {
		m.childrens = make(map[int64]struct{})
	}
	for i := range ids {
		m.childrens[ids[i]] = struct{}{}
	}
}

// ClearChildrens clears the "childrens" edge to the AsInnerAgency entity.
func (m *AsInnerAgencyMutation) ClearChildrens() {
	m.clearedchildrens = true
}

// ChildrensCleared reports if the "childrens" edge to the AsInnerAgency entity was cleared.
func (m *AsInnerAgencyMutation) ChildrensCleared() bool {
	return m.clearedchildrens
}

// RemoveChildrenIDs removes the "childrens" edge to the AsInnerAgency entity by IDs.
func (m *AsInnerAgencyMutation) RemoveChildrenIDs(ids ...int64) {
	if m.removedchildrens == nil {
		m.removedchildrens = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.childrens, ids[i])
		m.removedchildrens[ids[i]] = struct{}{}
	}
}

// RemovedChildrens returns the removed IDs of the "childrens" edge to the AsInnerAgency entity.
func (m *AsInnerAgencyMutation) RemovedChildrensIDs() (ids []int64) {
	for id := range m.removedchildrens {
		ids = append(ids, id)
	}
	return
}

// ChildrensIDs returns the "childrens" edge IDs in the mutation.
func (m *AsInnerAgencyMutation) ChildrensIDs() (ids []int64) {
	for id := range m.childrens {
		ids = append(ids, id)
	}
	return
}

// ResetChildrens resets all changes to the "childrens" edge.
func (m *AsInnerAgencyMutation) ResetChildrens() {
	m.childrens = nil
	m.clearedchildrens = false
	m.removedchildrens = nil
}

// AddJobIDs adds the "jobs" edge to the AsJob entity by ids.
func (m *AsInnerAgencyMutation) AddJobIDs(ids ...int64) {
	if m.jobs == nil {
		m.jobs = make(map[int64]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the AsJob entity.
func (m *AsInnerAgencyMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the AsJob entity was cleared.
func (m *AsInnerAgencyMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the AsJob entity by IDs.
func (m *AsInnerAgencyMutation) RemoveJobIDs(ids ...int64) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the AsJob entity.
func (m *AsInnerAgencyMutation) RemovedJobsIDs() (ids []int64) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *AsInnerAgencyMutation) JobsIDs() (ids []int64) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *AsInnerAgencyMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// AddUserIDs adds the "users" edge to the AsUser entity by ids.
func (m *AsInnerAgencyMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the AsUser entity.
func (m *AsInnerAgencyMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the AsUser entity was cleared.
func (m *AsInnerAgencyMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the AsUser entity by IDs.
func (m *AsInnerAgencyMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the AsUser entity.
func (m *AsInnerAgencyMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *AsInnerAgencyMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AsInnerAgencyMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddPersonIDs adds the "persons" edge to the AsPerson entity by ids.
func (m *AsInnerAgencyMutation) AddPersonIDs(ids ...int64) {
	if m.persons == nil {
		m.persons = make(map[int64]struct{})
	}
	for i := range ids {
		m.persons[ids[i]] = struct{}{}
	}
}

// ClearPersons clears the "persons" edge to the AsPerson entity.
func (m *AsInnerAgencyMutation) ClearPersons() {
	m.clearedpersons = true
}

// PersonsCleared reports if the "persons" edge to the AsPerson entity was cleared.
func (m *AsInnerAgencyMutation) PersonsCleared() bool {
	return m.clearedpersons
}

// RemovePersonIDs removes the "persons" edge to the AsPerson entity by IDs.
func (m *AsInnerAgencyMutation) RemovePersonIDs(ids ...int64) {
	if m.removedpersons == nil {
		m.removedpersons = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.persons, ids[i])
		m.removedpersons[ids[i]] = struct{}{}
	}
}

// RemovedPersons returns the removed IDs of the "persons" edge to the AsPerson entity.
func (m *AsInnerAgencyMutation) RemovedPersonsIDs() (ids []int64) {
	for id := range m.removedpersons {
		ids = append(ids, id)
	}
	return
}

// PersonsIDs returns the "persons" edge IDs in the mutation.
func (m *AsInnerAgencyMutation) PersonsIDs() (ids []int64) {
	for id := range m.persons {
		ids = append(ids, id)
	}
	return
}

// ResetPersons resets all changes to the "persons" edge.
func (m *AsInnerAgencyMutation) ResetPersons() {
	m.persons = nil
	m.clearedpersons = false
	m.removedpersons = nil
}

// AddRoleDistribIDs adds the "roleDistribs" edge to the AsMarketRoleDistribution entity by ids.
func (m *AsInnerAgencyMutation) AddRoleDistribIDs(ids ...int64) {
	if m.roleDistribs == nil {
		m.roleDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		m.roleDistribs[ids[i]] = struct{}{}
	}
}

// ClearRoleDistribs clears the "roleDistribs" edge to the AsMarketRoleDistribution entity.
func (m *AsInnerAgencyMutation) ClearRoleDistribs() {
	m.clearedroleDistribs = true
}

// RoleDistribsCleared reports if the "roleDistribs" edge to the AsMarketRoleDistribution entity was cleared.
func (m *AsInnerAgencyMutation) RoleDistribsCleared() bool {
	return m.clearedroleDistribs
}

// RemoveRoleDistribIDs removes the "roleDistribs" edge to the AsMarketRoleDistribution entity by IDs.
func (m *AsInnerAgencyMutation) RemoveRoleDistribIDs(ids ...int64) {
	if m.removedroleDistribs == nil {
		m.removedroleDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roleDistribs, ids[i])
		m.removedroleDistribs[ids[i]] = struct{}{}
	}
}

// RemovedRoleDistribs returns the removed IDs of the "roleDistribs" edge to the AsMarketRoleDistribution entity.
func (m *AsInnerAgencyMutation) RemovedRoleDistribsIDs() (ids []int64) {
	for id := range m.removedroleDistribs {
		ids = append(ids, id)
	}
	return
}

// RoleDistribsIDs returns the "roleDistribs" edge IDs in the mutation.
func (m *AsInnerAgencyMutation) RoleDistribsIDs() (ids []int64) {
	for id := range m.roleDistribs {
		ids = append(ids, id)
	}
	return
}

// ResetRoleDistribs resets all changes to the "roleDistribs" edge.
func (m *AsInnerAgencyMutation) ResetRoleDistribs() {
	m.roleDistribs = nil
	m.clearedroleDistribs = false
	m.removedroleDistribs = nil
}

// Where appends a list predicates to the AsInnerAgencyMutation builder.
func (m *AsInnerAgencyMutation) Where(ps ...predicate.AsInnerAgency) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsInnerAgencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsInnerAgency).
func (m *AsInnerAgencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsInnerAgencyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.agency_name != nil {
		fields = append(fields, asinneragency.FieldAgencyName)
	}
	if m.agency_code != nil {
		fields = append(fields, asinneragency.FieldAgencyCode)
	}
	if m.tenant_code != nil {
		fields = append(fields, asinneragency.FieldTenantCode)
	}
	if m.parent != nil {
		fields = append(fields, asinneragency.FieldParentID)
	}
	if m.is_deleted != nil {
		fields = append(fields, asinneragency.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asinneragency.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asinneragency.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asinneragency.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asinneragency.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asinneragency.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsInnerAgencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asinneragency.FieldAgencyName:
		return m.AgencyName()
	case asinneragency.FieldAgencyCode:
		return m.AgencyCode()
	case asinneragency.FieldTenantCode:
		return m.TenantCode()
	case asinneragency.FieldParentID:
		return m.ParentID()
	case asinneragency.FieldIsDeleted:
		return m.IsDeleted()
	case asinneragency.FieldStatus:
		return m.Status()
	case asinneragency.FieldCreateUser:
		return m.CreateUser()
	case asinneragency.FieldUpdateUser:
		return m.UpdateUser()
	case asinneragency.FieldCreateTime:
		return m.CreateTime()
	case asinneragency.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsInnerAgencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asinneragency.FieldAgencyName:
		return m.OldAgencyName(ctx)
	case asinneragency.FieldAgencyCode:
		return m.OldAgencyCode(ctx)
	case asinneragency.FieldTenantCode:
		return m.OldTenantCode(ctx)
	case asinneragency.FieldParentID:
		return m.OldParentID(ctx)
	case asinneragency.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asinneragency.FieldStatus:
		return m.OldStatus(ctx)
	case asinneragency.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asinneragency.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asinneragency.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asinneragency.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsInnerAgency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsInnerAgencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asinneragency.FieldAgencyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgencyName(v)
		return nil
	case asinneragency.FieldAgencyCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgencyCode(v)
		return nil
	case asinneragency.FieldTenantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantCode(v)
		return nil
	case asinneragency.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case asinneragency.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asinneragency.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asinneragency.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asinneragency.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asinneragency.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asinneragency.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsInnerAgency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsInnerAgencyMutation) AddedFields() []string {
	var fields []string
	if m.addis_deleted != nil {
		fields = append(fields, asinneragency.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asinneragency.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asinneragency.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asinneragency.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsInnerAgencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asinneragency.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asinneragency.FieldStatus:
		return m.AddedStatus()
	case asinneragency.FieldCreateUser:
		return m.AddedCreateUser()
	case asinneragency.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsInnerAgencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asinneragency.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asinneragency.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asinneragency.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asinneragency.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsInnerAgency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsInnerAgencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asinneragency.FieldAgencyCode) {
		fields = append(fields, asinneragency.FieldAgencyCode)
	}
	if m.FieldCleared(asinneragency.FieldParentID) {
		fields = append(fields, asinneragency.FieldParentID)
	}
	if m.FieldCleared(asinneragency.FieldStatus) {
		fields = append(fields, asinneragency.FieldStatus)
	}
	if m.FieldCleared(asinneragency.FieldCreateUser) {
		fields = append(fields, asinneragency.FieldCreateUser)
	}
	if m.FieldCleared(asinneragency.FieldUpdateUser) {
		fields = append(fields, asinneragency.FieldUpdateUser)
	}
	if m.FieldCleared(asinneragency.FieldCreateTime) {
		fields = append(fields, asinneragency.FieldCreateTime)
	}
	if m.FieldCleared(asinneragency.FieldUpdateTime) {
		fields = append(fields, asinneragency.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsInnerAgencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsInnerAgencyMutation) ClearField(name string) error {
	switch name {
	case asinneragency.FieldAgencyCode:
		m.ClearAgencyCode()
		return nil
	case asinneragency.FieldParentID:
		m.ClearParentID()
		return nil
	case asinneragency.FieldStatus:
		m.ClearStatus()
		return nil
	case asinneragency.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asinneragency.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asinneragency.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asinneragency.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsInnerAgency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsInnerAgencyMutation) ResetField(name string) error {
	switch name {
	case asinneragency.FieldAgencyName:
		m.ResetAgencyName()
		return nil
	case asinneragency.FieldAgencyCode:
		m.ResetAgencyCode()
		return nil
	case asinneragency.FieldTenantCode:
		m.ResetTenantCode()
		return nil
	case asinneragency.FieldParentID:
		m.ResetParentID()
		return nil
	case asinneragency.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asinneragency.FieldStatus:
		m.ResetStatus()
		return nil
	case asinneragency.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asinneragency.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asinneragency.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asinneragency.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsInnerAgency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsInnerAgencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.parent != nil {
		edges = append(edges, asinneragency.EdgeParent)
	}
	if m.childrens != nil {
		edges = append(edges, asinneragency.EdgeChildrens)
	}
	if m.jobs != nil {
		edges = append(edges, asinneragency.EdgeJobs)
	}
	if m.users != nil {
		edges = append(edges, asinneragency.EdgeUsers)
	}
	if m.persons != nil {
		edges = append(edges, asinneragency.EdgePersons)
	}
	if m.roleDistribs != nil {
		edges = append(edges, asinneragency.EdgeRoleDistribs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsInnerAgencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asinneragency.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case asinneragency.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.childrens))
		for id := range m.childrens {
			ids = append(ids, id)
		}
		return ids
	case asinneragency.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case asinneragency.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case asinneragency.EdgePersons:
		ids := make([]ent.Value, 0, len(m.persons))
		for id := range m.persons {
			ids = append(ids, id)
		}
		return ids
	case asinneragency.EdgeRoleDistribs:
		ids := make([]ent.Value, 0, len(m.roleDistribs))
		for id := range m.roleDistribs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsInnerAgencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedchildrens != nil {
		edges = append(edges, asinneragency.EdgeChildrens)
	}
	if m.removedjobs != nil {
		edges = append(edges, asinneragency.EdgeJobs)
	}
	if m.removedusers != nil {
		edges = append(edges, asinneragency.EdgeUsers)
	}
	if m.removedpersons != nil {
		edges = append(edges, asinneragency.EdgePersons)
	}
	if m.removedroleDistribs != nil {
		edges = append(edges, asinneragency.EdgeRoleDistribs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsInnerAgencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asinneragency.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.removedchildrens))
		for id := range m.removedchildrens {
			ids = append(ids, id)
		}
		return ids
	case asinneragency.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	case asinneragency.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case asinneragency.EdgePersons:
		ids := make([]ent.Value, 0, len(m.removedpersons))
		for id := range m.removedpersons {
			ids = append(ids, id)
		}
		return ids
	case asinneragency.EdgeRoleDistribs:
		ids := make([]ent.Value, 0, len(m.removedroleDistribs))
		for id := range m.removedroleDistribs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsInnerAgencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedparent {
		edges = append(edges, asinneragency.EdgeParent)
	}
	if m.clearedchildrens {
		edges = append(edges, asinneragency.EdgeChildrens)
	}
	if m.clearedjobs {
		edges = append(edges, asinneragency.EdgeJobs)
	}
	if m.clearedusers {
		edges = append(edges, asinneragency.EdgeUsers)
	}
	if m.clearedpersons {
		edges = append(edges, asinneragency.EdgePersons)
	}
	if m.clearedroleDistribs {
		edges = append(edges, asinneragency.EdgeRoleDistribs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsInnerAgencyMutation) EdgeCleared(name string) bool {
	switch name {
	case asinneragency.EdgeParent:
		return m.clearedparent
	case asinneragency.EdgeChildrens:
		return m.clearedchildrens
	case asinneragency.EdgeJobs:
		return m.clearedjobs
	case asinneragency.EdgeUsers:
		return m.clearedusers
	case asinneragency.EdgePersons:
		return m.clearedpersons
	case asinneragency.EdgeRoleDistribs:
		return m.clearedroleDistribs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsInnerAgencyMutation) ClearEdge(name string) error {
	switch name {
	case asinneragency.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown AsInnerAgency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsInnerAgencyMutation) ResetEdge(name string) error {
	switch name {
	case asinneragency.EdgeParent:
		m.ResetParent()
		return nil
	case asinneragency.EdgeChildrens:
		m.ResetChildrens()
		return nil
	case asinneragency.EdgeJobs:
		m.ResetJobs()
		return nil
	case asinneragency.EdgeUsers:
		m.ResetUsers()
		return nil
	case asinneragency.EdgePersons:
		m.ResetPersons()
		return nil
	case asinneragency.EdgeRoleDistribs:
		m.ResetRoleDistribs()
		return nil
	}
	return fmt.Errorf("unknown AsInnerAgency edge %s", name)
}

// AsInputDataMutation represents an operation that mutates the AsInputData nodes in the graph.
type AsInputDataMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	file_id        *int64
	addfile_id     *int64
	file_name      *string
	table_name     *string
	_type          *int64
	add_type       *int64
	t_count        *int64
	addt_count     *int64
	f_count        *int64
	addf_count     *int64
	context        *string
	end_time       *date.DateTime
	total_time     *int64
	addtotal_time  *int64
	tenant_code    *string
	import_type    *int64
	addimport_type *int64
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AsInputData, error)
	predicates     []predicate.AsInputData
}

var _ ent.Mutation = (*AsInputDataMutation)(nil)

// asinputdataOption allows management of the mutation configuration using functional options.
type asinputdataOption func(*AsInputDataMutation)

// newAsInputDataMutation creates new mutation for the AsInputData entity.
func newAsInputDataMutation(c config, op Op, opts ...asinputdataOption) *AsInputDataMutation {
	m := &AsInputDataMutation{
		config:        c,
		op:            op,
		typ:           TypeAsInputData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsInputDataID sets the ID field of the mutation.
func withAsInputDataID(id int64) asinputdataOption {
	return func(m *AsInputDataMutation) {
		var (
			err   error
			once  sync.Once
			value *AsInputData
		)
		m.oldValue = func(ctx context.Context) (*AsInputData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsInputData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsInputData sets the old AsInputData of the mutation.
func withAsInputData(node *AsInputData) asinputdataOption {
	return func(m *AsInputDataMutation) {
		m.oldValue = func(context.Context) (*AsInputData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsInputDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsInputDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsInputData entities.
func (m *AsInputDataMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsInputDataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsInputDataMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsInputData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFileID sets the "file_id" field.
func (m *AsInputDataMutation) SetFileID(i int64) {
	m.file_id = &i
	m.addfile_id = nil
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *AsInputDataMutation) FileID() (r int64, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldFileID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// AddFileID adds i to the "file_id" field.
func (m *AsInputDataMutation) AddFileID(i int64) {
	if m.addfile_id != nil {
		*m.addfile_id += i
	} else {
		m.addfile_id = &i
	}
}

// AddedFileID returns the value that was added to the "file_id" field in this mutation.
func (m *AsInputDataMutation) AddedFileID() (r int64, exists bool) {
	v := m.addfile_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileID resets all changes to the "file_id" field.
func (m *AsInputDataMutation) ResetFileID() {
	m.file_id = nil
	m.addfile_id = nil
}

// SetFileName sets the "file_name" field.
func (m *AsInputDataMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *AsInputDataMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *AsInputDataMutation) ResetFileName() {
	m.file_name = nil
}

// SetTableName sets the "table_name" field.
func (m *AsInputDataMutation) SetTableName(s string) {
	m.table_name = &s
}

// TableName returns the value of the "table_name" field in the mutation.
func (m *AsInputDataMutation) TableName() (r string, exists bool) {
	v := m.table_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTableName returns the old "table_name" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldTableName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableName: %w", err)
	}
	return oldValue.TableName, nil
}

// ResetTableName resets all changes to the "table_name" field.
func (m *AsInputDataMutation) ResetTableName() {
	m.table_name = nil
}

// SetType sets the "type" field.
func (m *AsInputDataMutation) SetType(i int64) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *AsInputDataMutation) GetType() (r int64, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *AsInputDataMutation) AddType(i int64) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *AsInputDataMutation) AddedType() (r int64, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *AsInputDataMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[asinputdata.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *AsInputDataMutation) TypeCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *AsInputDataMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, asinputdata.FieldType)
}

// SetTCount sets the "t_count" field.
func (m *AsInputDataMutation) SetTCount(i int64) {
	m.t_count = &i
	m.addt_count = nil
}

// TCount returns the value of the "t_count" field in the mutation.
func (m *AsInputDataMutation) TCount() (r int64, exists bool) {
	v := m.t_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTCount returns the old "t_count" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldTCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTCount: %w", err)
	}
	return oldValue.TCount, nil
}

// AddTCount adds i to the "t_count" field.
func (m *AsInputDataMutation) AddTCount(i int64) {
	if m.addt_count != nil {
		*m.addt_count += i
	} else {
		m.addt_count = &i
	}
}

// AddedTCount returns the value that was added to the "t_count" field in this mutation.
func (m *AsInputDataMutation) AddedTCount() (r int64, exists bool) {
	v := m.addt_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearTCount clears the value of the "t_count" field.
func (m *AsInputDataMutation) ClearTCount() {
	m.t_count = nil
	m.addt_count = nil
	m.clearedFields[asinputdata.FieldTCount] = struct{}{}
}

// TCountCleared returns if the "t_count" field was cleared in this mutation.
func (m *AsInputDataMutation) TCountCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldTCount]
	return ok
}

// ResetTCount resets all changes to the "t_count" field.
func (m *AsInputDataMutation) ResetTCount() {
	m.t_count = nil
	m.addt_count = nil
	delete(m.clearedFields, asinputdata.FieldTCount)
}

// SetFCount sets the "f_count" field.
func (m *AsInputDataMutation) SetFCount(i int64) {
	m.f_count = &i
	m.addf_count = nil
}

// FCount returns the value of the "f_count" field in the mutation.
func (m *AsInputDataMutation) FCount() (r int64, exists bool) {
	v := m.f_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFCount returns the old "f_count" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldFCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFCount: %w", err)
	}
	return oldValue.FCount, nil
}

// AddFCount adds i to the "f_count" field.
func (m *AsInputDataMutation) AddFCount(i int64) {
	if m.addf_count != nil {
		*m.addf_count += i
	} else {
		m.addf_count = &i
	}
}

// AddedFCount returns the value that was added to the "f_count" field in this mutation.
func (m *AsInputDataMutation) AddedFCount() (r int64, exists bool) {
	v := m.addf_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearFCount clears the value of the "f_count" field.
func (m *AsInputDataMutation) ClearFCount() {
	m.f_count = nil
	m.addf_count = nil
	m.clearedFields[asinputdata.FieldFCount] = struct{}{}
}

// FCountCleared returns if the "f_count" field was cleared in this mutation.
func (m *AsInputDataMutation) FCountCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldFCount]
	return ok
}

// ResetFCount resets all changes to the "f_count" field.
func (m *AsInputDataMutation) ResetFCount() {
	m.f_count = nil
	m.addf_count = nil
	delete(m.clearedFields, asinputdata.FieldFCount)
}

// SetContext sets the "context" field.
func (m *AsInputDataMutation) SetContext(s string) {
	m.context = &s
}

// Context returns the value of the "context" field in the mutation.
func (m *AsInputDataMutation) Context() (r string, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ClearContext clears the value of the "context" field.
func (m *AsInputDataMutation) ClearContext() {
	m.context = nil
	m.clearedFields[asinputdata.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *AsInputDataMutation) ContextCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *AsInputDataMutation) ResetContext() {
	m.context = nil
	delete(m.clearedFields, asinputdata.FieldContext)
}

// SetEndTime sets the "end_time" field.
func (m *AsInputDataMutation) SetEndTime(dt date.DateTime) {
	m.end_time = &dt
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *AsInputDataMutation) EndTime() (r date.DateTime, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldEndTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *AsInputDataMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[asinputdata.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *AsInputDataMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *AsInputDataMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, asinputdata.FieldEndTime)
}

// SetTotalTime sets the "total_time" field.
func (m *AsInputDataMutation) SetTotalTime(i int64) {
	m.total_time = &i
	m.addtotal_time = nil
}

// TotalTime returns the value of the "total_time" field in the mutation.
func (m *AsInputDataMutation) TotalTime() (r int64, exists bool) {
	v := m.total_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTime returns the old "total_time" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldTotalTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTime: %w", err)
	}
	return oldValue.TotalTime, nil
}

// AddTotalTime adds i to the "total_time" field.
func (m *AsInputDataMutation) AddTotalTime(i int64) {
	if m.addtotal_time != nil {
		*m.addtotal_time += i
	} else {
		m.addtotal_time = &i
	}
}

// AddedTotalTime returns the value that was added to the "total_time" field in this mutation.
func (m *AsInputDataMutation) AddedTotalTime() (r int64, exists bool) {
	v := m.addtotal_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalTime clears the value of the "total_time" field.
func (m *AsInputDataMutation) ClearTotalTime() {
	m.total_time = nil
	m.addtotal_time = nil
	m.clearedFields[asinputdata.FieldTotalTime] = struct{}{}
}

// TotalTimeCleared returns if the "total_time" field was cleared in this mutation.
func (m *AsInputDataMutation) TotalTimeCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldTotalTime]
	return ok
}

// ResetTotalTime resets all changes to the "total_time" field.
func (m *AsInputDataMutation) ResetTotalTime() {
	m.total_time = nil
	m.addtotal_time = nil
	delete(m.clearedFields, asinputdata.FieldTotalTime)
}

// SetTenantCode sets the "tenant_code" field.
func (m *AsInputDataMutation) SetTenantCode(s string) {
	m.tenant_code = &s
}

// TenantCode returns the value of the "tenant_code" field in the mutation.
func (m *AsInputDataMutation) TenantCode() (r string, exists bool) {
	v := m.tenant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantCode returns the old "tenant_code" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldTenantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantCode: %w", err)
	}
	return oldValue.TenantCode, nil
}

// ClearTenantCode clears the value of the "tenant_code" field.
func (m *AsInputDataMutation) ClearTenantCode() {
	m.tenant_code = nil
	m.clearedFields[asinputdata.FieldTenantCode] = struct{}{}
}

// TenantCodeCleared returns if the "tenant_code" field was cleared in this mutation.
func (m *AsInputDataMutation) TenantCodeCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldTenantCode]
	return ok
}

// ResetTenantCode resets all changes to the "tenant_code" field.
func (m *AsInputDataMutation) ResetTenantCode() {
	m.tenant_code = nil
	delete(m.clearedFields, asinputdata.FieldTenantCode)
}

// SetImportType sets the "import_type" field.
func (m *AsInputDataMutation) SetImportType(i int64) {
	m.import_type = &i
	m.addimport_type = nil
}

// ImportType returns the value of the "import_type" field in the mutation.
func (m *AsInputDataMutation) ImportType() (r int64, exists bool) {
	v := m.import_type
	if v == nil {
		return
	}
	return *v, true
}

// OldImportType returns the old "import_type" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldImportType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportType: %w", err)
	}
	return oldValue.ImportType, nil
}

// AddImportType adds i to the "import_type" field.
func (m *AsInputDataMutation) AddImportType(i int64) {
	if m.addimport_type != nil {
		*m.addimport_type += i
	} else {
		m.addimport_type = &i
	}
}

// AddedImportType returns the value that was added to the "import_type" field in this mutation.
func (m *AsInputDataMutation) AddedImportType() (r int64, exists bool) {
	v := m.addimport_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearImportType clears the value of the "import_type" field.
func (m *AsInputDataMutation) ClearImportType() {
	m.import_type = nil
	m.addimport_type = nil
	m.clearedFields[asinputdata.FieldImportType] = struct{}{}
}

// ImportTypeCleared returns if the "import_type" field was cleared in this mutation.
func (m *AsInputDataMutation) ImportTypeCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldImportType]
	return ok
}

// ResetImportType resets all changes to the "import_type" field.
func (m *AsInputDataMutation) ResetImportType() {
	m.import_type = nil
	m.addimport_type = nil
	delete(m.clearedFields, asinputdata.FieldImportType)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsInputDataMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsInputDataMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsInputDataMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsInputDataMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsInputDataMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsInputDataMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsInputDataMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsInputDataMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsInputDataMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsInputDataMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asinputdata.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsInputDataMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsInputDataMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asinputdata.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsInputDataMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsInputDataMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsInputDataMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsInputDataMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsInputDataMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asinputdata.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsInputDataMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsInputDataMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asinputdata.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsInputDataMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsInputDataMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsInputDataMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsInputDataMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsInputDataMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asinputdata.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsInputDataMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsInputDataMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asinputdata.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsInputDataMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsInputDataMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsInputDataMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asinputdata.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsInputDataMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsInputDataMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asinputdata.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsInputDataMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsInputDataMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsInputData entity.
// If the AsInputData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsInputDataMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsInputDataMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asinputdata.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsInputDataMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asinputdata.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsInputDataMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asinputdata.FieldUpdateTime)
}

// Where appends a list predicates to the AsInputDataMutation builder.
func (m *AsInputDataMutation) Where(ps ...predicate.AsInputData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsInputDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsInputData).
func (m *AsInputDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsInputDataMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.file_id != nil {
		fields = append(fields, asinputdata.FieldFileID)
	}
	if m.file_name != nil {
		fields = append(fields, asinputdata.FieldFileName)
	}
	if m.table_name != nil {
		fields = append(fields, asinputdata.FieldTableName)
	}
	if m._type != nil {
		fields = append(fields, asinputdata.FieldType)
	}
	if m.t_count != nil {
		fields = append(fields, asinputdata.FieldTCount)
	}
	if m.f_count != nil {
		fields = append(fields, asinputdata.FieldFCount)
	}
	if m.context != nil {
		fields = append(fields, asinputdata.FieldContext)
	}
	if m.end_time != nil {
		fields = append(fields, asinputdata.FieldEndTime)
	}
	if m.total_time != nil {
		fields = append(fields, asinputdata.FieldTotalTime)
	}
	if m.tenant_code != nil {
		fields = append(fields, asinputdata.FieldTenantCode)
	}
	if m.import_type != nil {
		fields = append(fields, asinputdata.FieldImportType)
	}
	if m.is_deleted != nil {
		fields = append(fields, asinputdata.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asinputdata.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asinputdata.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asinputdata.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asinputdata.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asinputdata.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsInputDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asinputdata.FieldFileID:
		return m.FileID()
	case asinputdata.FieldFileName:
		return m.FileName()
	case asinputdata.FieldTableName:
		return m.TableName()
	case asinputdata.FieldType:
		return m.GetType()
	case asinputdata.FieldTCount:
		return m.TCount()
	case asinputdata.FieldFCount:
		return m.FCount()
	case asinputdata.FieldContext:
		return m.Context()
	case asinputdata.FieldEndTime:
		return m.EndTime()
	case asinputdata.FieldTotalTime:
		return m.TotalTime()
	case asinputdata.FieldTenantCode:
		return m.TenantCode()
	case asinputdata.FieldImportType:
		return m.ImportType()
	case asinputdata.FieldIsDeleted:
		return m.IsDeleted()
	case asinputdata.FieldStatus:
		return m.Status()
	case asinputdata.FieldCreateUser:
		return m.CreateUser()
	case asinputdata.FieldUpdateUser:
		return m.UpdateUser()
	case asinputdata.FieldCreateTime:
		return m.CreateTime()
	case asinputdata.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsInputDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asinputdata.FieldFileID:
		return m.OldFileID(ctx)
	case asinputdata.FieldFileName:
		return m.OldFileName(ctx)
	case asinputdata.FieldTableName:
		return m.OldTableName(ctx)
	case asinputdata.FieldType:
		return m.OldType(ctx)
	case asinputdata.FieldTCount:
		return m.OldTCount(ctx)
	case asinputdata.FieldFCount:
		return m.OldFCount(ctx)
	case asinputdata.FieldContext:
		return m.OldContext(ctx)
	case asinputdata.FieldEndTime:
		return m.OldEndTime(ctx)
	case asinputdata.FieldTotalTime:
		return m.OldTotalTime(ctx)
	case asinputdata.FieldTenantCode:
		return m.OldTenantCode(ctx)
	case asinputdata.FieldImportType:
		return m.OldImportType(ctx)
	case asinputdata.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asinputdata.FieldStatus:
		return m.OldStatus(ctx)
	case asinputdata.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asinputdata.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asinputdata.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asinputdata.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsInputData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsInputDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asinputdata.FieldFileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case asinputdata.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case asinputdata.FieldTableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableName(v)
		return nil
	case asinputdata.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case asinputdata.FieldTCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTCount(v)
		return nil
	case asinputdata.FieldFCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFCount(v)
		return nil
	case asinputdata.FieldContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case asinputdata.FieldEndTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case asinputdata.FieldTotalTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTime(v)
		return nil
	case asinputdata.FieldTenantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantCode(v)
		return nil
	case asinputdata.FieldImportType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportType(v)
		return nil
	case asinputdata.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asinputdata.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asinputdata.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asinputdata.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asinputdata.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asinputdata.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsInputData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsInputDataMutation) AddedFields() []string {
	var fields []string
	if m.addfile_id != nil {
		fields = append(fields, asinputdata.FieldFileID)
	}
	if m.add_type != nil {
		fields = append(fields, asinputdata.FieldType)
	}
	if m.addt_count != nil {
		fields = append(fields, asinputdata.FieldTCount)
	}
	if m.addf_count != nil {
		fields = append(fields, asinputdata.FieldFCount)
	}
	if m.addtotal_time != nil {
		fields = append(fields, asinputdata.FieldTotalTime)
	}
	if m.addimport_type != nil {
		fields = append(fields, asinputdata.FieldImportType)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asinputdata.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asinputdata.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asinputdata.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asinputdata.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsInputDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asinputdata.FieldFileID:
		return m.AddedFileID()
	case asinputdata.FieldType:
		return m.AddedType()
	case asinputdata.FieldTCount:
		return m.AddedTCount()
	case asinputdata.FieldFCount:
		return m.AddedFCount()
	case asinputdata.FieldTotalTime:
		return m.AddedTotalTime()
	case asinputdata.FieldImportType:
		return m.AddedImportType()
	case asinputdata.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asinputdata.FieldStatus:
		return m.AddedStatus()
	case asinputdata.FieldCreateUser:
		return m.AddedCreateUser()
	case asinputdata.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsInputDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asinputdata.FieldFileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileID(v)
		return nil
	case asinputdata.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case asinputdata.FieldTCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTCount(v)
		return nil
	case asinputdata.FieldFCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFCount(v)
		return nil
	case asinputdata.FieldTotalTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTime(v)
		return nil
	case asinputdata.FieldImportType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImportType(v)
		return nil
	case asinputdata.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asinputdata.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asinputdata.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asinputdata.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsInputData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsInputDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asinputdata.FieldType) {
		fields = append(fields, asinputdata.FieldType)
	}
	if m.FieldCleared(asinputdata.FieldTCount) {
		fields = append(fields, asinputdata.FieldTCount)
	}
	if m.FieldCleared(asinputdata.FieldFCount) {
		fields = append(fields, asinputdata.FieldFCount)
	}
	if m.FieldCleared(asinputdata.FieldContext) {
		fields = append(fields, asinputdata.FieldContext)
	}
	if m.FieldCleared(asinputdata.FieldEndTime) {
		fields = append(fields, asinputdata.FieldEndTime)
	}
	if m.FieldCleared(asinputdata.FieldTotalTime) {
		fields = append(fields, asinputdata.FieldTotalTime)
	}
	if m.FieldCleared(asinputdata.FieldTenantCode) {
		fields = append(fields, asinputdata.FieldTenantCode)
	}
	if m.FieldCleared(asinputdata.FieldImportType) {
		fields = append(fields, asinputdata.FieldImportType)
	}
	if m.FieldCleared(asinputdata.FieldStatus) {
		fields = append(fields, asinputdata.FieldStatus)
	}
	if m.FieldCleared(asinputdata.FieldCreateUser) {
		fields = append(fields, asinputdata.FieldCreateUser)
	}
	if m.FieldCleared(asinputdata.FieldUpdateUser) {
		fields = append(fields, asinputdata.FieldUpdateUser)
	}
	if m.FieldCleared(asinputdata.FieldCreateTime) {
		fields = append(fields, asinputdata.FieldCreateTime)
	}
	if m.FieldCleared(asinputdata.FieldUpdateTime) {
		fields = append(fields, asinputdata.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsInputDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsInputDataMutation) ClearField(name string) error {
	switch name {
	case asinputdata.FieldType:
		m.ClearType()
		return nil
	case asinputdata.FieldTCount:
		m.ClearTCount()
		return nil
	case asinputdata.FieldFCount:
		m.ClearFCount()
		return nil
	case asinputdata.FieldContext:
		m.ClearContext()
		return nil
	case asinputdata.FieldEndTime:
		m.ClearEndTime()
		return nil
	case asinputdata.FieldTotalTime:
		m.ClearTotalTime()
		return nil
	case asinputdata.FieldTenantCode:
		m.ClearTenantCode()
		return nil
	case asinputdata.FieldImportType:
		m.ClearImportType()
		return nil
	case asinputdata.FieldStatus:
		m.ClearStatus()
		return nil
	case asinputdata.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asinputdata.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asinputdata.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asinputdata.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsInputData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsInputDataMutation) ResetField(name string) error {
	switch name {
	case asinputdata.FieldFileID:
		m.ResetFileID()
		return nil
	case asinputdata.FieldFileName:
		m.ResetFileName()
		return nil
	case asinputdata.FieldTableName:
		m.ResetTableName()
		return nil
	case asinputdata.FieldType:
		m.ResetType()
		return nil
	case asinputdata.FieldTCount:
		m.ResetTCount()
		return nil
	case asinputdata.FieldFCount:
		m.ResetFCount()
		return nil
	case asinputdata.FieldContext:
		m.ResetContext()
		return nil
	case asinputdata.FieldEndTime:
		m.ResetEndTime()
		return nil
	case asinputdata.FieldTotalTime:
		m.ResetTotalTime()
		return nil
	case asinputdata.FieldTenantCode:
		m.ResetTenantCode()
		return nil
	case asinputdata.FieldImportType:
		m.ResetImportType()
		return nil
	case asinputdata.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asinputdata.FieldStatus:
		m.ResetStatus()
		return nil
	case asinputdata.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asinputdata.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asinputdata.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asinputdata.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsInputData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsInputDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsInputDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsInputDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsInputDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsInputDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsInputDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsInputDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AsInputData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsInputDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AsInputData edge %s", name)
}

// AsJobMutation represents an operation that mutates the AsJob nodes in the graph.
type AsJobMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	job_name            *string
	tenant_code         *string
	_type               *int64
	add_type            *int64
	sort                *int64
	addsort             *int64
	is_deleted          *int64
	addis_deleted       *int64
	status              *int64
	addstatus           *int64
	create_user         *int64
	addcreate_user      *int64
	update_user         *int64
	addupdate_user      *int64
	create_time         *date.DateTime
	update_time         *date.DateTime
	clearedFields       map[string]struct{}
	persons             map[int64]struct{}
	removedpersons      map[int64]struct{}
	clearedpersons      bool
	roles               map[int64]struct{}
	removedroles        map[int64]struct{}
	clearedroles        bool
	users               map[int64]struct{}
	removedusers        map[int64]struct{}
	clearedusers        bool
	agencys             map[int64]struct{}
	removedagencys      map[int64]struct{}
	clearedagencys      bool
	roleDistribs        map[int64]struct{}
	removedroleDistribs map[int64]struct{}
	clearedroleDistribs bool
	done                bool
	oldValue            func(context.Context) (*AsJob, error)
	predicates          []predicate.AsJob
}

var _ ent.Mutation = (*AsJobMutation)(nil)

// asjobOption allows management of the mutation configuration using functional options.
type asjobOption func(*AsJobMutation)

// newAsJobMutation creates new mutation for the AsJob entity.
func newAsJobMutation(c config, op Op, opts ...asjobOption) *AsJobMutation {
	m := &AsJobMutation{
		config:        c,
		op:            op,
		typ:           TypeAsJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsJobID sets the ID field of the mutation.
func withAsJobID(id int64) asjobOption {
	return func(m *AsJobMutation) {
		var (
			err   error
			once  sync.Once
			value *AsJob
		)
		m.oldValue = func(ctx context.Context) (*AsJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsJob sets the old AsJob of the mutation.
func withAsJob(node *AsJob) asjobOption {
	return func(m *AsJobMutation) {
		m.oldValue = func(context.Context) (*AsJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsJob entities.
func (m *AsJobMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsJobMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsJobMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJobName sets the "job_name" field.
func (m *AsJobMutation) SetJobName(s string) {
	m.job_name = &s
}

// JobName returns the value of the "job_name" field in the mutation.
func (m *AsJobMutation) JobName() (r string, exists bool) {
	v := m.job_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJobName returns the old "job_name" field's value of the AsJob entity.
// If the AsJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsJobMutation) OldJobName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobName: %w", err)
	}
	return oldValue.JobName, nil
}

// ResetJobName resets all changes to the "job_name" field.
func (m *AsJobMutation) ResetJobName() {
	m.job_name = nil
}

// SetTenantCode sets the "tenant_code" field.
func (m *AsJobMutation) SetTenantCode(s string) {
	m.tenant_code = &s
}

// TenantCode returns the value of the "tenant_code" field in the mutation.
func (m *AsJobMutation) TenantCode() (r string, exists bool) {
	v := m.tenant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantCode returns the old "tenant_code" field's value of the AsJob entity.
// If the AsJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsJobMutation) OldTenantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantCode: %w", err)
	}
	return oldValue.TenantCode, nil
}

// ResetTenantCode resets all changes to the "tenant_code" field.
func (m *AsJobMutation) ResetTenantCode() {
	m.tenant_code = nil
}

// SetType sets the "type" field.
func (m *AsJobMutation) SetType(i int64) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *AsJobMutation) GetType() (r int64, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AsJob entity.
// If the AsJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsJobMutation) OldType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *AsJobMutation) AddType(i int64) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *AsJobMutation) AddedType() (r int64, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *AsJobMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[asjob.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *AsJobMutation) TypeCleared() bool {
	_, ok := m.clearedFields[asjob.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *AsJobMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, asjob.FieldType)
}

// SetSort sets the "sort" field.
func (m *AsJobMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AsJobMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the AsJob entity.
// If the AsJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsJobMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AsJobMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AsJobMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *AsJobMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[asjob.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *AsJobMutation) SortCleared() bool {
	_, ok := m.clearedFields[asjob.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *AsJobMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, asjob.FieldSort)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsJobMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsJobMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsJob entity.
// If the AsJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsJobMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsJobMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsJobMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsJobMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsJobMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsJobMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsJob entity.
// If the AsJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsJobMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsJobMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsJobMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsJobMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asjob.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsJobMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asjob.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsJobMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asjob.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsJobMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsJobMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsJob entity.
// If the AsJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsJobMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsJobMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsJobMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsJobMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asjob.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsJobMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asjob.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsJobMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asjob.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsJobMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsJobMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsJob entity.
// If the AsJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsJobMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsJobMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsJobMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsJobMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asjob.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsJobMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asjob.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsJobMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asjob.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsJobMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsJobMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsJob entity.
// If the AsJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsJobMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsJobMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asjob.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsJobMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asjob.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsJobMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asjob.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsJobMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsJobMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsJob entity.
// If the AsJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsJobMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsJobMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asjob.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsJobMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asjob.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsJobMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asjob.FieldUpdateTime)
}

// AddPersonIDs adds the "persons" edge to the AsPerson entity by ids.
func (m *AsJobMutation) AddPersonIDs(ids ...int64) {
	if m.persons == nil {
		m.persons = make(map[int64]struct{})
	}
	for i := range ids {
		m.persons[ids[i]] = struct{}{}
	}
}

// ClearPersons clears the "persons" edge to the AsPerson entity.
func (m *AsJobMutation) ClearPersons() {
	m.clearedpersons = true
}

// PersonsCleared reports if the "persons" edge to the AsPerson entity was cleared.
func (m *AsJobMutation) PersonsCleared() bool {
	return m.clearedpersons
}

// RemovePersonIDs removes the "persons" edge to the AsPerson entity by IDs.
func (m *AsJobMutation) RemovePersonIDs(ids ...int64) {
	if m.removedpersons == nil {
		m.removedpersons = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.persons, ids[i])
		m.removedpersons[ids[i]] = struct{}{}
	}
}

// RemovedPersons returns the removed IDs of the "persons" edge to the AsPerson entity.
func (m *AsJobMutation) RemovedPersonsIDs() (ids []int64) {
	for id := range m.removedpersons {
		ids = append(ids, id)
	}
	return
}

// PersonsIDs returns the "persons" edge IDs in the mutation.
func (m *AsJobMutation) PersonsIDs() (ids []int64) {
	for id := range m.persons {
		ids = append(ids, id)
	}
	return
}

// ResetPersons resets all changes to the "persons" edge.
func (m *AsJobMutation) ResetPersons() {
	m.persons = nil
	m.clearedpersons = false
	m.removedpersons = nil
}

// AddRoleIDs adds the "roles" edge to the AsRole entity by ids.
func (m *AsJobMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the AsRole entity.
func (m *AsJobMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AsRole entity was cleared.
func (m *AsJobMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the AsRole entity by IDs.
func (m *AsJobMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the AsRole entity.
func (m *AsJobMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AsJobMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AsJobMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddUserIDs adds the "users" edge to the AsUser entity by ids.
func (m *AsJobMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the AsUser entity.
func (m *AsJobMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the AsUser entity was cleared.
func (m *AsJobMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the AsUser entity by IDs.
func (m *AsJobMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the AsUser entity.
func (m *AsJobMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *AsJobMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AsJobMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddAgencyIDs adds the "agencys" edge to the AsInnerAgency entity by ids.
func (m *AsJobMutation) AddAgencyIDs(ids ...int64) {
	if m.agencys == nil {
		m.agencys = make(map[int64]struct{})
	}
	for i := range ids {
		m.agencys[ids[i]] = struct{}{}
	}
}

// ClearAgencys clears the "agencys" edge to the AsInnerAgency entity.
func (m *AsJobMutation) ClearAgencys() {
	m.clearedagencys = true
}

// AgencysCleared reports if the "agencys" edge to the AsInnerAgency entity was cleared.
func (m *AsJobMutation) AgencysCleared() bool {
	return m.clearedagencys
}

// RemoveAgencyIDs removes the "agencys" edge to the AsInnerAgency entity by IDs.
func (m *AsJobMutation) RemoveAgencyIDs(ids ...int64) {
	if m.removedagencys == nil {
		m.removedagencys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.agencys, ids[i])
		m.removedagencys[ids[i]] = struct{}{}
	}
}

// RemovedAgencys returns the removed IDs of the "agencys" edge to the AsInnerAgency entity.
func (m *AsJobMutation) RemovedAgencysIDs() (ids []int64) {
	for id := range m.removedagencys {
		ids = append(ids, id)
	}
	return
}

// AgencysIDs returns the "agencys" edge IDs in the mutation.
func (m *AsJobMutation) AgencysIDs() (ids []int64) {
	for id := range m.agencys {
		ids = append(ids, id)
	}
	return
}

// ResetAgencys resets all changes to the "agencys" edge.
func (m *AsJobMutation) ResetAgencys() {
	m.agencys = nil
	m.clearedagencys = false
	m.removedagencys = nil
}

// AddRoleDistribIDs adds the "roleDistribs" edge to the AsMarketRoleDistribution entity by ids.
func (m *AsJobMutation) AddRoleDistribIDs(ids ...int64) {
	if m.roleDistribs == nil {
		m.roleDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		m.roleDistribs[ids[i]] = struct{}{}
	}
}

// ClearRoleDistribs clears the "roleDistribs" edge to the AsMarketRoleDistribution entity.
func (m *AsJobMutation) ClearRoleDistribs() {
	m.clearedroleDistribs = true
}

// RoleDistribsCleared reports if the "roleDistribs" edge to the AsMarketRoleDistribution entity was cleared.
func (m *AsJobMutation) RoleDistribsCleared() bool {
	return m.clearedroleDistribs
}

// RemoveRoleDistribIDs removes the "roleDistribs" edge to the AsMarketRoleDistribution entity by IDs.
func (m *AsJobMutation) RemoveRoleDistribIDs(ids ...int64) {
	if m.removedroleDistribs == nil {
		m.removedroleDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roleDistribs, ids[i])
		m.removedroleDistribs[ids[i]] = struct{}{}
	}
}

// RemovedRoleDistribs returns the removed IDs of the "roleDistribs" edge to the AsMarketRoleDistribution entity.
func (m *AsJobMutation) RemovedRoleDistribsIDs() (ids []int64) {
	for id := range m.removedroleDistribs {
		ids = append(ids, id)
	}
	return
}

// RoleDistribsIDs returns the "roleDistribs" edge IDs in the mutation.
func (m *AsJobMutation) RoleDistribsIDs() (ids []int64) {
	for id := range m.roleDistribs {
		ids = append(ids, id)
	}
	return
}

// ResetRoleDistribs resets all changes to the "roleDistribs" edge.
func (m *AsJobMutation) ResetRoleDistribs() {
	m.roleDistribs = nil
	m.clearedroleDistribs = false
	m.removedroleDistribs = nil
}

// Where appends a list predicates to the AsJobMutation builder.
func (m *AsJobMutation) Where(ps ...predicate.AsJob) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsJobMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsJob).
func (m *AsJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsJobMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.job_name != nil {
		fields = append(fields, asjob.FieldJobName)
	}
	if m.tenant_code != nil {
		fields = append(fields, asjob.FieldTenantCode)
	}
	if m._type != nil {
		fields = append(fields, asjob.FieldType)
	}
	if m.sort != nil {
		fields = append(fields, asjob.FieldSort)
	}
	if m.is_deleted != nil {
		fields = append(fields, asjob.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asjob.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asjob.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asjob.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asjob.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asjob.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asjob.FieldJobName:
		return m.JobName()
	case asjob.FieldTenantCode:
		return m.TenantCode()
	case asjob.FieldType:
		return m.GetType()
	case asjob.FieldSort:
		return m.Sort()
	case asjob.FieldIsDeleted:
		return m.IsDeleted()
	case asjob.FieldStatus:
		return m.Status()
	case asjob.FieldCreateUser:
		return m.CreateUser()
	case asjob.FieldUpdateUser:
		return m.UpdateUser()
	case asjob.FieldCreateTime:
		return m.CreateTime()
	case asjob.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asjob.FieldJobName:
		return m.OldJobName(ctx)
	case asjob.FieldTenantCode:
		return m.OldTenantCode(ctx)
	case asjob.FieldType:
		return m.OldType(ctx)
	case asjob.FieldSort:
		return m.OldSort(ctx)
	case asjob.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asjob.FieldStatus:
		return m.OldStatus(ctx)
	case asjob.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asjob.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asjob.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asjob.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asjob.FieldJobName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobName(v)
		return nil
	case asjob.FieldTenantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantCode(v)
		return nil
	case asjob.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case asjob.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case asjob.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asjob.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asjob.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asjob.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asjob.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asjob.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsJobMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, asjob.FieldType)
	}
	if m.addsort != nil {
		fields = append(fields, asjob.FieldSort)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asjob.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asjob.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asjob.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asjob.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asjob.FieldType:
		return m.AddedType()
	case asjob.FieldSort:
		return m.AddedSort()
	case asjob.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asjob.FieldStatus:
		return m.AddedStatus()
	case asjob.FieldCreateUser:
		return m.AddedCreateUser()
	case asjob.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asjob.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case asjob.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case asjob.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asjob.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asjob.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asjob.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asjob.FieldType) {
		fields = append(fields, asjob.FieldType)
	}
	if m.FieldCleared(asjob.FieldSort) {
		fields = append(fields, asjob.FieldSort)
	}
	if m.FieldCleared(asjob.FieldStatus) {
		fields = append(fields, asjob.FieldStatus)
	}
	if m.FieldCleared(asjob.FieldCreateUser) {
		fields = append(fields, asjob.FieldCreateUser)
	}
	if m.FieldCleared(asjob.FieldUpdateUser) {
		fields = append(fields, asjob.FieldUpdateUser)
	}
	if m.FieldCleared(asjob.FieldCreateTime) {
		fields = append(fields, asjob.FieldCreateTime)
	}
	if m.FieldCleared(asjob.FieldUpdateTime) {
		fields = append(fields, asjob.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsJobMutation) ClearField(name string) error {
	switch name {
	case asjob.FieldType:
		m.ClearType()
		return nil
	case asjob.FieldSort:
		m.ClearSort()
		return nil
	case asjob.FieldStatus:
		m.ClearStatus()
		return nil
	case asjob.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asjob.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asjob.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asjob.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsJobMutation) ResetField(name string) error {
	switch name {
	case asjob.FieldJobName:
		m.ResetJobName()
		return nil
	case asjob.FieldTenantCode:
		m.ResetTenantCode()
		return nil
	case asjob.FieldType:
		m.ResetType()
		return nil
	case asjob.FieldSort:
		m.ResetSort()
		return nil
	case asjob.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asjob.FieldStatus:
		m.ResetStatus()
		return nil
	case asjob.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asjob.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asjob.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asjob.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.persons != nil {
		edges = append(edges, asjob.EdgePersons)
	}
	if m.roles != nil {
		edges = append(edges, asjob.EdgeRoles)
	}
	if m.users != nil {
		edges = append(edges, asjob.EdgeUsers)
	}
	if m.agencys != nil {
		edges = append(edges, asjob.EdgeAgencys)
	}
	if m.roleDistribs != nil {
		edges = append(edges, asjob.EdgeRoleDistribs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asjob.EdgePersons:
		ids := make([]ent.Value, 0, len(m.persons))
		for id := range m.persons {
			ids = append(ids, id)
		}
		return ids
	case asjob.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case asjob.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case asjob.EdgeAgencys:
		ids := make([]ent.Value, 0, len(m.agencys))
		for id := range m.agencys {
			ids = append(ids, id)
		}
		return ids
	case asjob.EdgeRoleDistribs:
		ids := make([]ent.Value, 0, len(m.roleDistribs))
		for id := range m.roleDistribs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpersons != nil {
		edges = append(edges, asjob.EdgePersons)
	}
	if m.removedroles != nil {
		edges = append(edges, asjob.EdgeRoles)
	}
	if m.removedusers != nil {
		edges = append(edges, asjob.EdgeUsers)
	}
	if m.removedagencys != nil {
		edges = append(edges, asjob.EdgeAgencys)
	}
	if m.removedroleDistribs != nil {
		edges = append(edges, asjob.EdgeRoleDistribs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asjob.EdgePersons:
		ids := make([]ent.Value, 0, len(m.removedpersons))
		for id := range m.removedpersons {
			ids = append(ids, id)
		}
		return ids
	case asjob.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case asjob.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case asjob.EdgeAgencys:
		ids := make([]ent.Value, 0, len(m.removedagencys))
		for id := range m.removedagencys {
			ids = append(ids, id)
		}
		return ids
	case asjob.EdgeRoleDistribs:
		ids := make([]ent.Value, 0, len(m.removedroleDistribs))
		for id := range m.removedroleDistribs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedpersons {
		edges = append(edges, asjob.EdgePersons)
	}
	if m.clearedroles {
		edges = append(edges, asjob.EdgeRoles)
	}
	if m.clearedusers {
		edges = append(edges, asjob.EdgeUsers)
	}
	if m.clearedagencys {
		edges = append(edges, asjob.EdgeAgencys)
	}
	if m.clearedroleDistribs {
		edges = append(edges, asjob.EdgeRoleDistribs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsJobMutation) EdgeCleared(name string) bool {
	switch name {
	case asjob.EdgePersons:
		return m.clearedpersons
	case asjob.EdgeRoles:
		return m.clearedroles
	case asjob.EdgeUsers:
		return m.clearedusers
	case asjob.EdgeAgencys:
		return m.clearedagencys
	case asjob.EdgeRoleDistribs:
		return m.clearedroleDistribs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsJobMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AsJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsJobMutation) ResetEdge(name string) error {
	switch name {
	case asjob.EdgePersons:
		m.ResetPersons()
		return nil
	case asjob.EdgeRoles:
		m.ResetRoles()
		return nil
	case asjob.EdgeUsers:
		m.ResetUsers()
		return nil
	case asjob.EdgeAgencys:
		m.ResetAgencys()
		return nil
	case asjob.EdgeRoleDistribs:
		m.ResetRoleDistribs()
		return nil
	}
	return fmt.Errorf("unknown AsJob edge %s", name)
}

// AsLayerMutation represents an operation that mutates the AsLayer nodes in the graph.
type AsLayerMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	layer          *int64
	addlayer       *int64
	width          *int64
	addwidth       *int64
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	group          *int64
	clearedgroup   bool
	done           bool
	oldValue       func(context.Context) (*AsLayer, error)
	predicates     []predicate.AsLayer
}

var _ ent.Mutation = (*AsLayerMutation)(nil)

// aslayerOption allows management of the mutation configuration using functional options.
type aslayerOption func(*AsLayerMutation)

// newAsLayerMutation creates new mutation for the AsLayer entity.
func newAsLayerMutation(c config, op Op, opts ...aslayerOption) *AsLayerMutation {
	m := &AsLayerMutation{
		config:        c,
		op:            op,
		typ:           TypeAsLayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsLayerID sets the ID field of the mutation.
func withAsLayerID(id int64) aslayerOption {
	return func(m *AsLayerMutation) {
		var (
			err   error
			once  sync.Once
			value *AsLayer
		)
		m.oldValue = func(ctx context.Context) (*AsLayer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsLayer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsLayer sets the old AsLayer of the mutation.
func withAsLayer(node *AsLayer) aslayerOption {
	return func(m *AsLayerMutation) {
		m.oldValue = func(context.Context) (*AsLayer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsLayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsLayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsLayer entities.
func (m *AsLayerMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsLayerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsLayerMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsLayer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLayer sets the "layer" field.
func (m *AsLayerMutation) SetLayer(i int64) {
	m.layer = &i
	m.addlayer = nil
}

// Layer returns the value of the "layer" field in the mutation.
func (m *AsLayerMutation) Layer() (r int64, exists bool) {
	v := m.layer
	if v == nil {
		return
	}
	return *v, true
}

// OldLayer returns the old "layer" field's value of the AsLayer entity.
// If the AsLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsLayerMutation) OldLayer(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayer: %w", err)
	}
	return oldValue.Layer, nil
}

// AddLayer adds i to the "layer" field.
func (m *AsLayerMutation) AddLayer(i int64) {
	if m.addlayer != nil {
		*m.addlayer += i
	} else {
		m.addlayer = &i
	}
}

// AddedLayer returns the value that was added to the "layer" field in this mutation.
func (m *AsLayerMutation) AddedLayer() (r int64, exists bool) {
	v := m.addlayer
	if v == nil {
		return
	}
	return *v, true
}

// ClearLayer clears the value of the "layer" field.
func (m *AsLayerMutation) ClearLayer() {
	m.layer = nil
	m.addlayer = nil
	m.clearedFields[aslayer.FieldLayer] = struct{}{}
}

// LayerCleared returns if the "layer" field was cleared in this mutation.
func (m *AsLayerMutation) LayerCleared() bool {
	_, ok := m.clearedFields[aslayer.FieldLayer]
	return ok
}

// ResetLayer resets all changes to the "layer" field.
func (m *AsLayerMutation) ResetLayer() {
	m.layer = nil
	m.addlayer = nil
	delete(m.clearedFields, aslayer.FieldLayer)
}

// SetWidth sets the "width" field.
func (m *AsLayerMutation) SetWidth(i int64) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *AsLayerMutation) Width() (r int64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the AsLayer entity.
// If the AsLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsLayerMutation) OldWidth(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *AsLayerMutation) AddWidth(i int64) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *AsLayerMutation) AddedWidth() (r int64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *AsLayerMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[aslayer.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *AsLayerMutation) WidthCleared() bool {
	_, ok := m.clearedFields[aslayer.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *AsLayerMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, aslayer.FieldWidth)
}

// SetGroupID sets the "group_id" field.
func (m *AsLayerMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *AsLayerMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the AsLayer entity.
// If the AsLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsLayerMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *AsLayerMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[aslayer.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *AsLayerMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[aslayer.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *AsLayerMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, aslayer.FieldGroupID)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsLayerMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsLayerMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsLayer entity.
// If the AsLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsLayerMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsLayerMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsLayerMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsLayerMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsLayerMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsLayerMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsLayer entity.
// If the AsLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsLayerMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsLayerMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsLayerMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsLayerMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[aslayer.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsLayerMutation) StatusCleared() bool {
	_, ok := m.clearedFields[aslayer.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsLayerMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, aslayer.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsLayerMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsLayerMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsLayer entity.
// If the AsLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsLayerMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsLayerMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsLayerMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsLayerMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[aslayer.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsLayerMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[aslayer.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsLayerMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, aslayer.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsLayerMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsLayerMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsLayer entity.
// If the AsLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsLayerMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsLayerMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsLayerMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsLayerMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[aslayer.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsLayerMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[aslayer.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsLayerMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, aslayer.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsLayerMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsLayerMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsLayer entity.
// If the AsLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsLayerMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsLayerMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[aslayer.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsLayerMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[aslayer.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsLayerMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, aslayer.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsLayerMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsLayerMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsLayer entity.
// If the AsLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsLayerMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsLayerMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[aslayer.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsLayerMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[aslayer.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsLayerMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, aslayer.FieldUpdateTime)
}

// ClearGroup clears the "group" edge to the AsAllGroup entity.
func (m *AsLayerMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the AsAllGroup entity was cleared.
func (m *AsLayerMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *AsLayerMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *AsLayerMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the AsLayerMutation builder.
func (m *AsLayerMutation) Where(ps ...predicate.AsLayer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsLayerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsLayer).
func (m *AsLayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsLayerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.layer != nil {
		fields = append(fields, aslayer.FieldLayer)
	}
	if m.width != nil {
		fields = append(fields, aslayer.FieldWidth)
	}
	if m.group != nil {
		fields = append(fields, aslayer.FieldGroupID)
	}
	if m.is_deleted != nil {
		fields = append(fields, aslayer.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, aslayer.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, aslayer.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, aslayer.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, aslayer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, aslayer.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsLayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case aslayer.FieldLayer:
		return m.Layer()
	case aslayer.FieldWidth:
		return m.Width()
	case aslayer.FieldGroupID:
		return m.GroupID()
	case aslayer.FieldIsDeleted:
		return m.IsDeleted()
	case aslayer.FieldStatus:
		return m.Status()
	case aslayer.FieldCreateUser:
		return m.CreateUser()
	case aslayer.FieldUpdateUser:
		return m.UpdateUser()
	case aslayer.FieldCreateTime:
		return m.CreateTime()
	case aslayer.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsLayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case aslayer.FieldLayer:
		return m.OldLayer(ctx)
	case aslayer.FieldWidth:
		return m.OldWidth(ctx)
	case aslayer.FieldGroupID:
		return m.OldGroupID(ctx)
	case aslayer.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case aslayer.FieldStatus:
		return m.OldStatus(ctx)
	case aslayer.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case aslayer.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case aslayer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case aslayer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsLayer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsLayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case aslayer.FieldLayer:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayer(v)
		return nil
	case aslayer.FieldWidth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case aslayer.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case aslayer.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case aslayer.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case aslayer.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case aslayer.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case aslayer.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case aslayer.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsLayer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsLayerMutation) AddedFields() []string {
	var fields []string
	if m.addlayer != nil {
		fields = append(fields, aslayer.FieldLayer)
	}
	if m.addwidth != nil {
		fields = append(fields, aslayer.FieldWidth)
	}
	if m.addis_deleted != nil {
		fields = append(fields, aslayer.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, aslayer.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, aslayer.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, aslayer.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsLayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case aslayer.FieldLayer:
		return m.AddedLayer()
	case aslayer.FieldWidth:
		return m.AddedWidth()
	case aslayer.FieldIsDeleted:
		return m.AddedIsDeleted()
	case aslayer.FieldStatus:
		return m.AddedStatus()
	case aslayer.FieldCreateUser:
		return m.AddedCreateUser()
	case aslayer.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsLayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case aslayer.FieldLayer:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLayer(v)
		return nil
	case aslayer.FieldWidth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case aslayer.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case aslayer.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case aslayer.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case aslayer.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsLayer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsLayerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(aslayer.FieldLayer) {
		fields = append(fields, aslayer.FieldLayer)
	}
	if m.FieldCleared(aslayer.FieldWidth) {
		fields = append(fields, aslayer.FieldWidth)
	}
	if m.FieldCleared(aslayer.FieldGroupID) {
		fields = append(fields, aslayer.FieldGroupID)
	}
	if m.FieldCleared(aslayer.FieldStatus) {
		fields = append(fields, aslayer.FieldStatus)
	}
	if m.FieldCleared(aslayer.FieldCreateUser) {
		fields = append(fields, aslayer.FieldCreateUser)
	}
	if m.FieldCleared(aslayer.FieldUpdateUser) {
		fields = append(fields, aslayer.FieldUpdateUser)
	}
	if m.FieldCleared(aslayer.FieldCreateTime) {
		fields = append(fields, aslayer.FieldCreateTime)
	}
	if m.FieldCleared(aslayer.FieldUpdateTime) {
		fields = append(fields, aslayer.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsLayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsLayerMutation) ClearField(name string) error {
	switch name {
	case aslayer.FieldLayer:
		m.ClearLayer()
		return nil
	case aslayer.FieldWidth:
		m.ClearWidth()
		return nil
	case aslayer.FieldGroupID:
		m.ClearGroupID()
		return nil
	case aslayer.FieldStatus:
		m.ClearStatus()
		return nil
	case aslayer.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case aslayer.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case aslayer.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case aslayer.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsLayer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsLayerMutation) ResetField(name string) error {
	switch name {
	case aslayer.FieldLayer:
		m.ResetLayer()
		return nil
	case aslayer.FieldWidth:
		m.ResetWidth()
		return nil
	case aslayer.FieldGroupID:
		m.ResetGroupID()
		return nil
	case aslayer.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case aslayer.FieldStatus:
		m.ResetStatus()
		return nil
	case aslayer.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case aslayer.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case aslayer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case aslayer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsLayer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsLayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.group != nil {
		edges = append(edges, aslayer.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsLayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case aslayer.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsLayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsLayerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsLayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgroup {
		edges = append(edges, aslayer.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsLayerMutation) EdgeCleared(name string) bool {
	switch name {
	case aslayer.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsLayerMutation) ClearEdge(name string) error {
	switch name {
	case aslayer.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown AsLayer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsLayerMutation) ResetEdge(name string) error {
	switch name {
	case aslayer.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown AsLayer edge %s", name)
}

// AsMarketAppMutation represents an operation that mutates the AsMarketApp nodes in the graph.
type AsMarketAppMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int64
	app_name                        *string
	icon                            *string
	version                         *string
	contact                         *string
	contact_name                    *string
	description                     *string
	file                            *string
	sale_status                     *int64
	addsale_status                  *int64
	tenant_id                       *string
	platform                        *int64
	addplatform                     *int64
	target_user                     *int64
	addtarget_user                  *int64
	deploy_status                   *int64
	adddeploy_status                *int64
	deploy_address                  *string
	deploy_type                     *int64
	adddeploy_type                  *int64
	publish_time                    *date.DateTime
	app_type                        *int64
	addapp_type                     *int64
	apply_time                      *date.DateTime
	app_address                     *string
	app_mail                        *string
	app_photo                       *string
	app_field                       *int64
	addapp_field                    *int64
	app_category                    *int64
	addapp_category                 *int64
	app_project_source              *int64
	addapp_project_source           *int64
	app_star                        *int64
	addapp_star                     *int64
	app_founds_source               *int64
	addapp_founds_source            *int64
	inner_url                       *string
	out_url                         *string
	reform_status                   *int64
	addreform_status                *int64
	out_ip_url                      *string
	is_deleted                      *int64
	addis_deleted                   *int64
	status                          *int64
	addstatus                       *int64
	create_user                     *int64
	addcreate_user                  *int64
	update_user                     *int64
	addupdate_user                  *int64
	create_time                     *date.DateTime
	update_time                     *date.DateTime
	clearedFields                   map[string]struct{}
	appMenus                        map[int64]struct{}
	removedappMenus                 map[int64]struct{}
	clearedappMenus                 bool
	appRoles                        map[int64]struct{}
	removedappRoles                 map[int64]struct{}
	clearedappRoles                 bool
	useds                           map[int64]struct{}
	removeduseds                    map[int64]struct{}
	cleareduseds                    bool
	appAlerts                       map[int64]struct{}
	removedappAlerts                map[int64]struct{}
	clearedappAlerts                bool
	appRedeploys                    map[int64]struct{}
	removedappRedeploys             map[int64]struct{}
	clearedappRedeploys             bool
	appKeys                         map[int64]struct{}
	removedappKeys                  map[int64]struct{}
	clearedappKeys                  bool
	appPurchases                    map[int64]struct{}
	removedappPurchases             map[int64]struct{}
	clearedappPurchases             bool
	appComponents                   map[int64]struct{}
	removedappComponents            map[int64]struct{}
	clearedappComponents            bool
	appGroupDistribs                map[int64]struct{}
	removedappGroupDistribs         map[int64]struct{}
	clearedappGroupDistribs         bool
	appGroupDistribConfigs          map[int64]struct{}
	removedappGroupDistribConfigs   map[int64]struct{}
	clearedappGroupDistribConfigs   bool
	appGroupDistribsRelation        map[int64]struct{}
	removedappGroupDistribsRelation map[int64]struct{}
	clearedappGroupDistribsRelation bool
	done                            bool
	oldValue                        func(context.Context) (*AsMarketApp, error)
	predicates                      []predicate.AsMarketApp
}

var _ ent.Mutation = (*AsMarketAppMutation)(nil)

// asmarketappOption allows management of the mutation configuration using functional options.
type asmarketappOption func(*AsMarketAppMutation)

// newAsMarketAppMutation creates new mutation for the AsMarketApp entity.
func newAsMarketAppMutation(c config, op Op, opts ...asmarketappOption) *AsMarketAppMutation {
	m := &AsMarketAppMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppID sets the ID field of the mutation.
func withAsMarketAppID(id int64) asmarketappOption {
	return func(m *AsMarketAppMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketApp
		)
		m.oldValue = func(ctx context.Context) (*AsMarketApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketApp sets the old AsMarketApp of the mutation.
func withAsMarketApp(node *AsMarketApp) asmarketappOption {
	return func(m *AsMarketAppMutation) {
		m.oldValue = func(context.Context) (*AsMarketApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketApp entities.
func (m *AsMarketAppMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppName sets the "app_name" field.
func (m *AsMarketAppMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *AsMarketAppMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ClearAppName clears the value of the "app_name" field.
func (m *AsMarketAppMutation) ClearAppName() {
	m.app_name = nil
	m.clearedFields[asmarketapp.FieldAppName] = struct{}{}
}

// AppNameCleared returns if the "app_name" field was cleared in this mutation.
func (m *AsMarketAppMutation) AppNameCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldAppName]
	return ok
}

// ResetAppName resets all changes to the "app_name" field.
func (m *AsMarketAppMutation) ResetAppName() {
	m.app_name = nil
	delete(m.clearedFields, asmarketapp.FieldAppName)
}

// SetIcon sets the "icon" field.
func (m *AsMarketAppMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AsMarketAppMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *AsMarketAppMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[asmarketapp.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *AsMarketAppMutation) IconCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *AsMarketAppMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, asmarketapp.FieldIcon)
}

// SetVersion sets the "version" field.
func (m *AsMarketAppMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AsMarketAppMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *AsMarketAppMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[asmarketapp.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *AsMarketAppMutation) VersionCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *AsMarketAppMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, asmarketapp.FieldVersion)
}

// SetContact sets the "contact" field.
func (m *AsMarketAppMutation) SetContact(s string) {
	m.contact = &s
}

// Contact returns the value of the "contact" field in the mutation.
func (m *AsMarketAppMutation) Contact() (r string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ClearContact clears the value of the "contact" field.
func (m *AsMarketAppMutation) ClearContact() {
	m.contact = nil
	m.clearedFields[asmarketapp.FieldContact] = struct{}{}
}

// ContactCleared returns if the "contact" field was cleared in this mutation.
func (m *AsMarketAppMutation) ContactCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldContact]
	return ok
}

// ResetContact resets all changes to the "contact" field.
func (m *AsMarketAppMutation) ResetContact() {
	m.contact = nil
	delete(m.clearedFields, asmarketapp.FieldContact)
}

// SetContactName sets the "contact_name" field.
func (m *AsMarketAppMutation) SetContactName(s string) {
	m.contact_name = &s
}

// ContactName returns the value of the "contact_name" field in the mutation.
func (m *AsMarketAppMutation) ContactName() (r string, exists bool) {
	v := m.contact_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContactName returns the old "contact_name" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldContactName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactName: %w", err)
	}
	return oldValue.ContactName, nil
}

// ClearContactName clears the value of the "contact_name" field.
func (m *AsMarketAppMutation) ClearContactName() {
	m.contact_name = nil
	m.clearedFields[asmarketapp.FieldContactName] = struct{}{}
}

// ContactNameCleared returns if the "contact_name" field was cleared in this mutation.
func (m *AsMarketAppMutation) ContactNameCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldContactName]
	return ok
}

// ResetContactName resets all changes to the "contact_name" field.
func (m *AsMarketAppMutation) ResetContactName() {
	m.contact_name = nil
	delete(m.clearedFields, asmarketapp.FieldContactName)
}

// SetDescription sets the "description" field.
func (m *AsMarketAppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AsMarketAppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AsMarketAppMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[asmarketapp.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AsMarketAppMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AsMarketAppMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, asmarketapp.FieldDescription)
}

// SetFile sets the "file" field.
func (m *AsMarketAppMutation) SetFile(s string) {
	m.file = &s
}

// File returns the value of the "file" field in the mutation.
func (m *AsMarketAppMutation) File() (r string, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFile returns the old "file" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFile: %w", err)
	}
	return oldValue.File, nil
}

// ClearFile clears the value of the "file" field.
func (m *AsMarketAppMutation) ClearFile() {
	m.file = nil
	m.clearedFields[asmarketapp.FieldFile] = struct{}{}
}

// FileCleared returns if the "file" field was cleared in this mutation.
func (m *AsMarketAppMutation) FileCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldFile]
	return ok
}

// ResetFile resets all changes to the "file" field.
func (m *AsMarketAppMutation) ResetFile() {
	m.file = nil
	delete(m.clearedFields, asmarketapp.FieldFile)
}

// SetSaleStatus sets the "sale_status" field.
func (m *AsMarketAppMutation) SetSaleStatus(i int64) {
	m.sale_status = &i
	m.addsale_status = nil
}

// SaleStatus returns the value of the "sale_status" field in the mutation.
func (m *AsMarketAppMutation) SaleStatus() (r int64, exists bool) {
	v := m.sale_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleStatus returns the old "sale_status" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldSaleStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleStatus: %w", err)
	}
	return oldValue.SaleStatus, nil
}

// AddSaleStatus adds i to the "sale_status" field.
func (m *AsMarketAppMutation) AddSaleStatus(i int64) {
	if m.addsale_status != nil {
		*m.addsale_status += i
	} else {
		m.addsale_status = &i
	}
}

// AddedSaleStatus returns the value that was added to the "sale_status" field in this mutation.
func (m *AsMarketAppMutation) AddedSaleStatus() (r int64, exists bool) {
	v := m.addsale_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearSaleStatus clears the value of the "sale_status" field.
func (m *AsMarketAppMutation) ClearSaleStatus() {
	m.sale_status = nil
	m.addsale_status = nil
	m.clearedFields[asmarketapp.FieldSaleStatus] = struct{}{}
}

// SaleStatusCleared returns if the "sale_status" field was cleared in this mutation.
func (m *AsMarketAppMutation) SaleStatusCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldSaleStatus]
	return ok
}

// ResetSaleStatus resets all changes to the "sale_status" field.
func (m *AsMarketAppMutation) ResetSaleStatus() {
	m.sale_status = nil
	m.addsale_status = nil
	delete(m.clearedFields, asmarketapp.FieldSaleStatus)
}

// SetTenantID sets the "tenant_id" field.
func (m *AsMarketAppMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AsMarketAppMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AsMarketAppMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[asmarketapp.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AsMarketAppMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AsMarketAppMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, asmarketapp.FieldTenantID)
}

// SetPlatform sets the "platform" field.
func (m *AsMarketAppMutation) SetPlatform(i int64) {
	m.platform = &i
	m.addplatform = nil
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AsMarketAppMutation) Platform() (r int64, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldPlatform(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// AddPlatform adds i to the "platform" field.
func (m *AsMarketAppMutation) AddPlatform(i int64) {
	if m.addplatform != nil {
		*m.addplatform += i
	} else {
		m.addplatform = &i
	}
}

// AddedPlatform returns the value that was added to the "platform" field in this mutation.
func (m *AsMarketAppMutation) AddedPlatform() (r int64, exists bool) {
	v := m.addplatform
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlatform clears the value of the "platform" field.
func (m *AsMarketAppMutation) ClearPlatform() {
	m.platform = nil
	m.addplatform = nil
	m.clearedFields[asmarketapp.FieldPlatform] = struct{}{}
}

// PlatformCleared returns if the "platform" field was cleared in this mutation.
func (m *AsMarketAppMutation) PlatformCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldPlatform]
	return ok
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AsMarketAppMutation) ResetPlatform() {
	m.platform = nil
	m.addplatform = nil
	delete(m.clearedFields, asmarketapp.FieldPlatform)
}

// SetTargetUser sets the "target_user" field.
func (m *AsMarketAppMutation) SetTargetUser(i int64) {
	m.target_user = &i
	m.addtarget_user = nil
}

// TargetUser returns the value of the "target_user" field in the mutation.
func (m *AsMarketAppMutation) TargetUser() (r int64, exists bool) {
	v := m.target_user
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetUser returns the old "target_user" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldTargetUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetUser: %w", err)
	}
	return oldValue.TargetUser, nil
}

// AddTargetUser adds i to the "target_user" field.
func (m *AsMarketAppMutation) AddTargetUser(i int64) {
	if m.addtarget_user != nil {
		*m.addtarget_user += i
	} else {
		m.addtarget_user = &i
	}
}

// AddedTargetUser returns the value that was added to the "target_user" field in this mutation.
func (m *AsMarketAppMutation) AddedTargetUser() (r int64, exists bool) {
	v := m.addtarget_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetUser clears the value of the "target_user" field.
func (m *AsMarketAppMutation) ClearTargetUser() {
	m.target_user = nil
	m.addtarget_user = nil
	m.clearedFields[asmarketapp.FieldTargetUser] = struct{}{}
}

// TargetUserCleared returns if the "target_user" field was cleared in this mutation.
func (m *AsMarketAppMutation) TargetUserCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldTargetUser]
	return ok
}

// ResetTargetUser resets all changes to the "target_user" field.
func (m *AsMarketAppMutation) ResetTargetUser() {
	m.target_user = nil
	m.addtarget_user = nil
	delete(m.clearedFields, asmarketapp.FieldTargetUser)
}

// SetDeployStatus sets the "deploy_status" field.
func (m *AsMarketAppMutation) SetDeployStatus(i int64) {
	m.deploy_status = &i
	m.adddeploy_status = nil
}

// DeployStatus returns the value of the "deploy_status" field in the mutation.
func (m *AsMarketAppMutation) DeployStatus() (r int64, exists bool) {
	v := m.deploy_status
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployStatus returns the old "deploy_status" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldDeployStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployStatus: %w", err)
	}
	return oldValue.DeployStatus, nil
}

// AddDeployStatus adds i to the "deploy_status" field.
func (m *AsMarketAppMutation) AddDeployStatus(i int64) {
	if m.adddeploy_status != nil {
		*m.adddeploy_status += i
	} else {
		m.adddeploy_status = &i
	}
}

// AddedDeployStatus returns the value that was added to the "deploy_status" field in this mutation.
func (m *AsMarketAppMutation) AddedDeployStatus() (r int64, exists bool) {
	v := m.adddeploy_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeployStatus clears the value of the "deploy_status" field.
func (m *AsMarketAppMutation) ClearDeployStatus() {
	m.deploy_status = nil
	m.adddeploy_status = nil
	m.clearedFields[asmarketapp.FieldDeployStatus] = struct{}{}
}

// DeployStatusCleared returns if the "deploy_status" field was cleared in this mutation.
func (m *AsMarketAppMutation) DeployStatusCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldDeployStatus]
	return ok
}

// ResetDeployStatus resets all changes to the "deploy_status" field.
func (m *AsMarketAppMutation) ResetDeployStatus() {
	m.deploy_status = nil
	m.adddeploy_status = nil
	delete(m.clearedFields, asmarketapp.FieldDeployStatus)
}

// SetDeployAddress sets the "deploy_address" field.
func (m *AsMarketAppMutation) SetDeployAddress(s string) {
	m.deploy_address = &s
}

// DeployAddress returns the value of the "deploy_address" field in the mutation.
func (m *AsMarketAppMutation) DeployAddress() (r string, exists bool) {
	v := m.deploy_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployAddress returns the old "deploy_address" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldDeployAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployAddress: %w", err)
	}
	return oldValue.DeployAddress, nil
}

// ClearDeployAddress clears the value of the "deploy_address" field.
func (m *AsMarketAppMutation) ClearDeployAddress() {
	m.deploy_address = nil
	m.clearedFields[asmarketapp.FieldDeployAddress] = struct{}{}
}

// DeployAddressCleared returns if the "deploy_address" field was cleared in this mutation.
func (m *AsMarketAppMutation) DeployAddressCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldDeployAddress]
	return ok
}

// ResetDeployAddress resets all changes to the "deploy_address" field.
func (m *AsMarketAppMutation) ResetDeployAddress() {
	m.deploy_address = nil
	delete(m.clearedFields, asmarketapp.FieldDeployAddress)
}

// SetDeployType sets the "deploy_type" field.
func (m *AsMarketAppMutation) SetDeployType(i int64) {
	m.deploy_type = &i
	m.adddeploy_type = nil
}

// DeployType returns the value of the "deploy_type" field in the mutation.
func (m *AsMarketAppMutation) DeployType() (r int64, exists bool) {
	v := m.deploy_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployType returns the old "deploy_type" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldDeployType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployType: %w", err)
	}
	return oldValue.DeployType, nil
}

// AddDeployType adds i to the "deploy_type" field.
func (m *AsMarketAppMutation) AddDeployType(i int64) {
	if m.adddeploy_type != nil {
		*m.adddeploy_type += i
	} else {
		m.adddeploy_type = &i
	}
}

// AddedDeployType returns the value that was added to the "deploy_type" field in this mutation.
func (m *AsMarketAppMutation) AddedDeployType() (r int64, exists bool) {
	v := m.adddeploy_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeployType clears the value of the "deploy_type" field.
func (m *AsMarketAppMutation) ClearDeployType() {
	m.deploy_type = nil
	m.adddeploy_type = nil
	m.clearedFields[asmarketapp.FieldDeployType] = struct{}{}
}

// DeployTypeCleared returns if the "deploy_type" field was cleared in this mutation.
func (m *AsMarketAppMutation) DeployTypeCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldDeployType]
	return ok
}

// ResetDeployType resets all changes to the "deploy_type" field.
func (m *AsMarketAppMutation) ResetDeployType() {
	m.deploy_type = nil
	m.adddeploy_type = nil
	delete(m.clearedFields, asmarketapp.FieldDeployType)
}

// SetPublishTime sets the "publish_time" field.
func (m *AsMarketAppMutation) SetPublishTime(dt date.DateTime) {
	m.publish_time = &dt
}

// PublishTime returns the value of the "publish_time" field in the mutation.
func (m *AsMarketAppMutation) PublishTime() (r date.DateTime, exists bool) {
	v := m.publish_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishTime returns the old "publish_time" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldPublishTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishTime: %w", err)
	}
	return oldValue.PublishTime, nil
}

// ClearPublishTime clears the value of the "publish_time" field.
func (m *AsMarketAppMutation) ClearPublishTime() {
	m.publish_time = nil
	m.clearedFields[asmarketapp.FieldPublishTime] = struct{}{}
}

// PublishTimeCleared returns if the "publish_time" field was cleared in this mutation.
func (m *AsMarketAppMutation) PublishTimeCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldPublishTime]
	return ok
}

// ResetPublishTime resets all changes to the "publish_time" field.
func (m *AsMarketAppMutation) ResetPublishTime() {
	m.publish_time = nil
	delete(m.clearedFields, asmarketapp.FieldPublishTime)
}

// SetAppType sets the "app_type" field.
func (m *AsMarketAppMutation) SetAppType(i int64) {
	m.app_type = &i
	m.addapp_type = nil
}

// AppType returns the value of the "app_type" field in the mutation.
func (m *AsMarketAppMutation) AppType() (r int64, exists bool) {
	v := m.app_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAppType returns the old "app_type" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldAppType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppType: %w", err)
	}
	return oldValue.AppType, nil
}

// AddAppType adds i to the "app_type" field.
func (m *AsMarketAppMutation) AddAppType(i int64) {
	if m.addapp_type != nil {
		*m.addapp_type += i
	} else {
		m.addapp_type = &i
	}
}

// AddedAppType returns the value that was added to the "app_type" field in this mutation.
func (m *AsMarketAppMutation) AddedAppType() (r int64, exists bool) {
	v := m.addapp_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppType clears the value of the "app_type" field.
func (m *AsMarketAppMutation) ClearAppType() {
	m.app_type = nil
	m.addapp_type = nil
	m.clearedFields[asmarketapp.FieldAppType] = struct{}{}
}

// AppTypeCleared returns if the "app_type" field was cleared in this mutation.
func (m *AsMarketAppMutation) AppTypeCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldAppType]
	return ok
}

// ResetAppType resets all changes to the "app_type" field.
func (m *AsMarketAppMutation) ResetAppType() {
	m.app_type = nil
	m.addapp_type = nil
	delete(m.clearedFields, asmarketapp.FieldAppType)
}

// SetApplyTime sets the "apply_time" field.
func (m *AsMarketAppMutation) SetApplyTime(dt date.DateTime) {
	m.apply_time = &dt
}

// ApplyTime returns the value of the "apply_time" field in the mutation.
func (m *AsMarketAppMutation) ApplyTime() (r date.DateTime, exists bool) {
	v := m.apply_time
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyTime returns the old "apply_time" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldApplyTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplyTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplyTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyTime: %w", err)
	}
	return oldValue.ApplyTime, nil
}

// ClearApplyTime clears the value of the "apply_time" field.
func (m *AsMarketAppMutation) ClearApplyTime() {
	m.apply_time = nil
	m.clearedFields[asmarketapp.FieldApplyTime] = struct{}{}
}

// ApplyTimeCleared returns if the "apply_time" field was cleared in this mutation.
func (m *AsMarketAppMutation) ApplyTimeCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldApplyTime]
	return ok
}

// ResetApplyTime resets all changes to the "apply_time" field.
func (m *AsMarketAppMutation) ResetApplyTime() {
	m.apply_time = nil
	delete(m.clearedFields, asmarketapp.FieldApplyTime)
}

// SetAppAddress sets the "app_address" field.
func (m *AsMarketAppMutation) SetAppAddress(s string) {
	m.app_address = &s
}

// AppAddress returns the value of the "app_address" field in the mutation.
func (m *AsMarketAppMutation) AppAddress() (r string, exists bool) {
	v := m.app_address
	if v == nil {
		return
	}
	return *v, true
}

// OldAppAddress returns the old "app_address" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldAppAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppAddress: %w", err)
	}
	return oldValue.AppAddress, nil
}

// ClearAppAddress clears the value of the "app_address" field.
func (m *AsMarketAppMutation) ClearAppAddress() {
	m.app_address = nil
	m.clearedFields[asmarketapp.FieldAppAddress] = struct{}{}
}

// AppAddressCleared returns if the "app_address" field was cleared in this mutation.
func (m *AsMarketAppMutation) AppAddressCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldAppAddress]
	return ok
}

// ResetAppAddress resets all changes to the "app_address" field.
func (m *AsMarketAppMutation) ResetAppAddress() {
	m.app_address = nil
	delete(m.clearedFields, asmarketapp.FieldAppAddress)
}

// SetAppMail sets the "app_mail" field.
func (m *AsMarketAppMutation) SetAppMail(s string) {
	m.app_mail = &s
}

// AppMail returns the value of the "app_mail" field in the mutation.
func (m *AsMarketAppMutation) AppMail() (r string, exists bool) {
	v := m.app_mail
	if v == nil {
		return
	}
	return *v, true
}

// OldAppMail returns the old "app_mail" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldAppMail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppMail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppMail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppMail: %w", err)
	}
	return oldValue.AppMail, nil
}

// ClearAppMail clears the value of the "app_mail" field.
func (m *AsMarketAppMutation) ClearAppMail() {
	m.app_mail = nil
	m.clearedFields[asmarketapp.FieldAppMail] = struct{}{}
}

// AppMailCleared returns if the "app_mail" field was cleared in this mutation.
func (m *AsMarketAppMutation) AppMailCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldAppMail]
	return ok
}

// ResetAppMail resets all changes to the "app_mail" field.
func (m *AsMarketAppMutation) ResetAppMail() {
	m.app_mail = nil
	delete(m.clearedFields, asmarketapp.FieldAppMail)
}

// SetAppPhoto sets the "app_photo" field.
func (m *AsMarketAppMutation) SetAppPhoto(s string) {
	m.app_photo = &s
}

// AppPhoto returns the value of the "app_photo" field in the mutation.
func (m *AsMarketAppMutation) AppPhoto() (r string, exists bool) {
	v := m.app_photo
	if v == nil {
		return
	}
	return *v, true
}

// OldAppPhoto returns the old "app_photo" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldAppPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppPhoto: %w", err)
	}
	return oldValue.AppPhoto, nil
}

// ClearAppPhoto clears the value of the "app_photo" field.
func (m *AsMarketAppMutation) ClearAppPhoto() {
	m.app_photo = nil
	m.clearedFields[asmarketapp.FieldAppPhoto] = struct{}{}
}

// AppPhotoCleared returns if the "app_photo" field was cleared in this mutation.
func (m *AsMarketAppMutation) AppPhotoCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldAppPhoto]
	return ok
}

// ResetAppPhoto resets all changes to the "app_photo" field.
func (m *AsMarketAppMutation) ResetAppPhoto() {
	m.app_photo = nil
	delete(m.clearedFields, asmarketapp.FieldAppPhoto)
}

// SetAppField sets the "app_field" field.
func (m *AsMarketAppMutation) SetAppField(i int64) {
	m.app_field = &i
	m.addapp_field = nil
}

// AppField returns the value of the "app_field" field in the mutation.
func (m *AsMarketAppMutation) AppField() (r int64, exists bool) {
	v := m.app_field
	if v == nil {
		return
	}
	return *v, true
}

// OldAppField returns the old "app_field" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldAppField(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppField: %w", err)
	}
	return oldValue.AppField, nil
}

// AddAppField adds i to the "app_field" field.
func (m *AsMarketAppMutation) AddAppField(i int64) {
	if m.addapp_field != nil {
		*m.addapp_field += i
	} else {
		m.addapp_field = &i
	}
}

// AddedAppField returns the value that was added to the "app_field" field in this mutation.
func (m *AsMarketAppMutation) AddedAppField() (r int64, exists bool) {
	v := m.addapp_field
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppField clears the value of the "app_field" field.
func (m *AsMarketAppMutation) ClearAppField() {
	m.app_field = nil
	m.addapp_field = nil
	m.clearedFields[asmarketapp.FieldAppField] = struct{}{}
}

// AppFieldCleared returns if the "app_field" field was cleared in this mutation.
func (m *AsMarketAppMutation) AppFieldCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldAppField]
	return ok
}

// ResetAppField resets all changes to the "app_field" field.
func (m *AsMarketAppMutation) ResetAppField() {
	m.app_field = nil
	m.addapp_field = nil
	delete(m.clearedFields, asmarketapp.FieldAppField)
}

// SetAppCategory sets the "app_category" field.
func (m *AsMarketAppMutation) SetAppCategory(i int64) {
	m.app_category = &i
	m.addapp_category = nil
}

// AppCategory returns the value of the "app_category" field in the mutation.
func (m *AsMarketAppMutation) AppCategory() (r int64, exists bool) {
	v := m.app_category
	if v == nil {
		return
	}
	return *v, true
}

// OldAppCategory returns the old "app_category" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldAppCategory(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppCategory: %w", err)
	}
	return oldValue.AppCategory, nil
}

// AddAppCategory adds i to the "app_category" field.
func (m *AsMarketAppMutation) AddAppCategory(i int64) {
	if m.addapp_category != nil {
		*m.addapp_category += i
	} else {
		m.addapp_category = &i
	}
}

// AddedAppCategory returns the value that was added to the "app_category" field in this mutation.
func (m *AsMarketAppMutation) AddedAppCategory() (r int64, exists bool) {
	v := m.addapp_category
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppCategory clears the value of the "app_category" field.
func (m *AsMarketAppMutation) ClearAppCategory() {
	m.app_category = nil
	m.addapp_category = nil
	m.clearedFields[asmarketapp.FieldAppCategory] = struct{}{}
}

// AppCategoryCleared returns if the "app_category" field was cleared in this mutation.
func (m *AsMarketAppMutation) AppCategoryCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldAppCategory]
	return ok
}

// ResetAppCategory resets all changes to the "app_category" field.
func (m *AsMarketAppMutation) ResetAppCategory() {
	m.app_category = nil
	m.addapp_category = nil
	delete(m.clearedFields, asmarketapp.FieldAppCategory)
}

// SetAppProjectSource sets the "app_project_source" field.
func (m *AsMarketAppMutation) SetAppProjectSource(i int64) {
	m.app_project_source = &i
	m.addapp_project_source = nil
}

// AppProjectSource returns the value of the "app_project_source" field in the mutation.
func (m *AsMarketAppMutation) AppProjectSource() (r int64, exists bool) {
	v := m.app_project_source
	if v == nil {
		return
	}
	return *v, true
}

// OldAppProjectSource returns the old "app_project_source" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldAppProjectSource(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppProjectSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppProjectSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppProjectSource: %w", err)
	}
	return oldValue.AppProjectSource, nil
}

// AddAppProjectSource adds i to the "app_project_source" field.
func (m *AsMarketAppMutation) AddAppProjectSource(i int64) {
	if m.addapp_project_source != nil {
		*m.addapp_project_source += i
	} else {
		m.addapp_project_source = &i
	}
}

// AddedAppProjectSource returns the value that was added to the "app_project_source" field in this mutation.
func (m *AsMarketAppMutation) AddedAppProjectSource() (r int64, exists bool) {
	v := m.addapp_project_source
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppProjectSource clears the value of the "app_project_source" field.
func (m *AsMarketAppMutation) ClearAppProjectSource() {
	m.app_project_source = nil
	m.addapp_project_source = nil
	m.clearedFields[asmarketapp.FieldAppProjectSource] = struct{}{}
}

// AppProjectSourceCleared returns if the "app_project_source" field was cleared in this mutation.
func (m *AsMarketAppMutation) AppProjectSourceCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldAppProjectSource]
	return ok
}

// ResetAppProjectSource resets all changes to the "app_project_source" field.
func (m *AsMarketAppMutation) ResetAppProjectSource() {
	m.app_project_source = nil
	m.addapp_project_source = nil
	delete(m.clearedFields, asmarketapp.FieldAppProjectSource)
}

// SetAppStar sets the "app_star" field.
func (m *AsMarketAppMutation) SetAppStar(i int64) {
	m.app_star = &i
	m.addapp_star = nil
}

// AppStar returns the value of the "app_star" field in the mutation.
func (m *AsMarketAppMutation) AppStar() (r int64, exists bool) {
	v := m.app_star
	if v == nil {
		return
	}
	return *v, true
}

// OldAppStar returns the old "app_star" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldAppStar(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppStar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppStar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppStar: %w", err)
	}
	return oldValue.AppStar, nil
}

// AddAppStar adds i to the "app_star" field.
func (m *AsMarketAppMutation) AddAppStar(i int64) {
	if m.addapp_star != nil {
		*m.addapp_star += i
	} else {
		m.addapp_star = &i
	}
}

// AddedAppStar returns the value that was added to the "app_star" field in this mutation.
func (m *AsMarketAppMutation) AddedAppStar() (r int64, exists bool) {
	v := m.addapp_star
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppStar resets all changes to the "app_star" field.
func (m *AsMarketAppMutation) ResetAppStar() {
	m.app_star = nil
	m.addapp_star = nil
}

// SetAppFoundsSource sets the "app_founds_source" field.
func (m *AsMarketAppMutation) SetAppFoundsSource(i int64) {
	m.app_founds_source = &i
	m.addapp_founds_source = nil
}

// AppFoundsSource returns the value of the "app_founds_source" field in the mutation.
func (m *AsMarketAppMutation) AppFoundsSource() (r int64, exists bool) {
	v := m.app_founds_source
	if v == nil {
		return
	}
	return *v, true
}

// OldAppFoundsSource returns the old "app_founds_source" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldAppFoundsSource(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppFoundsSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppFoundsSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppFoundsSource: %w", err)
	}
	return oldValue.AppFoundsSource, nil
}

// AddAppFoundsSource adds i to the "app_founds_source" field.
func (m *AsMarketAppMutation) AddAppFoundsSource(i int64) {
	if m.addapp_founds_source != nil {
		*m.addapp_founds_source += i
	} else {
		m.addapp_founds_source = &i
	}
}

// AddedAppFoundsSource returns the value that was added to the "app_founds_source" field in this mutation.
func (m *AsMarketAppMutation) AddedAppFoundsSource() (r int64, exists bool) {
	v := m.addapp_founds_source
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppFoundsSource clears the value of the "app_founds_source" field.
func (m *AsMarketAppMutation) ClearAppFoundsSource() {
	m.app_founds_source = nil
	m.addapp_founds_source = nil
	m.clearedFields[asmarketapp.FieldAppFoundsSource] = struct{}{}
}

// AppFoundsSourceCleared returns if the "app_founds_source" field was cleared in this mutation.
func (m *AsMarketAppMutation) AppFoundsSourceCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldAppFoundsSource]
	return ok
}

// ResetAppFoundsSource resets all changes to the "app_founds_source" field.
func (m *AsMarketAppMutation) ResetAppFoundsSource() {
	m.app_founds_source = nil
	m.addapp_founds_source = nil
	delete(m.clearedFields, asmarketapp.FieldAppFoundsSource)
}

// SetInnerURL sets the "inner_url" field.
func (m *AsMarketAppMutation) SetInnerURL(s string) {
	m.inner_url = &s
}

// InnerURL returns the value of the "inner_url" field in the mutation.
func (m *AsMarketAppMutation) InnerURL() (r string, exists bool) {
	v := m.inner_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInnerURL returns the old "inner_url" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldInnerURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnerURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnerURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnerURL: %w", err)
	}
	return oldValue.InnerURL, nil
}

// ClearInnerURL clears the value of the "inner_url" field.
func (m *AsMarketAppMutation) ClearInnerURL() {
	m.inner_url = nil
	m.clearedFields[asmarketapp.FieldInnerURL] = struct{}{}
}

// InnerURLCleared returns if the "inner_url" field was cleared in this mutation.
func (m *AsMarketAppMutation) InnerURLCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldInnerURL]
	return ok
}

// ResetInnerURL resets all changes to the "inner_url" field.
func (m *AsMarketAppMutation) ResetInnerURL() {
	m.inner_url = nil
	delete(m.clearedFields, asmarketapp.FieldInnerURL)
}

// SetOutURL sets the "out_url" field.
func (m *AsMarketAppMutation) SetOutURL(s string) {
	m.out_url = &s
}

// OutURL returns the value of the "out_url" field in the mutation.
func (m *AsMarketAppMutation) OutURL() (r string, exists bool) {
	v := m.out_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOutURL returns the old "out_url" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldOutURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutURL: %w", err)
	}
	return oldValue.OutURL, nil
}

// ClearOutURL clears the value of the "out_url" field.
func (m *AsMarketAppMutation) ClearOutURL() {
	m.out_url = nil
	m.clearedFields[asmarketapp.FieldOutURL] = struct{}{}
}

// OutURLCleared returns if the "out_url" field was cleared in this mutation.
func (m *AsMarketAppMutation) OutURLCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldOutURL]
	return ok
}

// ResetOutURL resets all changes to the "out_url" field.
func (m *AsMarketAppMutation) ResetOutURL() {
	m.out_url = nil
	delete(m.clearedFields, asmarketapp.FieldOutURL)
}

// SetReformStatus sets the "reform_status" field.
func (m *AsMarketAppMutation) SetReformStatus(i int64) {
	m.reform_status = &i
	m.addreform_status = nil
}

// ReformStatus returns the value of the "reform_status" field in the mutation.
func (m *AsMarketAppMutation) ReformStatus() (r int64, exists bool) {
	v := m.reform_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReformStatus returns the old "reform_status" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldReformStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReformStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReformStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReformStatus: %w", err)
	}
	return oldValue.ReformStatus, nil
}

// AddReformStatus adds i to the "reform_status" field.
func (m *AsMarketAppMutation) AddReformStatus(i int64) {
	if m.addreform_status != nil {
		*m.addreform_status += i
	} else {
		m.addreform_status = &i
	}
}

// AddedReformStatus returns the value that was added to the "reform_status" field in this mutation.
func (m *AsMarketAppMutation) AddedReformStatus() (r int64, exists bool) {
	v := m.addreform_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetReformStatus resets all changes to the "reform_status" field.
func (m *AsMarketAppMutation) ResetReformStatus() {
	m.reform_status = nil
	m.addreform_status = nil
}

// SetOutIPURL sets the "out_ip_url" field.
func (m *AsMarketAppMutation) SetOutIPURL(s string) {
	m.out_ip_url = &s
}

// OutIPURL returns the value of the "out_ip_url" field in the mutation.
func (m *AsMarketAppMutation) OutIPURL() (r string, exists bool) {
	v := m.out_ip_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOutIPURL returns the old "out_ip_url" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldOutIPURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutIPURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutIPURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutIPURL: %w", err)
	}
	return oldValue.OutIPURL, nil
}

// ClearOutIPURL clears the value of the "out_ip_url" field.
func (m *AsMarketAppMutation) ClearOutIPURL() {
	m.out_ip_url = nil
	m.clearedFields[asmarketapp.FieldOutIPURL] = struct{}{}
}

// OutIPURLCleared returns if the "out_ip_url" field was cleared in this mutation.
func (m *AsMarketAppMutation) OutIPURLCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldOutIPURL]
	return ok
}

// ResetOutIPURL resets all changes to the "out_ip_url" field.
func (m *AsMarketAppMutation) ResetOutIPURL() {
	m.out_ip_url = nil
	delete(m.clearedFields, asmarketapp.FieldOutIPURL)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketapp.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketapp.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketapp.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketapp.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketapp.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketapp.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketapp.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketapp.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketApp entity.
// If the AsMarketApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketapp.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketapp.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketapp.FieldUpdateTime)
}

// AddAppMenuIDs adds the "appMenus" edge to the AsMarketMenu entity by ids.
func (m *AsMarketAppMutation) AddAppMenuIDs(ids ...int64) {
	if m.appMenus == nil {
		m.appMenus = make(map[int64]struct{})
	}
	for i := range ids {
		m.appMenus[ids[i]] = struct{}{}
	}
}

// ClearAppMenus clears the "appMenus" edge to the AsMarketMenu entity.
func (m *AsMarketAppMutation) ClearAppMenus() {
	m.clearedappMenus = true
}

// AppMenusCleared reports if the "appMenus" edge to the AsMarketMenu entity was cleared.
func (m *AsMarketAppMutation) AppMenusCleared() bool {
	return m.clearedappMenus
}

// RemoveAppMenuIDs removes the "appMenus" edge to the AsMarketMenu entity by IDs.
func (m *AsMarketAppMutation) RemoveAppMenuIDs(ids ...int64) {
	if m.removedappMenus == nil {
		m.removedappMenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appMenus, ids[i])
		m.removedappMenus[ids[i]] = struct{}{}
	}
}

// RemovedAppMenus returns the removed IDs of the "appMenus" edge to the AsMarketMenu entity.
func (m *AsMarketAppMutation) RemovedAppMenusIDs() (ids []int64) {
	for id := range m.removedappMenus {
		ids = append(ids, id)
	}
	return
}

// AppMenusIDs returns the "appMenus" edge IDs in the mutation.
func (m *AsMarketAppMutation) AppMenusIDs() (ids []int64) {
	for id := range m.appMenus {
		ids = append(ids, id)
	}
	return
}

// ResetAppMenus resets all changes to the "appMenus" edge.
func (m *AsMarketAppMutation) ResetAppMenus() {
	m.appMenus = nil
	m.clearedappMenus = false
	m.removedappMenus = nil
}

// AddAppRoleIDs adds the "appRoles" edge to the AsMarketAppRole entity by ids.
func (m *AsMarketAppMutation) AddAppRoleIDs(ids ...int64) {
	if m.appRoles == nil {
		m.appRoles = make(map[int64]struct{})
	}
	for i := range ids {
		m.appRoles[ids[i]] = struct{}{}
	}
}

// ClearAppRoles clears the "appRoles" edge to the AsMarketAppRole entity.
func (m *AsMarketAppMutation) ClearAppRoles() {
	m.clearedappRoles = true
}

// AppRolesCleared reports if the "appRoles" edge to the AsMarketAppRole entity was cleared.
func (m *AsMarketAppMutation) AppRolesCleared() bool {
	return m.clearedappRoles
}

// RemoveAppRoleIDs removes the "appRoles" edge to the AsMarketAppRole entity by IDs.
func (m *AsMarketAppMutation) RemoveAppRoleIDs(ids ...int64) {
	if m.removedappRoles == nil {
		m.removedappRoles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appRoles, ids[i])
		m.removedappRoles[ids[i]] = struct{}{}
	}
}

// RemovedAppRoles returns the removed IDs of the "appRoles" edge to the AsMarketAppRole entity.
func (m *AsMarketAppMutation) RemovedAppRolesIDs() (ids []int64) {
	for id := range m.removedappRoles {
		ids = append(ids, id)
	}
	return
}

// AppRolesIDs returns the "appRoles" edge IDs in the mutation.
func (m *AsMarketAppMutation) AppRolesIDs() (ids []int64) {
	for id := range m.appRoles {
		ids = append(ids, id)
	}
	return
}

// ResetAppRoles resets all changes to the "appRoles" edge.
func (m *AsMarketAppMutation) ResetAppRoles() {
	m.appRoles = nil
	m.clearedappRoles = false
	m.removedappRoles = nil
}

// AddUsedIDs adds the "useds" edge to the AsMarketUsedApp entity by ids.
func (m *AsMarketAppMutation) AddUsedIDs(ids ...int64) {
	if m.useds == nil {
		m.useds = make(map[int64]struct{})
	}
	for i := range ids {
		m.useds[ids[i]] = struct{}{}
	}
}

// ClearUseds clears the "useds" edge to the AsMarketUsedApp entity.
func (m *AsMarketAppMutation) ClearUseds() {
	m.cleareduseds = true
}

// UsedsCleared reports if the "useds" edge to the AsMarketUsedApp entity was cleared.
func (m *AsMarketAppMutation) UsedsCleared() bool {
	return m.cleareduseds
}

// RemoveUsedIDs removes the "useds" edge to the AsMarketUsedApp entity by IDs.
func (m *AsMarketAppMutation) RemoveUsedIDs(ids ...int64) {
	if m.removeduseds == nil {
		m.removeduseds = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.useds, ids[i])
		m.removeduseds[ids[i]] = struct{}{}
	}
}

// RemovedUseds returns the removed IDs of the "useds" edge to the AsMarketUsedApp entity.
func (m *AsMarketAppMutation) RemovedUsedsIDs() (ids []int64) {
	for id := range m.removeduseds {
		ids = append(ids, id)
	}
	return
}

// UsedsIDs returns the "useds" edge IDs in the mutation.
func (m *AsMarketAppMutation) UsedsIDs() (ids []int64) {
	for id := range m.useds {
		ids = append(ids, id)
	}
	return
}

// ResetUseds resets all changes to the "useds" edge.
func (m *AsMarketAppMutation) ResetUseds() {
	m.useds = nil
	m.cleareduseds = false
	m.removeduseds = nil
}

// AddAppAlertIDs adds the "appAlerts" edge to the AsMarketAppAlert entity by ids.
func (m *AsMarketAppMutation) AddAppAlertIDs(ids ...int64) {
	if m.appAlerts == nil {
		m.appAlerts = make(map[int64]struct{})
	}
	for i := range ids {
		m.appAlerts[ids[i]] = struct{}{}
	}
}

// ClearAppAlerts clears the "appAlerts" edge to the AsMarketAppAlert entity.
func (m *AsMarketAppMutation) ClearAppAlerts() {
	m.clearedappAlerts = true
}

// AppAlertsCleared reports if the "appAlerts" edge to the AsMarketAppAlert entity was cleared.
func (m *AsMarketAppMutation) AppAlertsCleared() bool {
	return m.clearedappAlerts
}

// RemoveAppAlertIDs removes the "appAlerts" edge to the AsMarketAppAlert entity by IDs.
func (m *AsMarketAppMutation) RemoveAppAlertIDs(ids ...int64) {
	if m.removedappAlerts == nil {
		m.removedappAlerts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appAlerts, ids[i])
		m.removedappAlerts[ids[i]] = struct{}{}
	}
}

// RemovedAppAlerts returns the removed IDs of the "appAlerts" edge to the AsMarketAppAlert entity.
func (m *AsMarketAppMutation) RemovedAppAlertsIDs() (ids []int64) {
	for id := range m.removedappAlerts {
		ids = append(ids, id)
	}
	return
}

// AppAlertsIDs returns the "appAlerts" edge IDs in the mutation.
func (m *AsMarketAppMutation) AppAlertsIDs() (ids []int64) {
	for id := range m.appAlerts {
		ids = append(ids, id)
	}
	return
}

// ResetAppAlerts resets all changes to the "appAlerts" edge.
func (m *AsMarketAppMutation) ResetAppAlerts() {
	m.appAlerts = nil
	m.clearedappAlerts = false
	m.removedappAlerts = nil
}

// AddAppRedeployIDs adds the "appRedeploys" edge to the AsRedeployData entity by ids.
func (m *AsMarketAppMutation) AddAppRedeployIDs(ids ...int64) {
	if m.appRedeploys == nil {
		m.appRedeploys = make(map[int64]struct{})
	}
	for i := range ids {
		m.appRedeploys[ids[i]] = struct{}{}
	}
}

// ClearAppRedeploys clears the "appRedeploys" edge to the AsRedeployData entity.
func (m *AsMarketAppMutation) ClearAppRedeploys() {
	m.clearedappRedeploys = true
}

// AppRedeploysCleared reports if the "appRedeploys" edge to the AsRedeployData entity was cleared.
func (m *AsMarketAppMutation) AppRedeploysCleared() bool {
	return m.clearedappRedeploys
}

// RemoveAppRedeployIDs removes the "appRedeploys" edge to the AsRedeployData entity by IDs.
func (m *AsMarketAppMutation) RemoveAppRedeployIDs(ids ...int64) {
	if m.removedappRedeploys == nil {
		m.removedappRedeploys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appRedeploys, ids[i])
		m.removedappRedeploys[ids[i]] = struct{}{}
	}
}

// RemovedAppRedeploys returns the removed IDs of the "appRedeploys" edge to the AsRedeployData entity.
func (m *AsMarketAppMutation) RemovedAppRedeploysIDs() (ids []int64) {
	for id := range m.removedappRedeploys {
		ids = append(ids, id)
	}
	return
}

// AppRedeploysIDs returns the "appRedeploys" edge IDs in the mutation.
func (m *AsMarketAppMutation) AppRedeploysIDs() (ids []int64) {
	for id := range m.appRedeploys {
		ids = append(ids, id)
	}
	return
}

// ResetAppRedeploys resets all changes to the "appRedeploys" edge.
func (m *AsMarketAppMutation) ResetAppRedeploys() {
	m.appRedeploys = nil
	m.clearedappRedeploys = false
	m.removedappRedeploys = nil
}

// AddAppKeyIDs adds the "appKeys" edge to the AsMarketAppKeySecret entity by ids.
func (m *AsMarketAppMutation) AddAppKeyIDs(ids ...int64) {
	if m.appKeys == nil {
		m.appKeys = make(map[int64]struct{})
	}
	for i := range ids {
		m.appKeys[ids[i]] = struct{}{}
	}
}

// ClearAppKeys clears the "appKeys" edge to the AsMarketAppKeySecret entity.
func (m *AsMarketAppMutation) ClearAppKeys() {
	m.clearedappKeys = true
}

// AppKeysCleared reports if the "appKeys" edge to the AsMarketAppKeySecret entity was cleared.
func (m *AsMarketAppMutation) AppKeysCleared() bool {
	return m.clearedappKeys
}

// RemoveAppKeyIDs removes the "appKeys" edge to the AsMarketAppKeySecret entity by IDs.
func (m *AsMarketAppMutation) RemoveAppKeyIDs(ids ...int64) {
	if m.removedappKeys == nil {
		m.removedappKeys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appKeys, ids[i])
		m.removedappKeys[ids[i]] = struct{}{}
	}
}

// RemovedAppKeys returns the removed IDs of the "appKeys" edge to the AsMarketAppKeySecret entity.
func (m *AsMarketAppMutation) RemovedAppKeysIDs() (ids []int64) {
	for id := range m.removedappKeys {
		ids = append(ids, id)
	}
	return
}

// AppKeysIDs returns the "appKeys" edge IDs in the mutation.
func (m *AsMarketAppMutation) AppKeysIDs() (ids []int64) {
	for id := range m.appKeys {
		ids = append(ids, id)
	}
	return
}

// ResetAppKeys resets all changes to the "appKeys" edge.
func (m *AsMarketAppMutation) ResetAppKeys() {
	m.appKeys = nil
	m.clearedappKeys = false
	m.removedappKeys = nil
}

// AddAppPurchaseIDs adds the "appPurchases" edge to the AsMarketAppPurchase entity by ids.
func (m *AsMarketAppMutation) AddAppPurchaseIDs(ids ...int64) {
	if m.appPurchases == nil {
		m.appPurchases = make(map[int64]struct{})
	}
	for i := range ids {
		m.appPurchases[ids[i]] = struct{}{}
	}
}

// ClearAppPurchases clears the "appPurchases" edge to the AsMarketAppPurchase entity.
func (m *AsMarketAppMutation) ClearAppPurchases() {
	m.clearedappPurchases = true
}

// AppPurchasesCleared reports if the "appPurchases" edge to the AsMarketAppPurchase entity was cleared.
func (m *AsMarketAppMutation) AppPurchasesCleared() bool {
	return m.clearedappPurchases
}

// RemoveAppPurchaseIDs removes the "appPurchases" edge to the AsMarketAppPurchase entity by IDs.
func (m *AsMarketAppMutation) RemoveAppPurchaseIDs(ids ...int64) {
	if m.removedappPurchases == nil {
		m.removedappPurchases = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appPurchases, ids[i])
		m.removedappPurchases[ids[i]] = struct{}{}
	}
}

// RemovedAppPurchases returns the removed IDs of the "appPurchases" edge to the AsMarketAppPurchase entity.
func (m *AsMarketAppMutation) RemovedAppPurchasesIDs() (ids []int64) {
	for id := range m.removedappPurchases {
		ids = append(ids, id)
	}
	return
}

// AppPurchasesIDs returns the "appPurchases" edge IDs in the mutation.
func (m *AsMarketAppMutation) AppPurchasesIDs() (ids []int64) {
	for id := range m.appPurchases {
		ids = append(ids, id)
	}
	return
}

// ResetAppPurchases resets all changes to the "appPurchases" edge.
func (m *AsMarketAppMutation) ResetAppPurchases() {
	m.appPurchases = nil
	m.clearedappPurchases = false
	m.removedappPurchases = nil
}

// AddAppComponentIDs adds the "appComponents" edge to the AsMarketAppComponent entity by ids.
func (m *AsMarketAppMutation) AddAppComponentIDs(ids ...int64) {
	if m.appComponents == nil {
		m.appComponents = make(map[int64]struct{})
	}
	for i := range ids {
		m.appComponents[ids[i]] = struct{}{}
	}
}

// ClearAppComponents clears the "appComponents" edge to the AsMarketAppComponent entity.
func (m *AsMarketAppMutation) ClearAppComponents() {
	m.clearedappComponents = true
}

// AppComponentsCleared reports if the "appComponents" edge to the AsMarketAppComponent entity was cleared.
func (m *AsMarketAppMutation) AppComponentsCleared() bool {
	return m.clearedappComponents
}

// RemoveAppComponentIDs removes the "appComponents" edge to the AsMarketAppComponent entity by IDs.
func (m *AsMarketAppMutation) RemoveAppComponentIDs(ids ...int64) {
	if m.removedappComponents == nil {
		m.removedappComponents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appComponents, ids[i])
		m.removedappComponents[ids[i]] = struct{}{}
	}
}

// RemovedAppComponents returns the removed IDs of the "appComponents" edge to the AsMarketAppComponent entity.
func (m *AsMarketAppMutation) RemovedAppComponentsIDs() (ids []int64) {
	for id := range m.removedappComponents {
		ids = append(ids, id)
	}
	return
}

// AppComponentsIDs returns the "appComponents" edge IDs in the mutation.
func (m *AsMarketAppMutation) AppComponentsIDs() (ids []int64) {
	for id := range m.appComponents {
		ids = append(ids, id)
	}
	return
}

// ResetAppComponents resets all changes to the "appComponents" edge.
func (m *AsMarketAppMutation) ResetAppComponents() {
	m.appComponents = nil
	m.clearedappComponents = false
	m.removedappComponents = nil
}

// AddAppGroupDistribIDs adds the "appGroupDistribs" edge to the AsMarketAppGroupDistribution entity by ids.
func (m *AsMarketAppMutation) AddAppGroupDistribIDs(ids ...int64) {
	if m.appGroupDistribs == nil {
		m.appGroupDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		m.appGroupDistribs[ids[i]] = struct{}{}
	}
}

// ClearAppGroupDistribs clears the "appGroupDistribs" edge to the AsMarketAppGroupDistribution entity.
func (m *AsMarketAppMutation) ClearAppGroupDistribs() {
	m.clearedappGroupDistribs = true
}

// AppGroupDistribsCleared reports if the "appGroupDistribs" edge to the AsMarketAppGroupDistribution entity was cleared.
func (m *AsMarketAppMutation) AppGroupDistribsCleared() bool {
	return m.clearedappGroupDistribs
}

// RemoveAppGroupDistribIDs removes the "appGroupDistribs" edge to the AsMarketAppGroupDistribution entity by IDs.
func (m *AsMarketAppMutation) RemoveAppGroupDistribIDs(ids ...int64) {
	if m.removedappGroupDistribs == nil {
		m.removedappGroupDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appGroupDistribs, ids[i])
		m.removedappGroupDistribs[ids[i]] = struct{}{}
	}
}

// RemovedAppGroupDistribs returns the removed IDs of the "appGroupDistribs" edge to the AsMarketAppGroupDistribution entity.
func (m *AsMarketAppMutation) RemovedAppGroupDistribsIDs() (ids []int64) {
	for id := range m.removedappGroupDistribs {
		ids = append(ids, id)
	}
	return
}

// AppGroupDistribsIDs returns the "appGroupDistribs" edge IDs in the mutation.
func (m *AsMarketAppMutation) AppGroupDistribsIDs() (ids []int64) {
	for id := range m.appGroupDistribs {
		ids = append(ids, id)
	}
	return
}

// ResetAppGroupDistribs resets all changes to the "appGroupDistribs" edge.
func (m *AsMarketAppMutation) ResetAppGroupDistribs() {
	m.appGroupDistribs = nil
	m.clearedappGroupDistribs = false
	m.removedappGroupDistribs = nil
}

// AddAppGroupDistribConfigIDs adds the "appGroupDistribConfigs" edge to the AsAppGroupDistributionData entity by ids.
func (m *AsMarketAppMutation) AddAppGroupDistribConfigIDs(ids ...int64) {
	if m.appGroupDistribConfigs == nil {
		m.appGroupDistribConfigs = make(map[int64]struct{})
	}
	for i := range ids {
		m.appGroupDistribConfigs[ids[i]] = struct{}{}
	}
}

// ClearAppGroupDistribConfigs clears the "appGroupDistribConfigs" edge to the AsAppGroupDistributionData entity.
func (m *AsMarketAppMutation) ClearAppGroupDistribConfigs() {
	m.clearedappGroupDistribConfigs = true
}

// AppGroupDistribConfigsCleared reports if the "appGroupDistribConfigs" edge to the AsAppGroupDistributionData entity was cleared.
func (m *AsMarketAppMutation) AppGroupDistribConfigsCleared() bool {
	return m.clearedappGroupDistribConfigs
}

// RemoveAppGroupDistribConfigIDs removes the "appGroupDistribConfigs" edge to the AsAppGroupDistributionData entity by IDs.
func (m *AsMarketAppMutation) RemoveAppGroupDistribConfigIDs(ids ...int64) {
	if m.removedappGroupDistribConfigs == nil {
		m.removedappGroupDistribConfigs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appGroupDistribConfigs, ids[i])
		m.removedappGroupDistribConfigs[ids[i]] = struct{}{}
	}
}

// RemovedAppGroupDistribConfigs returns the removed IDs of the "appGroupDistribConfigs" edge to the AsAppGroupDistributionData entity.
func (m *AsMarketAppMutation) RemovedAppGroupDistribConfigsIDs() (ids []int64) {
	for id := range m.removedappGroupDistribConfigs {
		ids = append(ids, id)
	}
	return
}

// AppGroupDistribConfigsIDs returns the "appGroupDistribConfigs" edge IDs in the mutation.
func (m *AsMarketAppMutation) AppGroupDistribConfigsIDs() (ids []int64) {
	for id := range m.appGroupDistribConfigs {
		ids = append(ids, id)
	}
	return
}

// ResetAppGroupDistribConfigs resets all changes to the "appGroupDistribConfigs" edge.
func (m *AsMarketAppMutation) ResetAppGroupDistribConfigs() {
	m.appGroupDistribConfigs = nil
	m.clearedappGroupDistribConfigs = false
	m.removedappGroupDistribConfigs = nil
}

// AddAppGroupDistribsRelationIDs adds the "appGroupDistribsRelation" edge to the AsMarketAppGroupDistributionRelation entity by ids.
func (m *AsMarketAppMutation) AddAppGroupDistribsRelationIDs(ids ...int64) {
	if m.appGroupDistribsRelation == nil {
		m.appGroupDistribsRelation = make(map[int64]struct{})
	}
	for i := range ids {
		m.appGroupDistribsRelation[ids[i]] = struct{}{}
	}
}

// ClearAppGroupDistribsRelation clears the "appGroupDistribsRelation" edge to the AsMarketAppGroupDistributionRelation entity.
func (m *AsMarketAppMutation) ClearAppGroupDistribsRelation() {
	m.clearedappGroupDistribsRelation = true
}

// AppGroupDistribsRelationCleared reports if the "appGroupDistribsRelation" edge to the AsMarketAppGroupDistributionRelation entity was cleared.
func (m *AsMarketAppMutation) AppGroupDistribsRelationCleared() bool {
	return m.clearedappGroupDistribsRelation
}

// RemoveAppGroupDistribsRelationIDs removes the "appGroupDistribsRelation" edge to the AsMarketAppGroupDistributionRelation entity by IDs.
func (m *AsMarketAppMutation) RemoveAppGroupDistribsRelationIDs(ids ...int64) {
	if m.removedappGroupDistribsRelation == nil {
		m.removedappGroupDistribsRelation = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appGroupDistribsRelation, ids[i])
		m.removedappGroupDistribsRelation[ids[i]] = struct{}{}
	}
}

// RemovedAppGroupDistribsRelation returns the removed IDs of the "appGroupDistribsRelation" edge to the AsMarketAppGroupDistributionRelation entity.
func (m *AsMarketAppMutation) RemovedAppGroupDistribsRelationIDs() (ids []int64) {
	for id := range m.removedappGroupDistribsRelation {
		ids = append(ids, id)
	}
	return
}

// AppGroupDistribsRelationIDs returns the "appGroupDistribsRelation" edge IDs in the mutation.
func (m *AsMarketAppMutation) AppGroupDistribsRelationIDs() (ids []int64) {
	for id := range m.appGroupDistribsRelation {
		ids = append(ids, id)
	}
	return
}

// ResetAppGroupDistribsRelation resets all changes to the "appGroupDistribsRelation" edge.
func (m *AsMarketAppMutation) ResetAppGroupDistribsRelation() {
	m.appGroupDistribsRelation = nil
	m.clearedappGroupDistribsRelation = false
	m.removedappGroupDistribsRelation = nil
}

// Where appends a list predicates to the AsMarketAppMutation builder.
func (m *AsMarketAppMutation) Where(ps ...predicate.AsMarketApp) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketApp).
func (m *AsMarketAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppMutation) Fields() []string {
	fields := make([]string, 0, 35)
	if m.app_name != nil {
		fields = append(fields, asmarketapp.FieldAppName)
	}
	if m.icon != nil {
		fields = append(fields, asmarketapp.FieldIcon)
	}
	if m.version != nil {
		fields = append(fields, asmarketapp.FieldVersion)
	}
	if m.contact != nil {
		fields = append(fields, asmarketapp.FieldContact)
	}
	if m.contact_name != nil {
		fields = append(fields, asmarketapp.FieldContactName)
	}
	if m.description != nil {
		fields = append(fields, asmarketapp.FieldDescription)
	}
	if m.file != nil {
		fields = append(fields, asmarketapp.FieldFile)
	}
	if m.sale_status != nil {
		fields = append(fields, asmarketapp.FieldSaleStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, asmarketapp.FieldTenantID)
	}
	if m.platform != nil {
		fields = append(fields, asmarketapp.FieldPlatform)
	}
	if m.target_user != nil {
		fields = append(fields, asmarketapp.FieldTargetUser)
	}
	if m.deploy_status != nil {
		fields = append(fields, asmarketapp.FieldDeployStatus)
	}
	if m.deploy_address != nil {
		fields = append(fields, asmarketapp.FieldDeployAddress)
	}
	if m.deploy_type != nil {
		fields = append(fields, asmarketapp.FieldDeployType)
	}
	if m.publish_time != nil {
		fields = append(fields, asmarketapp.FieldPublishTime)
	}
	if m.app_type != nil {
		fields = append(fields, asmarketapp.FieldAppType)
	}
	if m.apply_time != nil {
		fields = append(fields, asmarketapp.FieldApplyTime)
	}
	if m.app_address != nil {
		fields = append(fields, asmarketapp.FieldAppAddress)
	}
	if m.app_mail != nil {
		fields = append(fields, asmarketapp.FieldAppMail)
	}
	if m.app_photo != nil {
		fields = append(fields, asmarketapp.FieldAppPhoto)
	}
	if m.app_field != nil {
		fields = append(fields, asmarketapp.FieldAppField)
	}
	if m.app_category != nil {
		fields = append(fields, asmarketapp.FieldAppCategory)
	}
	if m.app_project_source != nil {
		fields = append(fields, asmarketapp.FieldAppProjectSource)
	}
	if m.app_star != nil {
		fields = append(fields, asmarketapp.FieldAppStar)
	}
	if m.app_founds_source != nil {
		fields = append(fields, asmarketapp.FieldAppFoundsSource)
	}
	if m.inner_url != nil {
		fields = append(fields, asmarketapp.FieldInnerURL)
	}
	if m.out_url != nil {
		fields = append(fields, asmarketapp.FieldOutURL)
	}
	if m.reform_status != nil {
		fields = append(fields, asmarketapp.FieldReformStatus)
	}
	if m.out_ip_url != nil {
		fields = append(fields, asmarketapp.FieldOutIPURL)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketapp.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketapp.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketapp.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketapp.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketapp.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketapp.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketapp.FieldAppName:
		return m.AppName()
	case asmarketapp.FieldIcon:
		return m.Icon()
	case asmarketapp.FieldVersion:
		return m.Version()
	case asmarketapp.FieldContact:
		return m.Contact()
	case asmarketapp.FieldContactName:
		return m.ContactName()
	case asmarketapp.FieldDescription:
		return m.Description()
	case asmarketapp.FieldFile:
		return m.File()
	case asmarketapp.FieldSaleStatus:
		return m.SaleStatus()
	case asmarketapp.FieldTenantID:
		return m.TenantID()
	case asmarketapp.FieldPlatform:
		return m.Platform()
	case asmarketapp.FieldTargetUser:
		return m.TargetUser()
	case asmarketapp.FieldDeployStatus:
		return m.DeployStatus()
	case asmarketapp.FieldDeployAddress:
		return m.DeployAddress()
	case asmarketapp.FieldDeployType:
		return m.DeployType()
	case asmarketapp.FieldPublishTime:
		return m.PublishTime()
	case asmarketapp.FieldAppType:
		return m.AppType()
	case asmarketapp.FieldApplyTime:
		return m.ApplyTime()
	case asmarketapp.FieldAppAddress:
		return m.AppAddress()
	case asmarketapp.FieldAppMail:
		return m.AppMail()
	case asmarketapp.FieldAppPhoto:
		return m.AppPhoto()
	case asmarketapp.FieldAppField:
		return m.AppField()
	case asmarketapp.FieldAppCategory:
		return m.AppCategory()
	case asmarketapp.FieldAppProjectSource:
		return m.AppProjectSource()
	case asmarketapp.FieldAppStar:
		return m.AppStar()
	case asmarketapp.FieldAppFoundsSource:
		return m.AppFoundsSource()
	case asmarketapp.FieldInnerURL:
		return m.InnerURL()
	case asmarketapp.FieldOutURL:
		return m.OutURL()
	case asmarketapp.FieldReformStatus:
		return m.ReformStatus()
	case asmarketapp.FieldOutIPURL:
		return m.OutIPURL()
	case asmarketapp.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketapp.FieldStatus:
		return m.Status()
	case asmarketapp.FieldCreateUser:
		return m.CreateUser()
	case asmarketapp.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketapp.FieldCreateTime:
		return m.CreateTime()
	case asmarketapp.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketapp.FieldAppName:
		return m.OldAppName(ctx)
	case asmarketapp.FieldIcon:
		return m.OldIcon(ctx)
	case asmarketapp.FieldVersion:
		return m.OldVersion(ctx)
	case asmarketapp.FieldContact:
		return m.OldContact(ctx)
	case asmarketapp.FieldContactName:
		return m.OldContactName(ctx)
	case asmarketapp.FieldDescription:
		return m.OldDescription(ctx)
	case asmarketapp.FieldFile:
		return m.OldFile(ctx)
	case asmarketapp.FieldSaleStatus:
		return m.OldSaleStatus(ctx)
	case asmarketapp.FieldTenantID:
		return m.OldTenantID(ctx)
	case asmarketapp.FieldPlatform:
		return m.OldPlatform(ctx)
	case asmarketapp.FieldTargetUser:
		return m.OldTargetUser(ctx)
	case asmarketapp.FieldDeployStatus:
		return m.OldDeployStatus(ctx)
	case asmarketapp.FieldDeployAddress:
		return m.OldDeployAddress(ctx)
	case asmarketapp.FieldDeployType:
		return m.OldDeployType(ctx)
	case asmarketapp.FieldPublishTime:
		return m.OldPublishTime(ctx)
	case asmarketapp.FieldAppType:
		return m.OldAppType(ctx)
	case asmarketapp.FieldApplyTime:
		return m.OldApplyTime(ctx)
	case asmarketapp.FieldAppAddress:
		return m.OldAppAddress(ctx)
	case asmarketapp.FieldAppMail:
		return m.OldAppMail(ctx)
	case asmarketapp.FieldAppPhoto:
		return m.OldAppPhoto(ctx)
	case asmarketapp.FieldAppField:
		return m.OldAppField(ctx)
	case asmarketapp.FieldAppCategory:
		return m.OldAppCategory(ctx)
	case asmarketapp.FieldAppProjectSource:
		return m.OldAppProjectSource(ctx)
	case asmarketapp.FieldAppStar:
		return m.OldAppStar(ctx)
	case asmarketapp.FieldAppFoundsSource:
		return m.OldAppFoundsSource(ctx)
	case asmarketapp.FieldInnerURL:
		return m.OldInnerURL(ctx)
	case asmarketapp.FieldOutURL:
		return m.OldOutURL(ctx)
	case asmarketapp.FieldReformStatus:
		return m.OldReformStatus(ctx)
	case asmarketapp.FieldOutIPURL:
		return m.OldOutIPURL(ctx)
	case asmarketapp.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketapp.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketapp.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketapp.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketapp.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketapp.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketapp.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	case asmarketapp.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case asmarketapp.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case asmarketapp.FieldContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case asmarketapp.FieldContactName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactName(v)
		return nil
	case asmarketapp.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case asmarketapp.FieldFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFile(v)
		return nil
	case asmarketapp.FieldSaleStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleStatus(v)
		return nil
	case asmarketapp.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case asmarketapp.FieldPlatform:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case asmarketapp.FieldTargetUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetUser(v)
		return nil
	case asmarketapp.FieldDeployStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployStatus(v)
		return nil
	case asmarketapp.FieldDeployAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployAddress(v)
		return nil
	case asmarketapp.FieldDeployType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployType(v)
		return nil
	case asmarketapp.FieldPublishTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishTime(v)
		return nil
	case asmarketapp.FieldAppType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppType(v)
		return nil
	case asmarketapp.FieldApplyTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyTime(v)
		return nil
	case asmarketapp.FieldAppAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppAddress(v)
		return nil
	case asmarketapp.FieldAppMail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppMail(v)
		return nil
	case asmarketapp.FieldAppPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppPhoto(v)
		return nil
	case asmarketapp.FieldAppField:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppField(v)
		return nil
	case asmarketapp.FieldAppCategory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppCategory(v)
		return nil
	case asmarketapp.FieldAppProjectSource:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppProjectSource(v)
		return nil
	case asmarketapp.FieldAppStar:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppStar(v)
		return nil
	case asmarketapp.FieldAppFoundsSource:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppFoundsSource(v)
		return nil
	case asmarketapp.FieldInnerURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnerURL(v)
		return nil
	case asmarketapp.FieldOutURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutURL(v)
		return nil
	case asmarketapp.FieldReformStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReformStatus(v)
		return nil
	case asmarketapp.FieldOutIPURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutIPURL(v)
		return nil
	case asmarketapp.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketapp.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketapp.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketapp.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketapp.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketapp.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppMutation) AddedFields() []string {
	var fields []string
	if m.addsale_status != nil {
		fields = append(fields, asmarketapp.FieldSaleStatus)
	}
	if m.addplatform != nil {
		fields = append(fields, asmarketapp.FieldPlatform)
	}
	if m.addtarget_user != nil {
		fields = append(fields, asmarketapp.FieldTargetUser)
	}
	if m.adddeploy_status != nil {
		fields = append(fields, asmarketapp.FieldDeployStatus)
	}
	if m.adddeploy_type != nil {
		fields = append(fields, asmarketapp.FieldDeployType)
	}
	if m.addapp_type != nil {
		fields = append(fields, asmarketapp.FieldAppType)
	}
	if m.addapp_field != nil {
		fields = append(fields, asmarketapp.FieldAppField)
	}
	if m.addapp_category != nil {
		fields = append(fields, asmarketapp.FieldAppCategory)
	}
	if m.addapp_project_source != nil {
		fields = append(fields, asmarketapp.FieldAppProjectSource)
	}
	if m.addapp_star != nil {
		fields = append(fields, asmarketapp.FieldAppStar)
	}
	if m.addapp_founds_source != nil {
		fields = append(fields, asmarketapp.FieldAppFoundsSource)
	}
	if m.addreform_status != nil {
		fields = append(fields, asmarketapp.FieldReformStatus)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketapp.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketapp.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketapp.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketapp.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketapp.FieldSaleStatus:
		return m.AddedSaleStatus()
	case asmarketapp.FieldPlatform:
		return m.AddedPlatform()
	case asmarketapp.FieldTargetUser:
		return m.AddedTargetUser()
	case asmarketapp.FieldDeployStatus:
		return m.AddedDeployStatus()
	case asmarketapp.FieldDeployType:
		return m.AddedDeployType()
	case asmarketapp.FieldAppType:
		return m.AddedAppType()
	case asmarketapp.FieldAppField:
		return m.AddedAppField()
	case asmarketapp.FieldAppCategory:
		return m.AddedAppCategory()
	case asmarketapp.FieldAppProjectSource:
		return m.AddedAppProjectSource()
	case asmarketapp.FieldAppStar:
		return m.AddedAppStar()
	case asmarketapp.FieldAppFoundsSource:
		return m.AddedAppFoundsSource()
	case asmarketapp.FieldReformStatus:
		return m.AddedReformStatus()
	case asmarketapp.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketapp.FieldStatus:
		return m.AddedStatus()
	case asmarketapp.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketapp.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketapp.FieldSaleStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleStatus(v)
		return nil
	case asmarketapp.FieldPlatform:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatform(v)
		return nil
	case asmarketapp.FieldTargetUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetUser(v)
		return nil
	case asmarketapp.FieldDeployStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeployStatus(v)
		return nil
	case asmarketapp.FieldDeployType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeployType(v)
		return nil
	case asmarketapp.FieldAppType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppType(v)
		return nil
	case asmarketapp.FieldAppField:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppField(v)
		return nil
	case asmarketapp.FieldAppCategory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppCategory(v)
		return nil
	case asmarketapp.FieldAppProjectSource:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppProjectSource(v)
		return nil
	case asmarketapp.FieldAppStar:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppStar(v)
		return nil
	case asmarketapp.FieldAppFoundsSource:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppFoundsSource(v)
		return nil
	case asmarketapp.FieldReformStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReformStatus(v)
		return nil
	case asmarketapp.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketapp.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketapp.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketapp.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketapp.FieldAppName) {
		fields = append(fields, asmarketapp.FieldAppName)
	}
	if m.FieldCleared(asmarketapp.FieldIcon) {
		fields = append(fields, asmarketapp.FieldIcon)
	}
	if m.FieldCleared(asmarketapp.FieldVersion) {
		fields = append(fields, asmarketapp.FieldVersion)
	}
	if m.FieldCleared(asmarketapp.FieldContact) {
		fields = append(fields, asmarketapp.FieldContact)
	}
	if m.FieldCleared(asmarketapp.FieldContactName) {
		fields = append(fields, asmarketapp.FieldContactName)
	}
	if m.FieldCleared(asmarketapp.FieldDescription) {
		fields = append(fields, asmarketapp.FieldDescription)
	}
	if m.FieldCleared(asmarketapp.FieldFile) {
		fields = append(fields, asmarketapp.FieldFile)
	}
	if m.FieldCleared(asmarketapp.FieldSaleStatus) {
		fields = append(fields, asmarketapp.FieldSaleStatus)
	}
	if m.FieldCleared(asmarketapp.FieldTenantID) {
		fields = append(fields, asmarketapp.FieldTenantID)
	}
	if m.FieldCleared(asmarketapp.FieldPlatform) {
		fields = append(fields, asmarketapp.FieldPlatform)
	}
	if m.FieldCleared(asmarketapp.FieldTargetUser) {
		fields = append(fields, asmarketapp.FieldTargetUser)
	}
	if m.FieldCleared(asmarketapp.FieldDeployStatus) {
		fields = append(fields, asmarketapp.FieldDeployStatus)
	}
	if m.FieldCleared(asmarketapp.FieldDeployAddress) {
		fields = append(fields, asmarketapp.FieldDeployAddress)
	}
	if m.FieldCleared(asmarketapp.FieldDeployType) {
		fields = append(fields, asmarketapp.FieldDeployType)
	}
	if m.FieldCleared(asmarketapp.FieldPublishTime) {
		fields = append(fields, asmarketapp.FieldPublishTime)
	}
	if m.FieldCleared(asmarketapp.FieldAppType) {
		fields = append(fields, asmarketapp.FieldAppType)
	}
	if m.FieldCleared(asmarketapp.FieldApplyTime) {
		fields = append(fields, asmarketapp.FieldApplyTime)
	}
	if m.FieldCleared(asmarketapp.FieldAppAddress) {
		fields = append(fields, asmarketapp.FieldAppAddress)
	}
	if m.FieldCleared(asmarketapp.FieldAppMail) {
		fields = append(fields, asmarketapp.FieldAppMail)
	}
	if m.FieldCleared(asmarketapp.FieldAppPhoto) {
		fields = append(fields, asmarketapp.FieldAppPhoto)
	}
	if m.FieldCleared(asmarketapp.FieldAppField) {
		fields = append(fields, asmarketapp.FieldAppField)
	}
	if m.FieldCleared(asmarketapp.FieldAppCategory) {
		fields = append(fields, asmarketapp.FieldAppCategory)
	}
	if m.FieldCleared(asmarketapp.FieldAppProjectSource) {
		fields = append(fields, asmarketapp.FieldAppProjectSource)
	}
	if m.FieldCleared(asmarketapp.FieldAppFoundsSource) {
		fields = append(fields, asmarketapp.FieldAppFoundsSource)
	}
	if m.FieldCleared(asmarketapp.FieldInnerURL) {
		fields = append(fields, asmarketapp.FieldInnerURL)
	}
	if m.FieldCleared(asmarketapp.FieldOutURL) {
		fields = append(fields, asmarketapp.FieldOutURL)
	}
	if m.FieldCleared(asmarketapp.FieldOutIPURL) {
		fields = append(fields, asmarketapp.FieldOutIPURL)
	}
	if m.FieldCleared(asmarketapp.FieldStatus) {
		fields = append(fields, asmarketapp.FieldStatus)
	}
	if m.FieldCleared(asmarketapp.FieldCreateUser) {
		fields = append(fields, asmarketapp.FieldCreateUser)
	}
	if m.FieldCleared(asmarketapp.FieldUpdateUser) {
		fields = append(fields, asmarketapp.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketapp.FieldCreateTime) {
		fields = append(fields, asmarketapp.FieldCreateTime)
	}
	if m.FieldCleared(asmarketapp.FieldUpdateTime) {
		fields = append(fields, asmarketapp.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppMutation) ClearField(name string) error {
	switch name {
	case asmarketapp.FieldAppName:
		m.ClearAppName()
		return nil
	case asmarketapp.FieldIcon:
		m.ClearIcon()
		return nil
	case asmarketapp.FieldVersion:
		m.ClearVersion()
		return nil
	case asmarketapp.FieldContact:
		m.ClearContact()
		return nil
	case asmarketapp.FieldContactName:
		m.ClearContactName()
		return nil
	case asmarketapp.FieldDescription:
		m.ClearDescription()
		return nil
	case asmarketapp.FieldFile:
		m.ClearFile()
		return nil
	case asmarketapp.FieldSaleStatus:
		m.ClearSaleStatus()
		return nil
	case asmarketapp.FieldTenantID:
		m.ClearTenantID()
		return nil
	case asmarketapp.FieldPlatform:
		m.ClearPlatform()
		return nil
	case asmarketapp.FieldTargetUser:
		m.ClearTargetUser()
		return nil
	case asmarketapp.FieldDeployStatus:
		m.ClearDeployStatus()
		return nil
	case asmarketapp.FieldDeployAddress:
		m.ClearDeployAddress()
		return nil
	case asmarketapp.FieldDeployType:
		m.ClearDeployType()
		return nil
	case asmarketapp.FieldPublishTime:
		m.ClearPublishTime()
		return nil
	case asmarketapp.FieldAppType:
		m.ClearAppType()
		return nil
	case asmarketapp.FieldApplyTime:
		m.ClearApplyTime()
		return nil
	case asmarketapp.FieldAppAddress:
		m.ClearAppAddress()
		return nil
	case asmarketapp.FieldAppMail:
		m.ClearAppMail()
		return nil
	case asmarketapp.FieldAppPhoto:
		m.ClearAppPhoto()
		return nil
	case asmarketapp.FieldAppField:
		m.ClearAppField()
		return nil
	case asmarketapp.FieldAppCategory:
		m.ClearAppCategory()
		return nil
	case asmarketapp.FieldAppProjectSource:
		m.ClearAppProjectSource()
		return nil
	case asmarketapp.FieldAppFoundsSource:
		m.ClearAppFoundsSource()
		return nil
	case asmarketapp.FieldInnerURL:
		m.ClearInnerURL()
		return nil
	case asmarketapp.FieldOutURL:
		m.ClearOutURL()
		return nil
	case asmarketapp.FieldOutIPURL:
		m.ClearOutIPURL()
		return nil
	case asmarketapp.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketapp.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketapp.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketapp.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketapp.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppMutation) ResetField(name string) error {
	switch name {
	case asmarketapp.FieldAppName:
		m.ResetAppName()
		return nil
	case asmarketapp.FieldIcon:
		m.ResetIcon()
		return nil
	case asmarketapp.FieldVersion:
		m.ResetVersion()
		return nil
	case asmarketapp.FieldContact:
		m.ResetContact()
		return nil
	case asmarketapp.FieldContactName:
		m.ResetContactName()
		return nil
	case asmarketapp.FieldDescription:
		m.ResetDescription()
		return nil
	case asmarketapp.FieldFile:
		m.ResetFile()
		return nil
	case asmarketapp.FieldSaleStatus:
		m.ResetSaleStatus()
		return nil
	case asmarketapp.FieldTenantID:
		m.ResetTenantID()
		return nil
	case asmarketapp.FieldPlatform:
		m.ResetPlatform()
		return nil
	case asmarketapp.FieldTargetUser:
		m.ResetTargetUser()
		return nil
	case asmarketapp.FieldDeployStatus:
		m.ResetDeployStatus()
		return nil
	case asmarketapp.FieldDeployAddress:
		m.ResetDeployAddress()
		return nil
	case asmarketapp.FieldDeployType:
		m.ResetDeployType()
		return nil
	case asmarketapp.FieldPublishTime:
		m.ResetPublishTime()
		return nil
	case asmarketapp.FieldAppType:
		m.ResetAppType()
		return nil
	case asmarketapp.FieldApplyTime:
		m.ResetApplyTime()
		return nil
	case asmarketapp.FieldAppAddress:
		m.ResetAppAddress()
		return nil
	case asmarketapp.FieldAppMail:
		m.ResetAppMail()
		return nil
	case asmarketapp.FieldAppPhoto:
		m.ResetAppPhoto()
		return nil
	case asmarketapp.FieldAppField:
		m.ResetAppField()
		return nil
	case asmarketapp.FieldAppCategory:
		m.ResetAppCategory()
		return nil
	case asmarketapp.FieldAppProjectSource:
		m.ResetAppProjectSource()
		return nil
	case asmarketapp.FieldAppStar:
		m.ResetAppStar()
		return nil
	case asmarketapp.FieldAppFoundsSource:
		m.ResetAppFoundsSource()
		return nil
	case asmarketapp.FieldInnerURL:
		m.ResetInnerURL()
		return nil
	case asmarketapp.FieldOutURL:
		m.ResetOutURL()
		return nil
	case asmarketapp.FieldReformStatus:
		m.ResetReformStatus()
		return nil
	case asmarketapp.FieldOutIPURL:
		m.ResetOutIPURL()
		return nil
	case asmarketapp.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketapp.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketapp.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketapp.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketapp.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketapp.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.appMenus != nil {
		edges = append(edges, asmarketapp.EdgeAppMenus)
	}
	if m.appRoles != nil {
		edges = append(edges, asmarketapp.EdgeAppRoles)
	}
	if m.useds != nil {
		edges = append(edges, asmarketapp.EdgeUseds)
	}
	if m.appAlerts != nil {
		edges = append(edges, asmarketapp.EdgeAppAlerts)
	}
	if m.appRedeploys != nil {
		edges = append(edges, asmarketapp.EdgeAppRedeploys)
	}
	if m.appKeys != nil {
		edges = append(edges, asmarketapp.EdgeAppKeys)
	}
	if m.appPurchases != nil {
		edges = append(edges, asmarketapp.EdgeAppPurchases)
	}
	if m.appComponents != nil {
		edges = append(edges, asmarketapp.EdgeAppComponents)
	}
	if m.appGroupDistribs != nil {
		edges = append(edges, asmarketapp.EdgeAppGroupDistribs)
	}
	if m.appGroupDistribConfigs != nil {
		edges = append(edges, asmarketapp.EdgeAppGroupDistribConfigs)
	}
	if m.appGroupDistribsRelation != nil {
		edges = append(edges, asmarketapp.EdgeAppGroupDistribsRelation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketapp.EdgeAppMenus:
		ids := make([]ent.Value, 0, len(m.appMenus))
		for id := range m.appMenus {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppRoles:
		ids := make([]ent.Value, 0, len(m.appRoles))
		for id := range m.appRoles {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeUseds:
		ids := make([]ent.Value, 0, len(m.useds))
		for id := range m.useds {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppAlerts:
		ids := make([]ent.Value, 0, len(m.appAlerts))
		for id := range m.appAlerts {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppRedeploys:
		ids := make([]ent.Value, 0, len(m.appRedeploys))
		for id := range m.appRedeploys {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppKeys:
		ids := make([]ent.Value, 0, len(m.appKeys))
		for id := range m.appKeys {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppPurchases:
		ids := make([]ent.Value, 0, len(m.appPurchases))
		for id := range m.appPurchases {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppComponents:
		ids := make([]ent.Value, 0, len(m.appComponents))
		for id := range m.appComponents {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppGroupDistribs:
		ids := make([]ent.Value, 0, len(m.appGroupDistribs))
		for id := range m.appGroupDistribs {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppGroupDistribConfigs:
		ids := make([]ent.Value, 0, len(m.appGroupDistribConfigs))
		for id := range m.appGroupDistribConfigs {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppGroupDistribsRelation:
		ids := make([]ent.Value, 0, len(m.appGroupDistribsRelation))
		for id := range m.appGroupDistribsRelation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedappMenus != nil {
		edges = append(edges, asmarketapp.EdgeAppMenus)
	}
	if m.removedappRoles != nil {
		edges = append(edges, asmarketapp.EdgeAppRoles)
	}
	if m.removeduseds != nil {
		edges = append(edges, asmarketapp.EdgeUseds)
	}
	if m.removedappAlerts != nil {
		edges = append(edges, asmarketapp.EdgeAppAlerts)
	}
	if m.removedappRedeploys != nil {
		edges = append(edges, asmarketapp.EdgeAppRedeploys)
	}
	if m.removedappKeys != nil {
		edges = append(edges, asmarketapp.EdgeAppKeys)
	}
	if m.removedappPurchases != nil {
		edges = append(edges, asmarketapp.EdgeAppPurchases)
	}
	if m.removedappComponents != nil {
		edges = append(edges, asmarketapp.EdgeAppComponents)
	}
	if m.removedappGroupDistribs != nil {
		edges = append(edges, asmarketapp.EdgeAppGroupDistribs)
	}
	if m.removedappGroupDistribConfigs != nil {
		edges = append(edges, asmarketapp.EdgeAppGroupDistribConfigs)
	}
	if m.removedappGroupDistribsRelation != nil {
		edges = append(edges, asmarketapp.EdgeAppGroupDistribsRelation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asmarketapp.EdgeAppMenus:
		ids := make([]ent.Value, 0, len(m.removedappMenus))
		for id := range m.removedappMenus {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppRoles:
		ids := make([]ent.Value, 0, len(m.removedappRoles))
		for id := range m.removedappRoles {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeUseds:
		ids := make([]ent.Value, 0, len(m.removeduseds))
		for id := range m.removeduseds {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppAlerts:
		ids := make([]ent.Value, 0, len(m.removedappAlerts))
		for id := range m.removedappAlerts {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppRedeploys:
		ids := make([]ent.Value, 0, len(m.removedappRedeploys))
		for id := range m.removedappRedeploys {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppKeys:
		ids := make([]ent.Value, 0, len(m.removedappKeys))
		for id := range m.removedappKeys {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppPurchases:
		ids := make([]ent.Value, 0, len(m.removedappPurchases))
		for id := range m.removedappPurchases {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppComponents:
		ids := make([]ent.Value, 0, len(m.removedappComponents))
		for id := range m.removedappComponents {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppGroupDistribs:
		ids := make([]ent.Value, 0, len(m.removedappGroupDistribs))
		for id := range m.removedappGroupDistribs {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppGroupDistribConfigs:
		ids := make([]ent.Value, 0, len(m.removedappGroupDistribConfigs))
		for id := range m.removedappGroupDistribConfigs {
			ids = append(ids, id)
		}
		return ids
	case asmarketapp.EdgeAppGroupDistribsRelation:
		ids := make([]ent.Value, 0, len(m.removedappGroupDistribsRelation))
		for id := range m.removedappGroupDistribsRelation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedappMenus {
		edges = append(edges, asmarketapp.EdgeAppMenus)
	}
	if m.clearedappRoles {
		edges = append(edges, asmarketapp.EdgeAppRoles)
	}
	if m.cleareduseds {
		edges = append(edges, asmarketapp.EdgeUseds)
	}
	if m.clearedappAlerts {
		edges = append(edges, asmarketapp.EdgeAppAlerts)
	}
	if m.clearedappRedeploys {
		edges = append(edges, asmarketapp.EdgeAppRedeploys)
	}
	if m.clearedappKeys {
		edges = append(edges, asmarketapp.EdgeAppKeys)
	}
	if m.clearedappPurchases {
		edges = append(edges, asmarketapp.EdgeAppPurchases)
	}
	if m.clearedappComponents {
		edges = append(edges, asmarketapp.EdgeAppComponents)
	}
	if m.clearedappGroupDistribs {
		edges = append(edges, asmarketapp.EdgeAppGroupDistribs)
	}
	if m.clearedappGroupDistribConfigs {
		edges = append(edges, asmarketapp.EdgeAppGroupDistribConfigs)
	}
	if m.clearedappGroupDistribsRelation {
		edges = append(edges, asmarketapp.EdgeAppGroupDistribsRelation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketapp.EdgeAppMenus:
		return m.clearedappMenus
	case asmarketapp.EdgeAppRoles:
		return m.clearedappRoles
	case asmarketapp.EdgeUseds:
		return m.cleareduseds
	case asmarketapp.EdgeAppAlerts:
		return m.clearedappAlerts
	case asmarketapp.EdgeAppRedeploys:
		return m.clearedappRedeploys
	case asmarketapp.EdgeAppKeys:
		return m.clearedappKeys
	case asmarketapp.EdgeAppPurchases:
		return m.clearedappPurchases
	case asmarketapp.EdgeAppComponents:
		return m.clearedappComponents
	case asmarketapp.EdgeAppGroupDistribs:
		return m.clearedappGroupDistribs
	case asmarketapp.EdgeAppGroupDistribConfigs:
		return m.clearedappGroupDistribConfigs
	case asmarketapp.EdgeAppGroupDistribsRelation:
		return m.clearedappGroupDistribsRelation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AsMarketApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppMutation) ResetEdge(name string) error {
	switch name {
	case asmarketapp.EdgeAppMenus:
		m.ResetAppMenus()
		return nil
	case asmarketapp.EdgeAppRoles:
		m.ResetAppRoles()
		return nil
	case asmarketapp.EdgeUseds:
		m.ResetUseds()
		return nil
	case asmarketapp.EdgeAppAlerts:
		m.ResetAppAlerts()
		return nil
	case asmarketapp.EdgeAppRedeploys:
		m.ResetAppRedeploys()
		return nil
	case asmarketapp.EdgeAppKeys:
		m.ResetAppKeys()
		return nil
	case asmarketapp.EdgeAppPurchases:
		m.ResetAppPurchases()
		return nil
	case asmarketapp.EdgeAppComponents:
		m.ResetAppComponents()
		return nil
	case asmarketapp.EdgeAppGroupDistribs:
		m.ResetAppGroupDistribs()
		return nil
	case asmarketapp.EdgeAppGroupDistribConfigs:
		m.ResetAppGroupDistribConfigs()
		return nil
	case asmarketapp.EdgeAppGroupDistribsRelation:
		m.ResetAppGroupDistribsRelation()
		return nil
	}
	return fmt.Errorf("unknown AsMarketApp edge %s", name)
}

// AsMarketAppAlertMutation represents an operation that mutates the AsMarketAppAlert nodes in the graph.
type AsMarketAppAlertMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	alert_title              *string
	alert_content            *string
	alert_business           *string
	alert_emergency_level    *int64
	addalert_emergency_level *int64
	alert_release_time       *date.DateTime
	alert_role_ids           *string
	alert_job_ids            *string
	alert_status             *int64
	addalert_status          *int64
	is_deleted               *int64
	addis_deleted            *int64
	status                   *int64
	addstatus                *int64
	create_user              *int64
	addcreate_user           *int64
	update_user              *int64
	addupdate_user           *int64
	create_time              *date.DateTime
	update_time              *date.DateTime
	clearedFields            map[string]struct{}
	appx                     *int64
	clearedappx              bool
	done                     bool
	oldValue                 func(context.Context) (*AsMarketAppAlert, error)
	predicates               []predicate.AsMarketAppAlert
}

var _ ent.Mutation = (*AsMarketAppAlertMutation)(nil)

// asmarketappalertOption allows management of the mutation configuration using functional options.
type asmarketappalertOption func(*AsMarketAppAlertMutation)

// newAsMarketAppAlertMutation creates new mutation for the AsMarketAppAlert entity.
func newAsMarketAppAlertMutation(c config, op Op, opts ...asmarketappalertOption) *AsMarketAppAlertMutation {
	m := &AsMarketAppAlertMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketAppAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppAlertID sets the ID field of the mutation.
func withAsMarketAppAlertID(id int64) asmarketappalertOption {
	return func(m *AsMarketAppAlertMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketAppAlert
		)
		m.oldValue = func(ctx context.Context) (*AsMarketAppAlert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketAppAlert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketAppAlert sets the old AsMarketAppAlert of the mutation.
func withAsMarketAppAlert(node *AsMarketAppAlert) asmarketappalertOption {
	return func(m *AsMarketAppAlertMutation) {
		m.oldValue = func(context.Context) (*AsMarketAppAlert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppAlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppAlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketAppAlert entities.
func (m *AsMarketAppAlertMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppAlertMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppAlertMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketAppAlert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlertTitle sets the "alert_title" field.
func (m *AsMarketAppAlertMutation) SetAlertTitle(s string) {
	m.alert_title = &s
}

// AlertTitle returns the value of the "alert_title" field in the mutation.
func (m *AsMarketAppAlertMutation) AlertTitle() (r string, exists bool) {
	v := m.alert_title
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertTitle returns the old "alert_title" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldAlertTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertTitle: %w", err)
	}
	return oldValue.AlertTitle, nil
}

// ClearAlertTitle clears the value of the "alert_title" field.
func (m *AsMarketAppAlertMutation) ClearAlertTitle() {
	m.alert_title = nil
	m.clearedFields[asmarketappalert.FieldAlertTitle] = struct{}{}
}

// AlertTitleCleared returns if the "alert_title" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) AlertTitleCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldAlertTitle]
	return ok
}

// ResetAlertTitle resets all changes to the "alert_title" field.
func (m *AsMarketAppAlertMutation) ResetAlertTitle() {
	m.alert_title = nil
	delete(m.clearedFields, asmarketappalert.FieldAlertTitle)
}

// SetAlertContent sets the "alert_content" field.
func (m *AsMarketAppAlertMutation) SetAlertContent(s string) {
	m.alert_content = &s
}

// AlertContent returns the value of the "alert_content" field in the mutation.
func (m *AsMarketAppAlertMutation) AlertContent() (r string, exists bool) {
	v := m.alert_content
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertContent returns the old "alert_content" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldAlertContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertContent: %w", err)
	}
	return oldValue.AlertContent, nil
}

// ClearAlertContent clears the value of the "alert_content" field.
func (m *AsMarketAppAlertMutation) ClearAlertContent() {
	m.alert_content = nil
	m.clearedFields[asmarketappalert.FieldAlertContent] = struct{}{}
}

// AlertContentCleared returns if the "alert_content" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) AlertContentCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldAlertContent]
	return ok
}

// ResetAlertContent resets all changes to the "alert_content" field.
func (m *AsMarketAppAlertMutation) ResetAlertContent() {
	m.alert_content = nil
	delete(m.clearedFields, asmarketappalert.FieldAlertContent)
}

// SetAlertBusiness sets the "alert_business" field.
func (m *AsMarketAppAlertMutation) SetAlertBusiness(s string) {
	m.alert_business = &s
}

// AlertBusiness returns the value of the "alert_business" field in the mutation.
func (m *AsMarketAppAlertMutation) AlertBusiness() (r string, exists bool) {
	v := m.alert_business
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertBusiness returns the old "alert_business" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldAlertBusiness(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertBusiness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertBusiness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertBusiness: %w", err)
	}
	return oldValue.AlertBusiness, nil
}

// ClearAlertBusiness clears the value of the "alert_business" field.
func (m *AsMarketAppAlertMutation) ClearAlertBusiness() {
	m.alert_business = nil
	m.clearedFields[asmarketappalert.FieldAlertBusiness] = struct{}{}
}

// AlertBusinessCleared returns if the "alert_business" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) AlertBusinessCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldAlertBusiness]
	return ok
}

// ResetAlertBusiness resets all changes to the "alert_business" field.
func (m *AsMarketAppAlertMutation) ResetAlertBusiness() {
	m.alert_business = nil
	delete(m.clearedFields, asmarketappalert.FieldAlertBusiness)
}

// SetAlertEmergencyLevel sets the "alert_emergency_level" field.
func (m *AsMarketAppAlertMutation) SetAlertEmergencyLevel(i int64) {
	m.alert_emergency_level = &i
	m.addalert_emergency_level = nil
}

// AlertEmergencyLevel returns the value of the "alert_emergency_level" field in the mutation.
func (m *AsMarketAppAlertMutation) AlertEmergencyLevel() (r int64, exists bool) {
	v := m.alert_emergency_level
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertEmergencyLevel returns the old "alert_emergency_level" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldAlertEmergencyLevel(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertEmergencyLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertEmergencyLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertEmergencyLevel: %w", err)
	}
	return oldValue.AlertEmergencyLevel, nil
}

// AddAlertEmergencyLevel adds i to the "alert_emergency_level" field.
func (m *AsMarketAppAlertMutation) AddAlertEmergencyLevel(i int64) {
	if m.addalert_emergency_level != nil {
		*m.addalert_emergency_level += i
	} else {
		m.addalert_emergency_level = &i
	}
}

// AddedAlertEmergencyLevel returns the value that was added to the "alert_emergency_level" field in this mutation.
func (m *AsMarketAppAlertMutation) AddedAlertEmergencyLevel() (r int64, exists bool) {
	v := m.addalert_emergency_level
	if v == nil {
		return
	}
	return *v, true
}

// ClearAlertEmergencyLevel clears the value of the "alert_emergency_level" field.
func (m *AsMarketAppAlertMutation) ClearAlertEmergencyLevel() {
	m.alert_emergency_level = nil
	m.addalert_emergency_level = nil
	m.clearedFields[asmarketappalert.FieldAlertEmergencyLevel] = struct{}{}
}

// AlertEmergencyLevelCleared returns if the "alert_emergency_level" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) AlertEmergencyLevelCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldAlertEmergencyLevel]
	return ok
}

// ResetAlertEmergencyLevel resets all changes to the "alert_emergency_level" field.
func (m *AsMarketAppAlertMutation) ResetAlertEmergencyLevel() {
	m.alert_emergency_level = nil
	m.addalert_emergency_level = nil
	delete(m.clearedFields, asmarketappalert.FieldAlertEmergencyLevel)
}

// SetAlertReleaseAppID sets the "alert_release_app_id" field.
func (m *AsMarketAppAlertMutation) SetAlertReleaseAppID(i int64) {
	m.appx = &i
}

// AlertReleaseAppID returns the value of the "alert_release_app_id" field in the mutation.
func (m *AsMarketAppAlertMutation) AlertReleaseAppID() (r int64, exists bool) {
	v := m.appx
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertReleaseAppID returns the old "alert_release_app_id" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldAlertReleaseAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertReleaseAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertReleaseAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertReleaseAppID: %w", err)
	}
	return oldValue.AlertReleaseAppID, nil
}

// ClearAlertReleaseAppID clears the value of the "alert_release_app_id" field.
func (m *AsMarketAppAlertMutation) ClearAlertReleaseAppID() {
	m.appx = nil
	m.clearedFields[asmarketappalert.FieldAlertReleaseAppID] = struct{}{}
}

// AlertReleaseAppIDCleared returns if the "alert_release_app_id" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) AlertReleaseAppIDCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldAlertReleaseAppID]
	return ok
}

// ResetAlertReleaseAppID resets all changes to the "alert_release_app_id" field.
func (m *AsMarketAppAlertMutation) ResetAlertReleaseAppID() {
	m.appx = nil
	delete(m.clearedFields, asmarketappalert.FieldAlertReleaseAppID)
}

// SetAlertReleaseTime sets the "alert_release_time" field.
func (m *AsMarketAppAlertMutation) SetAlertReleaseTime(dt date.DateTime) {
	m.alert_release_time = &dt
}

// AlertReleaseTime returns the value of the "alert_release_time" field in the mutation.
func (m *AsMarketAppAlertMutation) AlertReleaseTime() (r date.DateTime, exists bool) {
	v := m.alert_release_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertReleaseTime returns the old "alert_release_time" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldAlertReleaseTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertReleaseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertReleaseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertReleaseTime: %w", err)
	}
	return oldValue.AlertReleaseTime, nil
}

// ClearAlertReleaseTime clears the value of the "alert_release_time" field.
func (m *AsMarketAppAlertMutation) ClearAlertReleaseTime() {
	m.alert_release_time = nil
	m.clearedFields[asmarketappalert.FieldAlertReleaseTime] = struct{}{}
}

// AlertReleaseTimeCleared returns if the "alert_release_time" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) AlertReleaseTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldAlertReleaseTime]
	return ok
}

// ResetAlertReleaseTime resets all changes to the "alert_release_time" field.
func (m *AsMarketAppAlertMutation) ResetAlertReleaseTime() {
	m.alert_release_time = nil
	delete(m.clearedFields, asmarketappalert.FieldAlertReleaseTime)
}

// SetAlertRoleIds sets the "alert_role_ids" field.
func (m *AsMarketAppAlertMutation) SetAlertRoleIds(s string) {
	m.alert_role_ids = &s
}

// AlertRoleIds returns the value of the "alert_role_ids" field in the mutation.
func (m *AsMarketAppAlertMutation) AlertRoleIds() (r string, exists bool) {
	v := m.alert_role_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertRoleIds returns the old "alert_role_ids" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldAlertRoleIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertRoleIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertRoleIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertRoleIds: %w", err)
	}
	return oldValue.AlertRoleIds, nil
}

// ClearAlertRoleIds clears the value of the "alert_role_ids" field.
func (m *AsMarketAppAlertMutation) ClearAlertRoleIds() {
	m.alert_role_ids = nil
	m.clearedFields[asmarketappalert.FieldAlertRoleIds] = struct{}{}
}

// AlertRoleIdsCleared returns if the "alert_role_ids" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) AlertRoleIdsCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldAlertRoleIds]
	return ok
}

// ResetAlertRoleIds resets all changes to the "alert_role_ids" field.
func (m *AsMarketAppAlertMutation) ResetAlertRoleIds() {
	m.alert_role_ids = nil
	delete(m.clearedFields, asmarketappalert.FieldAlertRoleIds)
}

// SetAlertJobIds sets the "alert_job_ids" field.
func (m *AsMarketAppAlertMutation) SetAlertJobIds(s string) {
	m.alert_job_ids = &s
}

// AlertJobIds returns the value of the "alert_job_ids" field in the mutation.
func (m *AsMarketAppAlertMutation) AlertJobIds() (r string, exists bool) {
	v := m.alert_job_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertJobIds returns the old "alert_job_ids" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldAlertJobIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertJobIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertJobIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertJobIds: %w", err)
	}
	return oldValue.AlertJobIds, nil
}

// ClearAlertJobIds clears the value of the "alert_job_ids" field.
func (m *AsMarketAppAlertMutation) ClearAlertJobIds() {
	m.alert_job_ids = nil
	m.clearedFields[asmarketappalert.FieldAlertJobIds] = struct{}{}
}

// AlertJobIdsCleared returns if the "alert_job_ids" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) AlertJobIdsCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldAlertJobIds]
	return ok
}

// ResetAlertJobIds resets all changes to the "alert_job_ids" field.
func (m *AsMarketAppAlertMutation) ResetAlertJobIds() {
	m.alert_job_ids = nil
	delete(m.clearedFields, asmarketappalert.FieldAlertJobIds)
}

// SetAlertStatus sets the "alert_status" field.
func (m *AsMarketAppAlertMutation) SetAlertStatus(i int64) {
	m.alert_status = &i
	m.addalert_status = nil
}

// AlertStatus returns the value of the "alert_status" field in the mutation.
func (m *AsMarketAppAlertMutation) AlertStatus() (r int64, exists bool) {
	v := m.alert_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertStatus returns the old "alert_status" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldAlertStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertStatus: %w", err)
	}
	return oldValue.AlertStatus, nil
}

// AddAlertStatus adds i to the "alert_status" field.
func (m *AsMarketAppAlertMutation) AddAlertStatus(i int64) {
	if m.addalert_status != nil {
		*m.addalert_status += i
	} else {
		m.addalert_status = &i
	}
}

// AddedAlertStatus returns the value that was added to the "alert_status" field in this mutation.
func (m *AsMarketAppAlertMutation) AddedAlertStatus() (r int64, exists bool) {
	v := m.addalert_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearAlertStatus clears the value of the "alert_status" field.
func (m *AsMarketAppAlertMutation) ClearAlertStatus() {
	m.alert_status = nil
	m.addalert_status = nil
	m.clearedFields[asmarketappalert.FieldAlertStatus] = struct{}{}
}

// AlertStatusCleared returns if the "alert_status" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) AlertStatusCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldAlertStatus]
	return ok
}

// ResetAlertStatus resets all changes to the "alert_status" field.
func (m *AsMarketAppAlertMutation) ResetAlertStatus() {
	m.alert_status = nil
	m.addalert_status = nil
	delete(m.clearedFields, asmarketappalert.FieldAlertStatus)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppAlertMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppAlertMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppAlertMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppAlertMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppAlertMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppAlertMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppAlertMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppAlertMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppAlertMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppAlertMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketappalert.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppAlertMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketappalert.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppAlertMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppAlertMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppAlertMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppAlertMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppAlertMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketappalert.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppAlertMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketappalert.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppAlertMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppAlertMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppAlertMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppAlertMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppAlertMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketappalert.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppAlertMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketappalert.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppAlertMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppAlertMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppAlertMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketappalert.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppAlertMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketappalert.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppAlertMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppAlertMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketAppAlert entity.
// If the AsMarketAppAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppAlertMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppAlertMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketappalert.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppAlertMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappalert.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppAlertMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketappalert.FieldUpdateTime)
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsMarketAppAlertMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsMarketAppAlertMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsMarketAppAlertMutation) AppxCleared() bool {
	return m.AlertReleaseAppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsMarketAppAlertMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppAlertMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsMarketAppAlertMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// Where appends a list predicates to the AsMarketAppAlertMutation builder.
func (m *AsMarketAppAlertMutation) Where(ps ...predicate.AsMarketAppAlert) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppAlertMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketAppAlert).
func (m *AsMarketAppAlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppAlertMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.alert_title != nil {
		fields = append(fields, asmarketappalert.FieldAlertTitle)
	}
	if m.alert_content != nil {
		fields = append(fields, asmarketappalert.FieldAlertContent)
	}
	if m.alert_business != nil {
		fields = append(fields, asmarketappalert.FieldAlertBusiness)
	}
	if m.alert_emergency_level != nil {
		fields = append(fields, asmarketappalert.FieldAlertEmergencyLevel)
	}
	if m.appx != nil {
		fields = append(fields, asmarketappalert.FieldAlertReleaseAppID)
	}
	if m.alert_release_time != nil {
		fields = append(fields, asmarketappalert.FieldAlertReleaseTime)
	}
	if m.alert_role_ids != nil {
		fields = append(fields, asmarketappalert.FieldAlertRoleIds)
	}
	if m.alert_job_ids != nil {
		fields = append(fields, asmarketappalert.FieldAlertJobIds)
	}
	if m.alert_status != nil {
		fields = append(fields, asmarketappalert.FieldAlertStatus)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketappalert.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketappalert.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketappalert.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketappalert.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketappalert.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketappalert.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppAlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketappalert.FieldAlertTitle:
		return m.AlertTitle()
	case asmarketappalert.FieldAlertContent:
		return m.AlertContent()
	case asmarketappalert.FieldAlertBusiness:
		return m.AlertBusiness()
	case asmarketappalert.FieldAlertEmergencyLevel:
		return m.AlertEmergencyLevel()
	case asmarketappalert.FieldAlertReleaseAppID:
		return m.AlertReleaseAppID()
	case asmarketappalert.FieldAlertReleaseTime:
		return m.AlertReleaseTime()
	case asmarketappalert.FieldAlertRoleIds:
		return m.AlertRoleIds()
	case asmarketappalert.FieldAlertJobIds:
		return m.AlertJobIds()
	case asmarketappalert.FieldAlertStatus:
		return m.AlertStatus()
	case asmarketappalert.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketappalert.FieldStatus:
		return m.Status()
	case asmarketappalert.FieldCreateUser:
		return m.CreateUser()
	case asmarketappalert.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketappalert.FieldCreateTime:
		return m.CreateTime()
	case asmarketappalert.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppAlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketappalert.FieldAlertTitle:
		return m.OldAlertTitle(ctx)
	case asmarketappalert.FieldAlertContent:
		return m.OldAlertContent(ctx)
	case asmarketappalert.FieldAlertBusiness:
		return m.OldAlertBusiness(ctx)
	case asmarketappalert.FieldAlertEmergencyLevel:
		return m.OldAlertEmergencyLevel(ctx)
	case asmarketappalert.FieldAlertReleaseAppID:
		return m.OldAlertReleaseAppID(ctx)
	case asmarketappalert.FieldAlertReleaseTime:
		return m.OldAlertReleaseTime(ctx)
	case asmarketappalert.FieldAlertRoleIds:
		return m.OldAlertRoleIds(ctx)
	case asmarketappalert.FieldAlertJobIds:
		return m.OldAlertJobIds(ctx)
	case asmarketappalert.FieldAlertStatus:
		return m.OldAlertStatus(ctx)
	case asmarketappalert.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketappalert.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketappalert.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketappalert.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketappalert.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketappalert.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketAppAlert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppAlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketappalert.FieldAlertTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertTitle(v)
		return nil
	case asmarketappalert.FieldAlertContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertContent(v)
		return nil
	case asmarketappalert.FieldAlertBusiness:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertBusiness(v)
		return nil
	case asmarketappalert.FieldAlertEmergencyLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertEmergencyLevel(v)
		return nil
	case asmarketappalert.FieldAlertReleaseAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertReleaseAppID(v)
		return nil
	case asmarketappalert.FieldAlertReleaseTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertReleaseTime(v)
		return nil
	case asmarketappalert.FieldAlertRoleIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertRoleIds(v)
		return nil
	case asmarketappalert.FieldAlertJobIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertJobIds(v)
		return nil
	case asmarketappalert.FieldAlertStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertStatus(v)
		return nil
	case asmarketappalert.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketappalert.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketappalert.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketappalert.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketappalert.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketappalert.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppAlert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppAlertMutation) AddedFields() []string {
	var fields []string
	if m.addalert_emergency_level != nil {
		fields = append(fields, asmarketappalert.FieldAlertEmergencyLevel)
	}
	if m.addalert_status != nil {
		fields = append(fields, asmarketappalert.FieldAlertStatus)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketappalert.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketappalert.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketappalert.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketappalert.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppAlertMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketappalert.FieldAlertEmergencyLevel:
		return m.AddedAlertEmergencyLevel()
	case asmarketappalert.FieldAlertStatus:
		return m.AddedAlertStatus()
	case asmarketappalert.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketappalert.FieldStatus:
		return m.AddedStatus()
	case asmarketappalert.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketappalert.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppAlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketappalert.FieldAlertEmergencyLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlertEmergencyLevel(v)
		return nil
	case asmarketappalert.FieldAlertStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlertStatus(v)
		return nil
	case asmarketappalert.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketappalert.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketappalert.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketappalert.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppAlert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppAlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketappalert.FieldAlertTitle) {
		fields = append(fields, asmarketappalert.FieldAlertTitle)
	}
	if m.FieldCleared(asmarketappalert.FieldAlertContent) {
		fields = append(fields, asmarketappalert.FieldAlertContent)
	}
	if m.FieldCleared(asmarketappalert.FieldAlertBusiness) {
		fields = append(fields, asmarketappalert.FieldAlertBusiness)
	}
	if m.FieldCleared(asmarketappalert.FieldAlertEmergencyLevel) {
		fields = append(fields, asmarketappalert.FieldAlertEmergencyLevel)
	}
	if m.FieldCleared(asmarketappalert.FieldAlertReleaseAppID) {
		fields = append(fields, asmarketappalert.FieldAlertReleaseAppID)
	}
	if m.FieldCleared(asmarketappalert.FieldAlertReleaseTime) {
		fields = append(fields, asmarketappalert.FieldAlertReleaseTime)
	}
	if m.FieldCleared(asmarketappalert.FieldAlertRoleIds) {
		fields = append(fields, asmarketappalert.FieldAlertRoleIds)
	}
	if m.FieldCleared(asmarketappalert.FieldAlertJobIds) {
		fields = append(fields, asmarketappalert.FieldAlertJobIds)
	}
	if m.FieldCleared(asmarketappalert.FieldAlertStatus) {
		fields = append(fields, asmarketappalert.FieldAlertStatus)
	}
	if m.FieldCleared(asmarketappalert.FieldStatus) {
		fields = append(fields, asmarketappalert.FieldStatus)
	}
	if m.FieldCleared(asmarketappalert.FieldCreateUser) {
		fields = append(fields, asmarketappalert.FieldCreateUser)
	}
	if m.FieldCleared(asmarketappalert.FieldUpdateUser) {
		fields = append(fields, asmarketappalert.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketappalert.FieldCreateTime) {
		fields = append(fields, asmarketappalert.FieldCreateTime)
	}
	if m.FieldCleared(asmarketappalert.FieldUpdateTime) {
		fields = append(fields, asmarketappalert.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppAlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppAlertMutation) ClearField(name string) error {
	switch name {
	case asmarketappalert.FieldAlertTitle:
		m.ClearAlertTitle()
		return nil
	case asmarketappalert.FieldAlertContent:
		m.ClearAlertContent()
		return nil
	case asmarketappalert.FieldAlertBusiness:
		m.ClearAlertBusiness()
		return nil
	case asmarketappalert.FieldAlertEmergencyLevel:
		m.ClearAlertEmergencyLevel()
		return nil
	case asmarketappalert.FieldAlertReleaseAppID:
		m.ClearAlertReleaseAppID()
		return nil
	case asmarketappalert.FieldAlertReleaseTime:
		m.ClearAlertReleaseTime()
		return nil
	case asmarketappalert.FieldAlertRoleIds:
		m.ClearAlertRoleIds()
		return nil
	case asmarketappalert.FieldAlertJobIds:
		m.ClearAlertJobIds()
		return nil
	case asmarketappalert.FieldAlertStatus:
		m.ClearAlertStatus()
		return nil
	case asmarketappalert.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketappalert.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketappalert.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketappalert.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketappalert.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppAlert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppAlertMutation) ResetField(name string) error {
	switch name {
	case asmarketappalert.FieldAlertTitle:
		m.ResetAlertTitle()
		return nil
	case asmarketappalert.FieldAlertContent:
		m.ResetAlertContent()
		return nil
	case asmarketappalert.FieldAlertBusiness:
		m.ResetAlertBusiness()
		return nil
	case asmarketappalert.FieldAlertEmergencyLevel:
		m.ResetAlertEmergencyLevel()
		return nil
	case asmarketappalert.FieldAlertReleaseAppID:
		m.ResetAlertReleaseAppID()
		return nil
	case asmarketappalert.FieldAlertReleaseTime:
		m.ResetAlertReleaseTime()
		return nil
	case asmarketappalert.FieldAlertRoleIds:
		m.ResetAlertRoleIds()
		return nil
	case asmarketappalert.FieldAlertJobIds:
		m.ResetAlertJobIds()
		return nil
	case asmarketappalert.FieldAlertStatus:
		m.ResetAlertStatus()
		return nil
	case asmarketappalert.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketappalert.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketappalert.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketappalert.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketappalert.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketappalert.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppAlert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppAlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.appx != nil {
		edges = append(edges, asmarketappalert.EdgeAppx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppAlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketappalert.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppAlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppAlertMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppAlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedappx {
		edges = append(edges, asmarketappalert.EdgeAppx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppAlertMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketappalert.EdgeAppx:
		return m.clearedappx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppAlertMutation) ClearEdge(name string) error {
	switch name {
	case asmarketappalert.EdgeAppx:
		m.ClearAppx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppAlert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppAlertMutation) ResetEdge(name string) error {
	switch name {
	case asmarketappalert.EdgeAppx:
		m.ResetAppx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppAlert edge %s", name)
}

// AsMarketAppComponentMutation represents an operation that mutates the AsMarketAppComponent nodes in the graph.
type AsMarketAppComponentMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	code           *string
	name           *string
	url            *string
	_type          *int64
	add_type       *int64
	preview_pic    *string
	layout_type    *string
	layout_config  *string
	tenant_code    *string
	source         *string
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	appx           *int64
	clearedappx    bool
	done           bool
	oldValue       func(context.Context) (*AsMarketAppComponent, error)
	predicates     []predicate.AsMarketAppComponent
}

var _ ent.Mutation = (*AsMarketAppComponentMutation)(nil)

// asmarketappcomponentOption allows management of the mutation configuration using functional options.
type asmarketappcomponentOption func(*AsMarketAppComponentMutation)

// newAsMarketAppComponentMutation creates new mutation for the AsMarketAppComponent entity.
func newAsMarketAppComponentMutation(c config, op Op, opts ...asmarketappcomponentOption) *AsMarketAppComponentMutation {
	m := &AsMarketAppComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketAppComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppComponentID sets the ID field of the mutation.
func withAsMarketAppComponentID(id int64) asmarketappcomponentOption {
	return func(m *AsMarketAppComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketAppComponent
		)
		m.oldValue = func(ctx context.Context) (*AsMarketAppComponent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketAppComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketAppComponent sets the old AsMarketAppComponent of the mutation.
func withAsMarketAppComponent(node *AsMarketAppComponent) asmarketappcomponentOption {
	return func(m *AsMarketAppComponentMutation) {
		m.oldValue = func(context.Context) (*AsMarketAppComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketAppComponent entities.
func (m *AsMarketAppComponentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppComponentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppComponentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketAppComponent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AsMarketAppComponentMutation) SetAppID(i int64) {
	m.appx = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsMarketAppComponentMutation) AppID() (r int64, exists bool) {
	v := m.appx
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AsMarketAppComponentMutation) ClearAppID() {
	m.appx = nil
	m.clearedFields[asmarketappcomponent.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsMarketAppComponentMutation) ResetAppID() {
	m.appx = nil
	delete(m.clearedFields, asmarketappcomponent.FieldAppID)
}

// SetCode sets the "code" field.
func (m *AsMarketAppComponentMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AsMarketAppComponentMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *AsMarketAppComponentMutation) ClearCode() {
	m.code = nil
	m.clearedFields[asmarketappcomponent.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) CodeCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *AsMarketAppComponentMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, asmarketappcomponent.FieldCode)
}

// SetName sets the "name" field.
func (m *AsMarketAppComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AsMarketAppComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AsMarketAppComponentMutation) ClearName() {
	m.name = nil
	m.clearedFields[asmarketappcomponent.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) NameCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AsMarketAppComponentMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, asmarketappcomponent.FieldName)
}

// SetURL sets the "url" field.
func (m *AsMarketAppComponentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *AsMarketAppComponentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *AsMarketAppComponentMutation) ClearURL() {
	m.url = nil
	m.clearedFields[asmarketappcomponent.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) URLCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *AsMarketAppComponentMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, asmarketappcomponent.FieldURL)
}

// SetType sets the "type" field.
func (m *AsMarketAppComponentMutation) SetType(i int64) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *AsMarketAppComponentMutation) GetType() (r int64, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *AsMarketAppComponentMutation) AddType(i int64) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *AsMarketAppComponentMutation) AddedType() (r int64, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *AsMarketAppComponentMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[asmarketappcomponent.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) TypeCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *AsMarketAppComponentMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, asmarketappcomponent.FieldType)
}

// SetPreviewPic sets the "preview_pic" field.
func (m *AsMarketAppComponentMutation) SetPreviewPic(s string) {
	m.preview_pic = &s
}

// PreviewPic returns the value of the "preview_pic" field in the mutation.
func (m *AsMarketAppComponentMutation) PreviewPic() (r string, exists bool) {
	v := m.preview_pic
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviewPic returns the old "preview_pic" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldPreviewPic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviewPic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviewPic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviewPic: %w", err)
	}
	return oldValue.PreviewPic, nil
}

// ClearPreviewPic clears the value of the "preview_pic" field.
func (m *AsMarketAppComponentMutation) ClearPreviewPic() {
	m.preview_pic = nil
	m.clearedFields[asmarketappcomponent.FieldPreviewPic] = struct{}{}
}

// PreviewPicCleared returns if the "preview_pic" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) PreviewPicCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldPreviewPic]
	return ok
}

// ResetPreviewPic resets all changes to the "preview_pic" field.
func (m *AsMarketAppComponentMutation) ResetPreviewPic() {
	m.preview_pic = nil
	delete(m.clearedFields, asmarketappcomponent.FieldPreviewPic)
}

// SetLayoutType sets the "layout_type" field.
func (m *AsMarketAppComponentMutation) SetLayoutType(s string) {
	m.layout_type = &s
}

// LayoutType returns the value of the "layout_type" field in the mutation.
func (m *AsMarketAppComponentMutation) LayoutType() (r string, exists bool) {
	v := m.layout_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLayoutType returns the old "layout_type" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldLayoutType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayoutType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayoutType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayoutType: %w", err)
	}
	return oldValue.LayoutType, nil
}

// ClearLayoutType clears the value of the "layout_type" field.
func (m *AsMarketAppComponentMutation) ClearLayoutType() {
	m.layout_type = nil
	m.clearedFields[asmarketappcomponent.FieldLayoutType] = struct{}{}
}

// LayoutTypeCleared returns if the "layout_type" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) LayoutTypeCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldLayoutType]
	return ok
}

// ResetLayoutType resets all changes to the "layout_type" field.
func (m *AsMarketAppComponentMutation) ResetLayoutType() {
	m.layout_type = nil
	delete(m.clearedFields, asmarketappcomponent.FieldLayoutType)
}

// SetLayoutConfig sets the "layout_config" field.
func (m *AsMarketAppComponentMutation) SetLayoutConfig(s string) {
	m.layout_config = &s
}

// LayoutConfig returns the value of the "layout_config" field in the mutation.
func (m *AsMarketAppComponentMutation) LayoutConfig() (r string, exists bool) {
	v := m.layout_config
	if v == nil {
		return
	}
	return *v, true
}

// OldLayoutConfig returns the old "layout_config" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldLayoutConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayoutConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayoutConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayoutConfig: %w", err)
	}
	return oldValue.LayoutConfig, nil
}

// ClearLayoutConfig clears the value of the "layout_config" field.
func (m *AsMarketAppComponentMutation) ClearLayoutConfig() {
	m.layout_config = nil
	m.clearedFields[asmarketappcomponent.FieldLayoutConfig] = struct{}{}
}

// LayoutConfigCleared returns if the "layout_config" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) LayoutConfigCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldLayoutConfig]
	return ok
}

// ResetLayoutConfig resets all changes to the "layout_config" field.
func (m *AsMarketAppComponentMutation) ResetLayoutConfig() {
	m.layout_config = nil
	delete(m.clearedFields, asmarketappcomponent.FieldLayoutConfig)
}

// SetTenantCode sets the "tenant_code" field.
func (m *AsMarketAppComponentMutation) SetTenantCode(s string) {
	m.tenant_code = &s
}

// TenantCode returns the value of the "tenant_code" field in the mutation.
func (m *AsMarketAppComponentMutation) TenantCode() (r string, exists bool) {
	v := m.tenant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantCode returns the old "tenant_code" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldTenantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantCode: %w", err)
	}
	return oldValue.TenantCode, nil
}

// ClearTenantCode clears the value of the "tenant_code" field.
func (m *AsMarketAppComponentMutation) ClearTenantCode() {
	m.tenant_code = nil
	m.clearedFields[asmarketappcomponent.FieldTenantCode] = struct{}{}
}

// TenantCodeCleared returns if the "tenant_code" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) TenantCodeCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldTenantCode]
	return ok
}

// ResetTenantCode resets all changes to the "tenant_code" field.
func (m *AsMarketAppComponentMutation) ResetTenantCode() {
	m.tenant_code = nil
	delete(m.clearedFields, asmarketappcomponent.FieldTenantCode)
}

// SetSource sets the "source" field.
func (m *AsMarketAppComponentMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *AsMarketAppComponentMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *AsMarketAppComponentMutation) ClearSource() {
	m.source = nil
	m.clearedFields[asmarketappcomponent.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) SourceCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *AsMarketAppComponentMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, asmarketappcomponent.FieldSource)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppComponentMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppComponentMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppComponentMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppComponentMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppComponentMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppComponentMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppComponentMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppComponentMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppComponentMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppComponentMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketappcomponent.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppComponentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketappcomponent.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppComponentMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppComponentMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppComponentMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppComponentMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppComponentMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketappcomponent.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppComponentMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketappcomponent.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppComponentMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppComponentMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppComponentMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppComponentMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppComponentMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketappcomponent.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppComponentMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketappcomponent.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppComponentMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppComponentMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppComponentMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketappcomponent.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppComponentMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketappcomponent.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppComponentMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppComponentMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketAppComponent entity.
// If the AsMarketAppComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppComponentMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketappcomponent.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppComponentMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponent.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppComponentMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketappcomponent.FieldUpdateTime)
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsMarketAppComponentMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsMarketAppComponentMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsMarketAppComponentMutation) AppxCleared() bool {
	return m.AppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsMarketAppComponentMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppComponentMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsMarketAppComponentMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// Where appends a list predicates to the AsMarketAppComponentMutation builder.
func (m *AsMarketAppComponentMutation) Where(ps ...predicate.AsMarketAppComponent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppComponentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketAppComponent).
func (m *AsMarketAppComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppComponentMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.appx != nil {
		fields = append(fields, asmarketappcomponent.FieldAppID)
	}
	if m.code != nil {
		fields = append(fields, asmarketappcomponent.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, asmarketappcomponent.FieldName)
	}
	if m.url != nil {
		fields = append(fields, asmarketappcomponent.FieldURL)
	}
	if m._type != nil {
		fields = append(fields, asmarketappcomponent.FieldType)
	}
	if m.preview_pic != nil {
		fields = append(fields, asmarketappcomponent.FieldPreviewPic)
	}
	if m.layout_type != nil {
		fields = append(fields, asmarketappcomponent.FieldLayoutType)
	}
	if m.layout_config != nil {
		fields = append(fields, asmarketappcomponent.FieldLayoutConfig)
	}
	if m.tenant_code != nil {
		fields = append(fields, asmarketappcomponent.FieldTenantCode)
	}
	if m.source != nil {
		fields = append(fields, asmarketappcomponent.FieldSource)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketappcomponent.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketappcomponent.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketappcomponent.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketappcomponent.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketappcomponent.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketappcomponent.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketappcomponent.FieldAppID:
		return m.AppID()
	case asmarketappcomponent.FieldCode:
		return m.Code()
	case asmarketappcomponent.FieldName:
		return m.Name()
	case asmarketappcomponent.FieldURL:
		return m.URL()
	case asmarketappcomponent.FieldType:
		return m.GetType()
	case asmarketappcomponent.FieldPreviewPic:
		return m.PreviewPic()
	case asmarketappcomponent.FieldLayoutType:
		return m.LayoutType()
	case asmarketappcomponent.FieldLayoutConfig:
		return m.LayoutConfig()
	case asmarketappcomponent.FieldTenantCode:
		return m.TenantCode()
	case asmarketappcomponent.FieldSource:
		return m.Source()
	case asmarketappcomponent.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketappcomponent.FieldStatus:
		return m.Status()
	case asmarketappcomponent.FieldCreateUser:
		return m.CreateUser()
	case asmarketappcomponent.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketappcomponent.FieldCreateTime:
		return m.CreateTime()
	case asmarketappcomponent.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketappcomponent.FieldAppID:
		return m.OldAppID(ctx)
	case asmarketappcomponent.FieldCode:
		return m.OldCode(ctx)
	case asmarketappcomponent.FieldName:
		return m.OldName(ctx)
	case asmarketappcomponent.FieldURL:
		return m.OldURL(ctx)
	case asmarketappcomponent.FieldType:
		return m.OldType(ctx)
	case asmarketappcomponent.FieldPreviewPic:
		return m.OldPreviewPic(ctx)
	case asmarketappcomponent.FieldLayoutType:
		return m.OldLayoutType(ctx)
	case asmarketappcomponent.FieldLayoutConfig:
		return m.OldLayoutConfig(ctx)
	case asmarketappcomponent.FieldTenantCode:
		return m.OldTenantCode(ctx)
	case asmarketappcomponent.FieldSource:
		return m.OldSource(ctx)
	case asmarketappcomponent.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketappcomponent.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketappcomponent.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketappcomponent.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketappcomponent.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketappcomponent.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketAppComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketappcomponent.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asmarketappcomponent.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case asmarketappcomponent.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case asmarketappcomponent.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case asmarketappcomponent.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case asmarketappcomponent.FieldPreviewPic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviewPic(v)
		return nil
	case asmarketappcomponent.FieldLayoutType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayoutType(v)
		return nil
	case asmarketappcomponent.FieldLayoutConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayoutConfig(v)
		return nil
	case asmarketappcomponent.FieldTenantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantCode(v)
		return nil
	case asmarketappcomponent.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case asmarketappcomponent.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketappcomponent.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketappcomponent.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketappcomponent.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketappcomponent.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketappcomponent.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppComponentMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, asmarketappcomponent.FieldType)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketappcomponent.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketappcomponent.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketappcomponent.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketappcomponent.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppComponentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketappcomponent.FieldType:
		return m.AddedType()
	case asmarketappcomponent.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketappcomponent.FieldStatus:
		return m.AddedStatus()
	case asmarketappcomponent.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketappcomponent.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketappcomponent.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case asmarketappcomponent.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketappcomponent.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketappcomponent.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketappcomponent.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketappcomponent.FieldAppID) {
		fields = append(fields, asmarketappcomponent.FieldAppID)
	}
	if m.FieldCleared(asmarketappcomponent.FieldCode) {
		fields = append(fields, asmarketappcomponent.FieldCode)
	}
	if m.FieldCleared(asmarketappcomponent.FieldName) {
		fields = append(fields, asmarketappcomponent.FieldName)
	}
	if m.FieldCleared(asmarketappcomponent.FieldURL) {
		fields = append(fields, asmarketappcomponent.FieldURL)
	}
	if m.FieldCleared(asmarketappcomponent.FieldType) {
		fields = append(fields, asmarketappcomponent.FieldType)
	}
	if m.FieldCleared(asmarketappcomponent.FieldPreviewPic) {
		fields = append(fields, asmarketappcomponent.FieldPreviewPic)
	}
	if m.FieldCleared(asmarketappcomponent.FieldLayoutType) {
		fields = append(fields, asmarketappcomponent.FieldLayoutType)
	}
	if m.FieldCleared(asmarketappcomponent.FieldLayoutConfig) {
		fields = append(fields, asmarketappcomponent.FieldLayoutConfig)
	}
	if m.FieldCleared(asmarketappcomponent.FieldTenantCode) {
		fields = append(fields, asmarketappcomponent.FieldTenantCode)
	}
	if m.FieldCleared(asmarketappcomponent.FieldSource) {
		fields = append(fields, asmarketappcomponent.FieldSource)
	}
	if m.FieldCleared(asmarketappcomponent.FieldStatus) {
		fields = append(fields, asmarketappcomponent.FieldStatus)
	}
	if m.FieldCleared(asmarketappcomponent.FieldCreateUser) {
		fields = append(fields, asmarketappcomponent.FieldCreateUser)
	}
	if m.FieldCleared(asmarketappcomponent.FieldUpdateUser) {
		fields = append(fields, asmarketappcomponent.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketappcomponent.FieldCreateTime) {
		fields = append(fields, asmarketappcomponent.FieldCreateTime)
	}
	if m.FieldCleared(asmarketappcomponent.FieldUpdateTime) {
		fields = append(fields, asmarketappcomponent.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppComponentMutation) ClearField(name string) error {
	switch name {
	case asmarketappcomponent.FieldAppID:
		m.ClearAppID()
		return nil
	case asmarketappcomponent.FieldCode:
		m.ClearCode()
		return nil
	case asmarketappcomponent.FieldName:
		m.ClearName()
		return nil
	case asmarketappcomponent.FieldURL:
		m.ClearURL()
		return nil
	case asmarketappcomponent.FieldType:
		m.ClearType()
		return nil
	case asmarketappcomponent.FieldPreviewPic:
		m.ClearPreviewPic()
		return nil
	case asmarketappcomponent.FieldLayoutType:
		m.ClearLayoutType()
		return nil
	case asmarketappcomponent.FieldLayoutConfig:
		m.ClearLayoutConfig()
		return nil
	case asmarketappcomponent.FieldTenantCode:
		m.ClearTenantCode()
		return nil
	case asmarketappcomponent.FieldSource:
		m.ClearSource()
		return nil
	case asmarketappcomponent.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketappcomponent.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketappcomponent.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketappcomponent.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketappcomponent.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppComponentMutation) ResetField(name string) error {
	switch name {
	case asmarketappcomponent.FieldAppID:
		m.ResetAppID()
		return nil
	case asmarketappcomponent.FieldCode:
		m.ResetCode()
		return nil
	case asmarketappcomponent.FieldName:
		m.ResetName()
		return nil
	case asmarketappcomponent.FieldURL:
		m.ResetURL()
		return nil
	case asmarketappcomponent.FieldType:
		m.ResetType()
		return nil
	case asmarketappcomponent.FieldPreviewPic:
		m.ResetPreviewPic()
		return nil
	case asmarketappcomponent.FieldLayoutType:
		m.ResetLayoutType()
		return nil
	case asmarketappcomponent.FieldLayoutConfig:
		m.ResetLayoutConfig()
		return nil
	case asmarketappcomponent.FieldTenantCode:
		m.ResetTenantCode()
		return nil
	case asmarketappcomponent.FieldSource:
		m.ResetSource()
		return nil
	case asmarketappcomponent.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketappcomponent.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketappcomponent.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketappcomponent.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketappcomponent.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketappcomponent.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.appx != nil {
		edges = append(edges, asmarketappcomponent.EdgeAppx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketappcomponent.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedappx {
		edges = append(edges, asmarketappcomponent.EdgeAppx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketappcomponent.EdgeAppx:
		return m.clearedappx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppComponentMutation) ClearEdge(name string) error {
	switch name {
	case asmarketappcomponent.EdgeAppx:
		m.ClearAppx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppComponentMutation) ResetEdge(name string) error {
	switch name {
	case asmarketappcomponent.EdgeAppx:
		m.ResetAppx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponent edge %s", name)
}

// AsMarketAppComponentTemplateMutation represents an operation that mutates the AsMarketAppComponentTemplate nodes in the graph.
type AsMarketAppComponentTemplateMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	name                    *string
	_config                 *string
	is_default              *int64
	addis_default           *int64
	is_deleted              *int64
	addis_deleted           *int64
	status                  *int64
	addstatus               *int64
	create_user             *int64
	addcreate_user          *int64
	update_user             *int64
	addupdate_user          *int64
	create_time             *date.DateTime
	update_time             *date.DateTime
	clearedFields           map[string]struct{}
	appUserTemplates        map[int64]struct{}
	removedappUserTemplates map[int64]struct{}
	clearedappUserTemplates bool
	done                    bool
	oldValue                func(context.Context) (*AsMarketAppComponentTemplate, error)
	predicates              []predicate.AsMarketAppComponentTemplate
}

var _ ent.Mutation = (*AsMarketAppComponentTemplateMutation)(nil)

// asmarketappcomponenttemplateOption allows management of the mutation configuration using functional options.
type asmarketappcomponenttemplateOption func(*AsMarketAppComponentTemplateMutation)

// newAsMarketAppComponentTemplateMutation creates new mutation for the AsMarketAppComponentTemplate entity.
func newAsMarketAppComponentTemplateMutation(c config, op Op, opts ...asmarketappcomponenttemplateOption) *AsMarketAppComponentTemplateMutation {
	m := &AsMarketAppComponentTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketAppComponentTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppComponentTemplateID sets the ID field of the mutation.
func withAsMarketAppComponentTemplateID(id int64) asmarketappcomponenttemplateOption {
	return func(m *AsMarketAppComponentTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketAppComponentTemplate
		)
		m.oldValue = func(ctx context.Context) (*AsMarketAppComponentTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketAppComponentTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketAppComponentTemplate sets the old AsMarketAppComponentTemplate of the mutation.
func withAsMarketAppComponentTemplate(node *AsMarketAppComponentTemplate) asmarketappcomponenttemplateOption {
	return func(m *AsMarketAppComponentTemplateMutation) {
		m.oldValue = func(context.Context) (*AsMarketAppComponentTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppComponentTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppComponentTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketAppComponentTemplate entities.
func (m *AsMarketAppComponentTemplateMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppComponentTemplateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppComponentTemplateMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketAppComponentTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AsMarketAppComponentTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AsMarketAppComponentTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AsMarketAppComponentTemplate entity.
// If the AsMarketAppComponentTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AsMarketAppComponentTemplateMutation) ClearName() {
	m.name = nil
	m.clearedFields[asmarketappcomponenttemplate.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) NameCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponenttemplate.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AsMarketAppComponentTemplateMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, asmarketappcomponenttemplate.FieldName)
}

// SetConfig sets the "config" field.
func (m *AsMarketAppComponentTemplateMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *AsMarketAppComponentTemplateMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the AsMarketAppComponentTemplate entity.
// If the AsMarketAppComponentTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentTemplateMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *AsMarketAppComponentTemplateMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[asmarketappcomponenttemplate.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponenttemplate.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *AsMarketAppComponentTemplateMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, asmarketappcomponenttemplate.FieldConfig)
}

// SetIsDefault sets the "is_default" field.
func (m *AsMarketAppComponentTemplateMutation) SetIsDefault(i int64) {
	m.is_default = &i
	m.addis_default = nil
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *AsMarketAppComponentTemplateMutation) IsDefault() (r int64, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the AsMarketAppComponentTemplate entity.
// If the AsMarketAppComponentTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentTemplateMutation) OldIsDefault(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// AddIsDefault adds i to the "is_default" field.
func (m *AsMarketAppComponentTemplateMutation) AddIsDefault(i int64) {
	if m.addis_default != nil {
		*m.addis_default += i
	} else {
		m.addis_default = &i
	}
}

// AddedIsDefault returns the value that was added to the "is_default" field in this mutation.
func (m *AsMarketAppComponentTemplateMutation) AddedIsDefault() (r int64, exists bool) {
	v := m.addis_default
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsDefault clears the value of the "is_default" field.
func (m *AsMarketAppComponentTemplateMutation) ClearIsDefault() {
	m.is_default = nil
	m.addis_default = nil
	m.clearedFields[asmarketappcomponenttemplate.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "is_default" field was cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponenttemplate.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *AsMarketAppComponentTemplateMutation) ResetIsDefault() {
	m.is_default = nil
	m.addis_default = nil
	delete(m.clearedFields, asmarketappcomponenttemplate.FieldIsDefault)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppComponentTemplateMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppComponentTemplateMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketAppComponentTemplate entity.
// If the AsMarketAppComponentTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentTemplateMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppComponentTemplateMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppComponentTemplateMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppComponentTemplateMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppComponentTemplateMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppComponentTemplateMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketAppComponentTemplate entity.
// If the AsMarketAppComponentTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentTemplateMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppComponentTemplateMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppComponentTemplateMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppComponentTemplateMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketappcomponenttemplate.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponenttemplate.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppComponentTemplateMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketappcomponenttemplate.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppComponentTemplateMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppComponentTemplateMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketAppComponentTemplate entity.
// If the AsMarketAppComponentTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentTemplateMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppComponentTemplateMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppComponentTemplateMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppComponentTemplateMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketappcomponenttemplate.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponenttemplate.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppComponentTemplateMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketappcomponenttemplate.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppComponentTemplateMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppComponentTemplateMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketAppComponentTemplate entity.
// If the AsMarketAppComponentTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentTemplateMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppComponentTemplateMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppComponentTemplateMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppComponentTemplateMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketappcomponenttemplate.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponenttemplate.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppComponentTemplateMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketappcomponenttemplate.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppComponentTemplateMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppComponentTemplateMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketAppComponentTemplate entity.
// If the AsMarketAppComponentTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentTemplateMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppComponentTemplateMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketappcomponenttemplate.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponenttemplate.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppComponentTemplateMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketappcomponenttemplate.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppComponentTemplateMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppComponentTemplateMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketAppComponentTemplate entity.
// If the AsMarketAppComponentTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppComponentTemplateMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppComponentTemplateMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketappcomponenttemplate.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappcomponenttemplate.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppComponentTemplateMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketappcomponenttemplate.FieldUpdateTime)
}

// AddAppUserTemplateIDs adds the "appUserTemplates" edge to the AsMarketAppUserTemplate entity by ids.
func (m *AsMarketAppComponentTemplateMutation) AddAppUserTemplateIDs(ids ...int64) {
	if m.appUserTemplates == nil {
		m.appUserTemplates = make(map[int64]struct{})
	}
	for i := range ids {
		m.appUserTemplates[ids[i]] = struct{}{}
	}
}

// ClearAppUserTemplates clears the "appUserTemplates" edge to the AsMarketAppUserTemplate entity.
func (m *AsMarketAppComponentTemplateMutation) ClearAppUserTemplates() {
	m.clearedappUserTemplates = true
}

// AppUserTemplatesCleared reports if the "appUserTemplates" edge to the AsMarketAppUserTemplate entity was cleared.
func (m *AsMarketAppComponentTemplateMutation) AppUserTemplatesCleared() bool {
	return m.clearedappUserTemplates
}

// RemoveAppUserTemplateIDs removes the "appUserTemplates" edge to the AsMarketAppUserTemplate entity by IDs.
func (m *AsMarketAppComponentTemplateMutation) RemoveAppUserTemplateIDs(ids ...int64) {
	if m.removedappUserTemplates == nil {
		m.removedappUserTemplates = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appUserTemplates, ids[i])
		m.removedappUserTemplates[ids[i]] = struct{}{}
	}
}

// RemovedAppUserTemplates returns the removed IDs of the "appUserTemplates" edge to the AsMarketAppUserTemplate entity.
func (m *AsMarketAppComponentTemplateMutation) RemovedAppUserTemplatesIDs() (ids []int64) {
	for id := range m.removedappUserTemplates {
		ids = append(ids, id)
	}
	return
}

// AppUserTemplatesIDs returns the "appUserTemplates" edge IDs in the mutation.
func (m *AsMarketAppComponentTemplateMutation) AppUserTemplatesIDs() (ids []int64) {
	for id := range m.appUserTemplates {
		ids = append(ids, id)
	}
	return
}

// ResetAppUserTemplates resets all changes to the "appUserTemplates" edge.
func (m *AsMarketAppComponentTemplateMutation) ResetAppUserTemplates() {
	m.appUserTemplates = nil
	m.clearedappUserTemplates = false
	m.removedappUserTemplates = nil
}

// Where appends a list predicates to the AsMarketAppComponentTemplateMutation builder.
func (m *AsMarketAppComponentTemplateMutation) Where(ps ...predicate.AsMarketAppComponentTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppComponentTemplateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketAppComponentTemplate).
func (m *AsMarketAppComponentTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppComponentTemplateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldName)
	}
	if m._config != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldConfig)
	}
	if m.is_default != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldIsDefault)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppComponentTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketappcomponenttemplate.FieldName:
		return m.Name()
	case asmarketappcomponenttemplate.FieldConfig:
		return m.Config()
	case asmarketappcomponenttemplate.FieldIsDefault:
		return m.IsDefault()
	case asmarketappcomponenttemplate.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketappcomponenttemplate.FieldStatus:
		return m.Status()
	case asmarketappcomponenttemplate.FieldCreateUser:
		return m.CreateUser()
	case asmarketappcomponenttemplate.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketappcomponenttemplate.FieldCreateTime:
		return m.CreateTime()
	case asmarketappcomponenttemplate.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppComponentTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketappcomponenttemplate.FieldName:
		return m.OldName(ctx)
	case asmarketappcomponenttemplate.FieldConfig:
		return m.OldConfig(ctx)
	case asmarketappcomponenttemplate.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case asmarketappcomponenttemplate.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketappcomponenttemplate.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketappcomponenttemplate.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketappcomponenttemplate.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketappcomponenttemplate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketappcomponenttemplate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketAppComponentTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppComponentTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketappcomponenttemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case asmarketappcomponenttemplate.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case asmarketappcomponenttemplate.FieldIsDefault:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case asmarketappcomponenttemplate.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketappcomponenttemplate.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketappcomponenttemplate.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketappcomponenttemplate.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketappcomponenttemplate.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketappcomponenttemplate.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponentTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppComponentTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addis_default != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldIsDefault)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketappcomponenttemplate.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppComponentTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketappcomponenttemplate.FieldIsDefault:
		return m.AddedIsDefault()
	case asmarketappcomponenttemplate.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketappcomponenttemplate.FieldStatus:
		return m.AddedStatus()
	case asmarketappcomponenttemplate.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketappcomponenttemplate.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppComponentTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketappcomponenttemplate.FieldIsDefault:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDefault(v)
		return nil
	case asmarketappcomponenttemplate.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketappcomponenttemplate.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketappcomponenttemplate.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketappcomponenttemplate.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponentTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppComponentTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketappcomponenttemplate.FieldName) {
		fields = append(fields, asmarketappcomponenttemplate.FieldName)
	}
	if m.FieldCleared(asmarketappcomponenttemplate.FieldConfig) {
		fields = append(fields, asmarketappcomponenttemplate.FieldConfig)
	}
	if m.FieldCleared(asmarketappcomponenttemplate.FieldIsDefault) {
		fields = append(fields, asmarketappcomponenttemplate.FieldIsDefault)
	}
	if m.FieldCleared(asmarketappcomponenttemplate.FieldStatus) {
		fields = append(fields, asmarketappcomponenttemplate.FieldStatus)
	}
	if m.FieldCleared(asmarketappcomponenttemplate.FieldCreateUser) {
		fields = append(fields, asmarketappcomponenttemplate.FieldCreateUser)
	}
	if m.FieldCleared(asmarketappcomponenttemplate.FieldUpdateUser) {
		fields = append(fields, asmarketappcomponenttemplate.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketappcomponenttemplate.FieldCreateTime) {
		fields = append(fields, asmarketappcomponenttemplate.FieldCreateTime)
	}
	if m.FieldCleared(asmarketappcomponenttemplate.FieldUpdateTime) {
		fields = append(fields, asmarketappcomponenttemplate.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppComponentTemplateMutation) ClearField(name string) error {
	switch name {
	case asmarketappcomponenttemplate.FieldName:
		m.ClearName()
		return nil
	case asmarketappcomponenttemplate.FieldConfig:
		m.ClearConfig()
		return nil
	case asmarketappcomponenttemplate.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	case asmarketappcomponenttemplate.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketappcomponenttemplate.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketappcomponenttemplate.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketappcomponenttemplate.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketappcomponenttemplate.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponentTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppComponentTemplateMutation) ResetField(name string) error {
	switch name {
	case asmarketappcomponenttemplate.FieldName:
		m.ResetName()
		return nil
	case asmarketappcomponenttemplate.FieldConfig:
		m.ResetConfig()
		return nil
	case asmarketappcomponenttemplate.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case asmarketappcomponenttemplate.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketappcomponenttemplate.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketappcomponenttemplate.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketappcomponenttemplate.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketappcomponenttemplate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketappcomponenttemplate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponentTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppComponentTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.appUserTemplates != nil {
		edges = append(edges, asmarketappcomponenttemplate.EdgeAppUserTemplates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppComponentTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketappcomponenttemplate.EdgeAppUserTemplates:
		ids := make([]ent.Value, 0, len(m.appUserTemplates))
		for id := range m.appUserTemplates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppComponentTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedappUserTemplates != nil {
		edges = append(edges, asmarketappcomponenttemplate.EdgeAppUserTemplates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppComponentTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asmarketappcomponenttemplate.EdgeAppUserTemplates:
		ids := make([]ent.Value, 0, len(m.removedappUserTemplates))
		for id := range m.removedappUserTemplates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedappUserTemplates {
		edges = append(edges, asmarketappcomponenttemplate.EdgeAppUserTemplates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppComponentTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketappcomponenttemplate.EdgeAppUserTemplates:
		return m.clearedappUserTemplates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppComponentTemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AsMarketAppComponentTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppComponentTemplateMutation) ResetEdge(name string) error {
	switch name {
	case asmarketappcomponenttemplate.EdgeAppUserTemplates:
		m.ResetAppUserTemplates()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppComponentTemplate edge %s", name)
}

// AsMarketAppGroupDistributionMutation represents an operation that mutates the AsMarketAppGroupDistribution nodes in the graph.
type AsMarketAppGroupDistributionMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	remark         *string
	tenant_id      *string
	use_status     *int64
	adduse_status  *int64
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	appx           *int64
	clearedappx    bool
	groupx         *int64
	clearedgroupx  bool
	done           bool
	oldValue       func(context.Context) (*AsMarketAppGroupDistribution, error)
	predicates     []predicate.AsMarketAppGroupDistribution
}

var _ ent.Mutation = (*AsMarketAppGroupDistributionMutation)(nil)

// asmarketappgroupdistributionOption allows management of the mutation configuration using functional options.
type asmarketappgroupdistributionOption func(*AsMarketAppGroupDistributionMutation)

// newAsMarketAppGroupDistributionMutation creates new mutation for the AsMarketAppGroupDistribution entity.
func newAsMarketAppGroupDistributionMutation(c config, op Op, opts ...asmarketappgroupdistributionOption) *AsMarketAppGroupDistributionMutation {
	m := &AsMarketAppGroupDistributionMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketAppGroupDistribution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppGroupDistributionID sets the ID field of the mutation.
func withAsMarketAppGroupDistributionID(id int64) asmarketappgroupdistributionOption {
	return func(m *AsMarketAppGroupDistributionMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketAppGroupDistribution
		)
		m.oldValue = func(ctx context.Context) (*AsMarketAppGroupDistribution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketAppGroupDistribution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketAppGroupDistribution sets the old AsMarketAppGroupDistribution of the mutation.
func withAsMarketAppGroupDistribution(node *AsMarketAppGroupDistribution) asmarketappgroupdistributionOption {
	return func(m *AsMarketAppGroupDistributionMutation) {
		m.oldValue = func(context.Context) (*AsMarketAppGroupDistribution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppGroupDistributionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppGroupDistributionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketAppGroupDistribution entities.
func (m *AsMarketAppGroupDistributionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppGroupDistributionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppGroupDistributionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketAppGroupDistribution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRemark sets the "remark" field.
func (m *AsMarketAppGroupDistributionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AsMarketAppGroupDistributionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[asmarketappgroupdistribution.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistribution.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AsMarketAppGroupDistributionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, asmarketappgroupdistribution.FieldRemark)
}

// SetAppID sets the "app_id" field.
func (m *AsMarketAppGroupDistributionMutation) SetAppID(i int64) {
	m.appx = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) AppID() (r int64, exists bool) {
	v := m.appx
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AsMarketAppGroupDistributionMutation) ClearAppID() {
	m.appx = nil
	m.clearedFields[asmarketappgroupdistribution.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistribution.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsMarketAppGroupDistributionMutation) ResetAppID() {
	m.appx = nil
	delete(m.clearedFields, asmarketappgroupdistribution.FieldAppID)
}

// SetTenantID sets the "tenant_id" field.
func (m *AsMarketAppGroupDistributionMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AsMarketAppGroupDistributionMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[asmarketappgroupdistribution.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistribution.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AsMarketAppGroupDistributionMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, asmarketappgroupdistribution.FieldTenantID)
}

// SetGroupID sets the "group_id" field.
func (m *AsMarketAppGroupDistributionMutation) SetGroupID(i int64) {
	m.groupx = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) GroupID() (r int64, exists bool) {
	v := m.groupx
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *AsMarketAppGroupDistributionMutation) ClearGroupID() {
	m.groupx = nil
	m.clearedFields[asmarketappgroupdistribution.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistribution.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *AsMarketAppGroupDistributionMutation) ResetGroupID() {
	m.groupx = nil
	delete(m.clearedFields, asmarketappgroupdistribution.FieldGroupID)
}

// SetUseStatus sets the "use_status" field.
func (m *AsMarketAppGroupDistributionMutation) SetUseStatus(i int64) {
	m.use_status = &i
	m.adduse_status = nil
}

// UseStatus returns the value of the "use_status" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) UseStatus() (r int64, exists bool) {
	v := m.use_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUseStatus returns the old "use_status" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldUseStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseStatus: %w", err)
	}
	return oldValue.UseStatus, nil
}

// AddUseStatus adds i to the "use_status" field.
func (m *AsMarketAppGroupDistributionMutation) AddUseStatus(i int64) {
	if m.adduse_status != nil {
		*m.adduse_status += i
	} else {
		m.adduse_status = &i
	}
}

// AddedUseStatus returns the value that was added to the "use_status" field in this mutation.
func (m *AsMarketAppGroupDistributionMutation) AddedUseStatus() (r int64, exists bool) {
	v := m.adduse_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearUseStatus clears the value of the "use_status" field.
func (m *AsMarketAppGroupDistributionMutation) ClearUseStatus() {
	m.use_status = nil
	m.adduse_status = nil
	m.clearedFields[asmarketappgroupdistribution.FieldUseStatus] = struct{}{}
}

// UseStatusCleared returns if the "use_status" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) UseStatusCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistribution.FieldUseStatus]
	return ok
}

// ResetUseStatus resets all changes to the "use_status" field.
func (m *AsMarketAppGroupDistributionMutation) ResetUseStatus() {
	m.use_status = nil
	m.adduse_status = nil
	delete(m.clearedFields, asmarketappgroupdistribution.FieldUseStatus)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppGroupDistributionMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppGroupDistributionMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppGroupDistributionMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppGroupDistributionMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppGroupDistributionMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppGroupDistributionMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppGroupDistributionMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppGroupDistributionMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketappgroupdistribution.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistribution.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppGroupDistributionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketappgroupdistribution.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppGroupDistributionMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppGroupDistributionMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppGroupDistributionMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppGroupDistributionMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketappgroupdistribution.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistribution.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppGroupDistributionMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketappgroupdistribution.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppGroupDistributionMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppGroupDistributionMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppGroupDistributionMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppGroupDistributionMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketappgroupdistribution.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistribution.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppGroupDistributionMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketappgroupdistribution.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppGroupDistributionMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppGroupDistributionMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketappgroupdistribution.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistribution.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppGroupDistributionMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketappgroupdistribution.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppGroupDistributionMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppGroupDistributionMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketAppGroupDistribution entity.
// If the AsMarketAppGroupDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppGroupDistributionMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketappgroupdistribution.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistribution.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppGroupDistributionMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketappgroupdistribution.FieldUpdateTime)
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsMarketAppGroupDistributionMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsMarketAppGroupDistributionMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsMarketAppGroupDistributionMutation) AppxCleared() bool {
	return m.AppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsMarketAppGroupDistributionMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppGroupDistributionMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsMarketAppGroupDistributionMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// SetGroupxID sets the "groupx" edge to the AsAllGroup entity by id.
func (m *AsMarketAppGroupDistributionMutation) SetGroupxID(id int64) {
	m.groupx = &id
}

// ClearGroupx clears the "groupx" edge to the AsAllGroup entity.
func (m *AsMarketAppGroupDistributionMutation) ClearGroupx() {
	m.clearedgroupx = true
}

// GroupxCleared reports if the "groupx" edge to the AsAllGroup entity was cleared.
func (m *AsMarketAppGroupDistributionMutation) GroupxCleared() bool {
	return m.GroupIDCleared() || m.clearedgroupx
}

// GroupxID returns the "groupx" edge ID in the mutation.
func (m *AsMarketAppGroupDistributionMutation) GroupxID() (id int64, exists bool) {
	if m.groupx != nil {
		return *m.groupx, true
	}
	return
}

// GroupxIDs returns the "groupx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppGroupDistributionMutation) GroupxIDs() (ids []int64) {
	if id := m.groupx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupx resets all changes to the "groupx" edge.
func (m *AsMarketAppGroupDistributionMutation) ResetGroupx() {
	m.groupx = nil
	m.clearedgroupx = false
}

// Where appends a list predicates to the AsMarketAppGroupDistributionMutation builder.
func (m *AsMarketAppGroupDistributionMutation) Where(ps ...predicate.AsMarketAppGroupDistribution) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppGroupDistributionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketAppGroupDistribution).
func (m *AsMarketAppGroupDistributionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppGroupDistributionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.remark != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldRemark)
	}
	if m.appx != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldAppID)
	}
	if m.tenant_id != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldTenantID)
	}
	if m.groupx != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldGroupID)
	}
	if m.use_status != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldUseStatus)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppGroupDistributionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketappgroupdistribution.FieldRemark:
		return m.Remark()
	case asmarketappgroupdistribution.FieldAppID:
		return m.AppID()
	case asmarketappgroupdistribution.FieldTenantID:
		return m.TenantID()
	case asmarketappgroupdistribution.FieldGroupID:
		return m.GroupID()
	case asmarketappgroupdistribution.FieldUseStatus:
		return m.UseStatus()
	case asmarketappgroupdistribution.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketappgroupdistribution.FieldStatus:
		return m.Status()
	case asmarketappgroupdistribution.FieldCreateUser:
		return m.CreateUser()
	case asmarketappgroupdistribution.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketappgroupdistribution.FieldCreateTime:
		return m.CreateTime()
	case asmarketappgroupdistribution.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppGroupDistributionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketappgroupdistribution.FieldRemark:
		return m.OldRemark(ctx)
	case asmarketappgroupdistribution.FieldAppID:
		return m.OldAppID(ctx)
	case asmarketappgroupdistribution.FieldTenantID:
		return m.OldTenantID(ctx)
	case asmarketappgroupdistribution.FieldGroupID:
		return m.OldGroupID(ctx)
	case asmarketappgroupdistribution.FieldUseStatus:
		return m.OldUseStatus(ctx)
	case asmarketappgroupdistribution.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketappgroupdistribution.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketappgroupdistribution.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketappgroupdistribution.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketappgroupdistribution.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketappgroupdistribution.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketAppGroupDistribution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppGroupDistributionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketappgroupdistribution.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case asmarketappgroupdistribution.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asmarketappgroupdistribution.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case asmarketappgroupdistribution.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case asmarketappgroupdistribution.FieldUseStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseStatus(v)
		return nil
	case asmarketappgroupdistribution.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketappgroupdistribution.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketappgroupdistribution.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketappgroupdistribution.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketappgroupdistribution.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketappgroupdistribution.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistribution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppGroupDistributionMutation) AddedFields() []string {
	var fields []string
	if m.adduse_status != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldUseStatus)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketappgroupdistribution.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppGroupDistributionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketappgroupdistribution.FieldUseStatus:
		return m.AddedUseStatus()
	case asmarketappgroupdistribution.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketappgroupdistribution.FieldStatus:
		return m.AddedStatus()
	case asmarketappgroupdistribution.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketappgroupdistribution.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppGroupDistributionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketappgroupdistribution.FieldUseStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseStatus(v)
		return nil
	case asmarketappgroupdistribution.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketappgroupdistribution.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketappgroupdistribution.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketappgroupdistribution.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistribution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppGroupDistributionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketappgroupdistribution.FieldRemark) {
		fields = append(fields, asmarketappgroupdistribution.FieldRemark)
	}
	if m.FieldCleared(asmarketappgroupdistribution.FieldAppID) {
		fields = append(fields, asmarketappgroupdistribution.FieldAppID)
	}
	if m.FieldCleared(asmarketappgroupdistribution.FieldTenantID) {
		fields = append(fields, asmarketappgroupdistribution.FieldTenantID)
	}
	if m.FieldCleared(asmarketappgroupdistribution.FieldGroupID) {
		fields = append(fields, asmarketappgroupdistribution.FieldGroupID)
	}
	if m.FieldCleared(asmarketappgroupdistribution.FieldUseStatus) {
		fields = append(fields, asmarketappgroupdistribution.FieldUseStatus)
	}
	if m.FieldCleared(asmarketappgroupdistribution.FieldStatus) {
		fields = append(fields, asmarketappgroupdistribution.FieldStatus)
	}
	if m.FieldCleared(asmarketappgroupdistribution.FieldCreateUser) {
		fields = append(fields, asmarketappgroupdistribution.FieldCreateUser)
	}
	if m.FieldCleared(asmarketappgroupdistribution.FieldUpdateUser) {
		fields = append(fields, asmarketappgroupdistribution.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketappgroupdistribution.FieldCreateTime) {
		fields = append(fields, asmarketappgroupdistribution.FieldCreateTime)
	}
	if m.FieldCleared(asmarketappgroupdistribution.FieldUpdateTime) {
		fields = append(fields, asmarketappgroupdistribution.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppGroupDistributionMutation) ClearField(name string) error {
	switch name {
	case asmarketappgroupdistribution.FieldRemark:
		m.ClearRemark()
		return nil
	case asmarketappgroupdistribution.FieldAppID:
		m.ClearAppID()
		return nil
	case asmarketappgroupdistribution.FieldTenantID:
		m.ClearTenantID()
		return nil
	case asmarketappgroupdistribution.FieldGroupID:
		m.ClearGroupID()
		return nil
	case asmarketappgroupdistribution.FieldUseStatus:
		m.ClearUseStatus()
		return nil
	case asmarketappgroupdistribution.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketappgroupdistribution.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketappgroupdistribution.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketappgroupdistribution.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketappgroupdistribution.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistribution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppGroupDistributionMutation) ResetField(name string) error {
	switch name {
	case asmarketappgroupdistribution.FieldRemark:
		m.ResetRemark()
		return nil
	case asmarketappgroupdistribution.FieldAppID:
		m.ResetAppID()
		return nil
	case asmarketappgroupdistribution.FieldTenantID:
		m.ResetTenantID()
		return nil
	case asmarketappgroupdistribution.FieldGroupID:
		m.ResetGroupID()
		return nil
	case asmarketappgroupdistribution.FieldUseStatus:
		m.ResetUseStatus()
		return nil
	case asmarketappgroupdistribution.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketappgroupdistribution.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketappgroupdistribution.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketappgroupdistribution.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketappgroupdistribution.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketappgroupdistribution.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistribution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppGroupDistributionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.appx != nil {
		edges = append(edges, asmarketappgroupdistribution.EdgeAppx)
	}
	if m.groupx != nil {
		edges = append(edges, asmarketappgroupdistribution.EdgeGroupx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppGroupDistributionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketappgroupdistribution.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	case asmarketappgroupdistribution.EdgeGroupx:
		if id := m.groupx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppGroupDistributionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppGroupDistributionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedappx {
		edges = append(edges, asmarketappgroupdistribution.EdgeAppx)
	}
	if m.clearedgroupx {
		edges = append(edges, asmarketappgroupdistribution.EdgeGroupx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppGroupDistributionMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketappgroupdistribution.EdgeAppx:
		return m.clearedappx
	case asmarketappgroupdistribution.EdgeGroupx:
		return m.clearedgroupx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppGroupDistributionMutation) ClearEdge(name string) error {
	switch name {
	case asmarketappgroupdistribution.EdgeAppx:
		m.ClearAppx()
		return nil
	case asmarketappgroupdistribution.EdgeGroupx:
		m.ClearGroupx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistribution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppGroupDistributionMutation) ResetEdge(name string) error {
	switch name {
	case asmarketappgroupdistribution.EdgeAppx:
		m.ResetAppx()
		return nil
	case asmarketappgroupdistribution.EdgeGroupx:
		m.ResetGroupx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistribution edge %s", name)
}

// AsMarketAppGroupDistributionRelationMutation represents an operation that mutates the AsMarketAppGroupDistributionRelation nodes in the graph.
type AsMarketAppGroupDistributionRelationMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	relation_id    *int64
	addrelation_id *int64
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	appx           *int64
	clearedappx    bool
	groupx         *int64
	clearedgroupx  bool
	done           bool
	oldValue       func(context.Context) (*AsMarketAppGroupDistributionRelation, error)
	predicates     []predicate.AsMarketAppGroupDistributionRelation
}

var _ ent.Mutation = (*AsMarketAppGroupDistributionRelationMutation)(nil)

// asmarketappgroupdistributionrelationOption allows management of the mutation configuration using functional options.
type asmarketappgroupdistributionrelationOption func(*AsMarketAppGroupDistributionRelationMutation)

// newAsMarketAppGroupDistributionRelationMutation creates new mutation for the AsMarketAppGroupDistributionRelation entity.
func newAsMarketAppGroupDistributionRelationMutation(c config, op Op, opts ...asmarketappgroupdistributionrelationOption) *AsMarketAppGroupDistributionRelationMutation {
	m := &AsMarketAppGroupDistributionRelationMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketAppGroupDistributionRelation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppGroupDistributionRelationID sets the ID field of the mutation.
func withAsMarketAppGroupDistributionRelationID(id int64) asmarketappgroupdistributionrelationOption {
	return func(m *AsMarketAppGroupDistributionRelationMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketAppGroupDistributionRelation
		)
		m.oldValue = func(ctx context.Context) (*AsMarketAppGroupDistributionRelation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketAppGroupDistributionRelation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketAppGroupDistributionRelation sets the old AsMarketAppGroupDistributionRelation of the mutation.
func withAsMarketAppGroupDistributionRelation(node *AsMarketAppGroupDistributionRelation) asmarketappgroupdistributionrelationOption {
	return func(m *AsMarketAppGroupDistributionRelationMutation) {
		m.oldValue = func(context.Context) (*AsMarketAppGroupDistributionRelation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppGroupDistributionRelationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppGroupDistributionRelationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketAppGroupDistributionRelation entities.
func (m *AsMarketAppGroupDistributionRelationMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppGroupDistributionRelationMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketAppGroupDistributionRelation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AsMarketAppGroupDistributionRelationMutation) SetAppID(i int64) {
	m.appx = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AppID() (r int64, exists bool) {
	v := m.appx
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsMarketAppGroupDistributionRelation entity.
// If the AsMarketAppGroupDistributionRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionRelationMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearAppID() {
	m.appx = nil
	m.clearedFields[asmarketappgroupdistributionrelation.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistributionrelation.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetAppID() {
	m.appx = nil
	delete(m.clearedFields, asmarketappgroupdistributionrelation.FieldAppID)
}

// SetRelationID sets the "relation_id" field.
func (m *AsMarketAppGroupDistributionRelationMutation) SetRelationID(i int64) {
	m.relation_id = &i
	m.addrelation_id = nil
}

// RelationID returns the value of the "relation_id" field in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) RelationID() (r int64, exists bool) {
	v := m.relation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationID returns the old "relation_id" field's value of the AsMarketAppGroupDistributionRelation entity.
// If the AsMarketAppGroupDistributionRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionRelationMutation) OldRelationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationID: %w", err)
	}
	return oldValue.RelationID, nil
}

// AddRelationID adds i to the "relation_id" field.
func (m *AsMarketAppGroupDistributionRelationMutation) AddRelationID(i int64) {
	if m.addrelation_id != nil {
		*m.addrelation_id += i
	} else {
		m.addrelation_id = &i
	}
}

// AddedRelationID returns the value that was added to the "relation_id" field in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AddedRelationID() (r int64, exists bool) {
	v := m.addrelation_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelationID clears the value of the "relation_id" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearRelationID() {
	m.relation_id = nil
	m.addrelation_id = nil
	m.clearedFields[asmarketappgroupdistributionrelation.FieldRelationID] = struct{}{}
}

// RelationIDCleared returns if the "relation_id" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) RelationIDCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistributionrelation.FieldRelationID]
	return ok
}

// ResetRelationID resets all changes to the "relation_id" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetRelationID() {
	m.relation_id = nil
	m.addrelation_id = nil
	delete(m.clearedFields, asmarketappgroupdistributionrelation.FieldRelationID)
}

// SetGroupID sets the "group_id" field.
func (m *AsMarketAppGroupDistributionRelationMutation) SetGroupID(i int64) {
	m.groupx = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) GroupID() (r int64, exists bool) {
	v := m.groupx
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the AsMarketAppGroupDistributionRelation entity.
// If the AsMarketAppGroupDistributionRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionRelationMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearGroupID() {
	m.groupx = nil
	m.clearedFields[asmarketappgroupdistributionrelation.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistributionrelation.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetGroupID() {
	m.groupx = nil
	delete(m.clearedFields, asmarketappgroupdistributionrelation.FieldGroupID)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppGroupDistributionRelationMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketAppGroupDistributionRelation entity.
// If the AsMarketAppGroupDistributionRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionRelationMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppGroupDistributionRelationMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppGroupDistributionRelationMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketAppGroupDistributionRelation entity.
// If the AsMarketAppGroupDistributionRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionRelationMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppGroupDistributionRelationMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketappgroupdistributionrelation.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistributionrelation.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketappgroupdistributionrelation.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppGroupDistributionRelationMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketAppGroupDistributionRelation entity.
// If the AsMarketAppGroupDistributionRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionRelationMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppGroupDistributionRelationMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketappgroupdistributionrelation.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistributionrelation.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketappgroupdistributionrelation.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppGroupDistributionRelationMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketAppGroupDistributionRelation entity.
// If the AsMarketAppGroupDistributionRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionRelationMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppGroupDistributionRelationMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketappgroupdistributionrelation.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistributionrelation.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketappgroupdistributionrelation.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppGroupDistributionRelationMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketAppGroupDistributionRelation entity.
// If the AsMarketAppGroupDistributionRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionRelationMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketappgroupdistributionrelation.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistributionrelation.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketappgroupdistributionrelation.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppGroupDistributionRelationMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketAppGroupDistributionRelation entity.
// If the AsMarketAppGroupDistributionRelation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppGroupDistributionRelationMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketappgroupdistributionrelation.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappgroupdistributionrelation.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketappgroupdistributionrelation.FieldUpdateTime)
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsMarketAppGroupDistributionRelationMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsMarketAppGroupDistributionRelationMutation) AppxCleared() bool {
	return m.AppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppGroupDistributionRelationMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// SetGroupxID sets the "groupx" edge to the AsAllGroup entity by id.
func (m *AsMarketAppGroupDistributionRelationMutation) SetGroupxID(id int64) {
	m.groupx = &id
}

// ClearGroupx clears the "groupx" edge to the AsAllGroup entity.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearGroupx() {
	m.clearedgroupx = true
}

// GroupxCleared reports if the "groupx" edge to the AsAllGroup entity was cleared.
func (m *AsMarketAppGroupDistributionRelationMutation) GroupxCleared() bool {
	return m.GroupIDCleared() || m.clearedgroupx
}

// GroupxID returns the "groupx" edge ID in the mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) GroupxID() (id int64, exists bool) {
	if m.groupx != nil {
		return *m.groupx, true
	}
	return
}

// GroupxIDs returns the "groupx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppGroupDistributionRelationMutation) GroupxIDs() (ids []int64) {
	if id := m.groupx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupx resets all changes to the "groupx" edge.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetGroupx() {
	m.groupx = nil
	m.clearedgroupx = false
}

// Where appends a list predicates to the AsMarketAppGroupDistributionRelationMutation builder.
func (m *AsMarketAppGroupDistributionRelationMutation) Where(ps ...predicate.AsMarketAppGroupDistributionRelation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppGroupDistributionRelationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketAppGroupDistributionRelation).
func (m *AsMarketAppGroupDistributionRelationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppGroupDistributionRelationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.appx != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldAppID)
	}
	if m.relation_id != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldRelationID)
	}
	if m.groupx != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldGroupID)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppGroupDistributionRelationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketappgroupdistributionrelation.FieldAppID:
		return m.AppID()
	case asmarketappgroupdistributionrelation.FieldRelationID:
		return m.RelationID()
	case asmarketappgroupdistributionrelation.FieldGroupID:
		return m.GroupID()
	case asmarketappgroupdistributionrelation.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketappgroupdistributionrelation.FieldStatus:
		return m.Status()
	case asmarketappgroupdistributionrelation.FieldCreateUser:
		return m.CreateUser()
	case asmarketappgroupdistributionrelation.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketappgroupdistributionrelation.FieldCreateTime:
		return m.CreateTime()
	case asmarketappgroupdistributionrelation.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppGroupDistributionRelationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketappgroupdistributionrelation.FieldAppID:
		return m.OldAppID(ctx)
	case asmarketappgroupdistributionrelation.FieldRelationID:
		return m.OldRelationID(ctx)
	case asmarketappgroupdistributionrelation.FieldGroupID:
		return m.OldGroupID(ctx)
	case asmarketappgroupdistributionrelation.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketappgroupdistributionrelation.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketappgroupdistributionrelation.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketappgroupdistributionrelation.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketappgroupdistributionrelation.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketappgroupdistributionrelation.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketAppGroupDistributionRelation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppGroupDistributionRelationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketappgroupdistributionrelation.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldRelationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationID(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistributionRelation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AddedFields() []string {
	var fields []string
	if m.addrelation_id != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldRelationID)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppGroupDistributionRelationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketappgroupdistributionrelation.FieldRelationID:
		return m.AddedRelationID()
	case asmarketappgroupdistributionrelation.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketappgroupdistributionrelation.FieldStatus:
		return m.AddedStatus()
	case asmarketappgroupdistributionrelation.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketappgroupdistributionrelation.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppGroupDistributionRelationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketappgroupdistributionrelation.FieldRelationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationID(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketappgroupdistributionrelation.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistributionRelation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketappgroupdistributionrelation.FieldAppID) {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldAppID)
	}
	if m.FieldCleared(asmarketappgroupdistributionrelation.FieldRelationID) {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldRelationID)
	}
	if m.FieldCleared(asmarketappgroupdistributionrelation.FieldGroupID) {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldGroupID)
	}
	if m.FieldCleared(asmarketappgroupdistributionrelation.FieldStatus) {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldStatus)
	}
	if m.FieldCleared(asmarketappgroupdistributionrelation.FieldCreateUser) {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldCreateUser)
	}
	if m.FieldCleared(asmarketappgroupdistributionrelation.FieldUpdateUser) {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketappgroupdistributionrelation.FieldCreateTime) {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldCreateTime)
	}
	if m.FieldCleared(asmarketappgroupdistributionrelation.FieldUpdateTime) {
		fields = append(fields, asmarketappgroupdistributionrelation.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearField(name string) error {
	switch name {
	case asmarketappgroupdistributionrelation.FieldAppID:
		m.ClearAppID()
		return nil
	case asmarketappgroupdistributionrelation.FieldRelationID:
		m.ClearRelationID()
		return nil
	case asmarketappgroupdistributionrelation.FieldGroupID:
		m.ClearGroupID()
		return nil
	case asmarketappgroupdistributionrelation.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketappgroupdistributionrelation.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketappgroupdistributionrelation.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketappgroupdistributionrelation.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketappgroupdistributionrelation.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistributionRelation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetField(name string) error {
	switch name {
	case asmarketappgroupdistributionrelation.FieldAppID:
		m.ResetAppID()
		return nil
	case asmarketappgroupdistributionrelation.FieldRelationID:
		m.ResetRelationID()
		return nil
	case asmarketappgroupdistributionrelation.FieldGroupID:
		m.ResetGroupID()
		return nil
	case asmarketappgroupdistributionrelation.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketappgroupdistributionrelation.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketappgroupdistributionrelation.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketappgroupdistributionrelation.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketappgroupdistributionrelation.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketappgroupdistributionrelation.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistributionRelation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.appx != nil {
		edges = append(edges, asmarketappgroupdistributionrelation.EdgeAppx)
	}
	if m.groupx != nil {
		edges = append(edges, asmarketappgroupdistributionrelation.EdgeGroupx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketappgroupdistributionrelation.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	case asmarketappgroupdistributionrelation.EdgeGroupx:
		if id := m.groupx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedappx {
		edges = append(edges, asmarketappgroupdistributionrelation.EdgeAppx)
	}
	if m.clearedgroupx {
		edges = append(edges, asmarketappgroupdistributionrelation.EdgeGroupx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppGroupDistributionRelationMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketappgroupdistributionrelation.EdgeAppx:
		return m.clearedappx
	case asmarketappgroupdistributionrelation.EdgeGroupx:
		return m.clearedgroupx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppGroupDistributionRelationMutation) ClearEdge(name string) error {
	switch name {
	case asmarketappgroupdistributionrelation.EdgeAppx:
		m.ClearAppx()
		return nil
	case asmarketappgroupdistributionrelation.EdgeGroupx:
		m.ClearGroupx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistributionRelation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppGroupDistributionRelationMutation) ResetEdge(name string) error {
	switch name {
	case asmarketappgroupdistributionrelation.EdgeAppx:
		m.ResetAppx()
		return nil
	case asmarketappgroupdistributionrelation.EdgeGroupx:
		m.ResetGroupx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppGroupDistributionRelation edge %s", name)
}

// AsMarketAppKeySecretMutation represents an operation that mutates the AsMarketAppKeySecret nodes in the graph.
type AsMarketAppKeySecretMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	app_key        *string
	app_secret     *string
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	appx           *int64
	clearedappx    bool
	done           bool
	oldValue       func(context.Context) (*AsMarketAppKeySecret, error)
	predicates     []predicate.AsMarketAppKeySecret
}

var _ ent.Mutation = (*AsMarketAppKeySecretMutation)(nil)

// asmarketappkeysecretOption allows management of the mutation configuration using functional options.
type asmarketappkeysecretOption func(*AsMarketAppKeySecretMutation)

// newAsMarketAppKeySecretMutation creates new mutation for the AsMarketAppKeySecret entity.
func newAsMarketAppKeySecretMutation(c config, op Op, opts ...asmarketappkeysecretOption) *AsMarketAppKeySecretMutation {
	m := &AsMarketAppKeySecretMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketAppKeySecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppKeySecretID sets the ID field of the mutation.
func withAsMarketAppKeySecretID(id int64) asmarketappkeysecretOption {
	return func(m *AsMarketAppKeySecretMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketAppKeySecret
		)
		m.oldValue = func(ctx context.Context) (*AsMarketAppKeySecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketAppKeySecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketAppKeySecret sets the old AsMarketAppKeySecret of the mutation.
func withAsMarketAppKeySecret(node *AsMarketAppKeySecret) asmarketappkeysecretOption {
	return func(m *AsMarketAppKeySecretMutation) {
		m.oldValue = func(context.Context) (*AsMarketAppKeySecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppKeySecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppKeySecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketAppKeySecret entities.
func (m *AsMarketAppKeySecretMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppKeySecretMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppKeySecretMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketAppKeySecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AsMarketAppKeySecretMutation) SetAppID(i int64) {
	m.appx = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsMarketAppKeySecretMutation) AppID() (r int64, exists bool) {
	v := m.appx
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsMarketAppKeySecret entity.
// If the AsMarketAppKeySecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppKeySecretMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AsMarketAppKeySecretMutation) ClearAppID() {
	m.appx = nil
	m.clearedFields[asmarketappkeysecret.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[asmarketappkeysecret.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsMarketAppKeySecretMutation) ResetAppID() {
	m.appx = nil
	delete(m.clearedFields, asmarketappkeysecret.FieldAppID)
}

// SetAppKey sets the "app_key" field.
func (m *AsMarketAppKeySecretMutation) SetAppKey(s string) {
	m.app_key = &s
}

// AppKey returns the value of the "app_key" field in the mutation.
func (m *AsMarketAppKeySecretMutation) AppKey() (r string, exists bool) {
	v := m.app_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAppKey returns the old "app_key" field's value of the AsMarketAppKeySecret entity.
// If the AsMarketAppKeySecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppKeySecretMutation) OldAppKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppKey: %w", err)
	}
	return oldValue.AppKey, nil
}

// ClearAppKey clears the value of the "app_key" field.
func (m *AsMarketAppKeySecretMutation) ClearAppKey() {
	m.app_key = nil
	m.clearedFields[asmarketappkeysecret.FieldAppKey] = struct{}{}
}

// AppKeyCleared returns if the "app_key" field was cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) AppKeyCleared() bool {
	_, ok := m.clearedFields[asmarketappkeysecret.FieldAppKey]
	return ok
}

// ResetAppKey resets all changes to the "app_key" field.
func (m *AsMarketAppKeySecretMutation) ResetAppKey() {
	m.app_key = nil
	delete(m.clearedFields, asmarketappkeysecret.FieldAppKey)
}

// SetAppSecret sets the "app_secret" field.
func (m *AsMarketAppKeySecretMutation) SetAppSecret(s string) {
	m.app_secret = &s
}

// AppSecret returns the value of the "app_secret" field in the mutation.
func (m *AsMarketAppKeySecretMutation) AppSecret() (r string, exists bool) {
	v := m.app_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSecret returns the old "app_secret" field's value of the AsMarketAppKeySecret entity.
// If the AsMarketAppKeySecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppKeySecretMutation) OldAppSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSecret: %w", err)
	}
	return oldValue.AppSecret, nil
}

// ClearAppSecret clears the value of the "app_secret" field.
func (m *AsMarketAppKeySecretMutation) ClearAppSecret() {
	m.app_secret = nil
	m.clearedFields[asmarketappkeysecret.FieldAppSecret] = struct{}{}
}

// AppSecretCleared returns if the "app_secret" field was cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) AppSecretCleared() bool {
	_, ok := m.clearedFields[asmarketappkeysecret.FieldAppSecret]
	return ok
}

// ResetAppSecret resets all changes to the "app_secret" field.
func (m *AsMarketAppKeySecretMutation) ResetAppSecret() {
	m.app_secret = nil
	delete(m.clearedFields, asmarketappkeysecret.FieldAppSecret)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppKeySecretMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppKeySecretMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketAppKeySecret entity.
// If the AsMarketAppKeySecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppKeySecretMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppKeySecretMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppKeySecretMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppKeySecretMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppKeySecretMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppKeySecretMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketAppKeySecret entity.
// If the AsMarketAppKeySecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppKeySecretMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppKeySecretMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppKeySecretMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppKeySecretMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketappkeysecret.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketappkeysecret.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppKeySecretMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketappkeysecret.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppKeySecretMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppKeySecretMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketAppKeySecret entity.
// If the AsMarketAppKeySecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppKeySecretMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppKeySecretMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppKeySecretMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppKeySecretMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketappkeysecret.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappkeysecret.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppKeySecretMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketappkeysecret.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppKeySecretMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppKeySecretMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketAppKeySecret entity.
// If the AsMarketAppKeySecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppKeySecretMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppKeySecretMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppKeySecretMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppKeySecretMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketappkeysecret.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappkeysecret.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppKeySecretMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketappkeysecret.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppKeySecretMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppKeySecretMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketAppKeySecret entity.
// If the AsMarketAppKeySecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppKeySecretMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppKeySecretMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketappkeysecret.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappkeysecret.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppKeySecretMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketappkeysecret.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppKeySecretMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppKeySecretMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketAppKeySecret entity.
// If the AsMarketAppKeySecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppKeySecretMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppKeySecretMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketappkeysecret.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappkeysecret.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppKeySecretMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketappkeysecret.FieldUpdateTime)
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsMarketAppKeySecretMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsMarketAppKeySecretMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsMarketAppKeySecretMutation) AppxCleared() bool {
	return m.AppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsMarketAppKeySecretMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppKeySecretMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsMarketAppKeySecretMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// Where appends a list predicates to the AsMarketAppKeySecretMutation builder.
func (m *AsMarketAppKeySecretMutation) Where(ps ...predicate.AsMarketAppKeySecret) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppKeySecretMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketAppKeySecret).
func (m *AsMarketAppKeySecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppKeySecretMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.appx != nil {
		fields = append(fields, asmarketappkeysecret.FieldAppID)
	}
	if m.app_key != nil {
		fields = append(fields, asmarketappkeysecret.FieldAppKey)
	}
	if m.app_secret != nil {
		fields = append(fields, asmarketappkeysecret.FieldAppSecret)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketappkeysecret.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketappkeysecret.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketappkeysecret.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketappkeysecret.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketappkeysecret.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketappkeysecret.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppKeySecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketappkeysecret.FieldAppID:
		return m.AppID()
	case asmarketappkeysecret.FieldAppKey:
		return m.AppKey()
	case asmarketappkeysecret.FieldAppSecret:
		return m.AppSecret()
	case asmarketappkeysecret.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketappkeysecret.FieldStatus:
		return m.Status()
	case asmarketappkeysecret.FieldCreateUser:
		return m.CreateUser()
	case asmarketappkeysecret.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketappkeysecret.FieldCreateTime:
		return m.CreateTime()
	case asmarketappkeysecret.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppKeySecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketappkeysecret.FieldAppID:
		return m.OldAppID(ctx)
	case asmarketappkeysecret.FieldAppKey:
		return m.OldAppKey(ctx)
	case asmarketappkeysecret.FieldAppSecret:
		return m.OldAppSecret(ctx)
	case asmarketappkeysecret.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketappkeysecret.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketappkeysecret.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketappkeysecret.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketappkeysecret.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketappkeysecret.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketAppKeySecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppKeySecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketappkeysecret.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asmarketappkeysecret.FieldAppKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppKey(v)
		return nil
	case asmarketappkeysecret.FieldAppSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSecret(v)
		return nil
	case asmarketappkeysecret.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketappkeysecret.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketappkeysecret.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketappkeysecret.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketappkeysecret.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketappkeysecret.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppKeySecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppKeySecretMutation) AddedFields() []string {
	var fields []string
	if m.addis_deleted != nil {
		fields = append(fields, asmarketappkeysecret.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketappkeysecret.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketappkeysecret.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketappkeysecret.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppKeySecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketappkeysecret.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketappkeysecret.FieldStatus:
		return m.AddedStatus()
	case asmarketappkeysecret.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketappkeysecret.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppKeySecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketappkeysecret.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketappkeysecret.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketappkeysecret.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketappkeysecret.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppKeySecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppKeySecretMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketappkeysecret.FieldAppID) {
		fields = append(fields, asmarketappkeysecret.FieldAppID)
	}
	if m.FieldCleared(asmarketappkeysecret.FieldAppKey) {
		fields = append(fields, asmarketappkeysecret.FieldAppKey)
	}
	if m.FieldCleared(asmarketappkeysecret.FieldAppSecret) {
		fields = append(fields, asmarketappkeysecret.FieldAppSecret)
	}
	if m.FieldCleared(asmarketappkeysecret.FieldStatus) {
		fields = append(fields, asmarketappkeysecret.FieldStatus)
	}
	if m.FieldCleared(asmarketappkeysecret.FieldCreateUser) {
		fields = append(fields, asmarketappkeysecret.FieldCreateUser)
	}
	if m.FieldCleared(asmarketappkeysecret.FieldUpdateUser) {
		fields = append(fields, asmarketappkeysecret.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketappkeysecret.FieldCreateTime) {
		fields = append(fields, asmarketappkeysecret.FieldCreateTime)
	}
	if m.FieldCleared(asmarketappkeysecret.FieldUpdateTime) {
		fields = append(fields, asmarketappkeysecret.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppKeySecretMutation) ClearField(name string) error {
	switch name {
	case asmarketappkeysecret.FieldAppID:
		m.ClearAppID()
		return nil
	case asmarketappkeysecret.FieldAppKey:
		m.ClearAppKey()
		return nil
	case asmarketappkeysecret.FieldAppSecret:
		m.ClearAppSecret()
		return nil
	case asmarketappkeysecret.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketappkeysecret.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketappkeysecret.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketappkeysecret.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketappkeysecret.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppKeySecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppKeySecretMutation) ResetField(name string) error {
	switch name {
	case asmarketappkeysecret.FieldAppID:
		m.ResetAppID()
		return nil
	case asmarketappkeysecret.FieldAppKey:
		m.ResetAppKey()
		return nil
	case asmarketappkeysecret.FieldAppSecret:
		m.ResetAppSecret()
		return nil
	case asmarketappkeysecret.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketappkeysecret.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketappkeysecret.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketappkeysecret.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketappkeysecret.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketappkeysecret.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppKeySecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppKeySecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.appx != nil {
		edges = append(edges, asmarketappkeysecret.EdgeAppx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppKeySecretMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketappkeysecret.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppKeySecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppKeySecretMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedappx {
		edges = append(edges, asmarketappkeysecret.EdgeAppx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppKeySecretMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketappkeysecret.EdgeAppx:
		return m.clearedappx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppKeySecretMutation) ClearEdge(name string) error {
	switch name {
	case asmarketappkeysecret.EdgeAppx:
		m.ClearAppx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppKeySecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppKeySecretMutation) ResetEdge(name string) error {
	switch name {
	case asmarketappkeysecret.EdgeAppx:
		m.ResetAppx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppKeySecret edge %s", name)
}

// AsMarketAppNoticeMutation represents an operation that mutates the AsMarketAppNotice nodes in the graph.
type AsMarketAppNoticeMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int64
	notice_title              *string
	notice_content            *string
	notice_release_unit_id    *int64
	addnotice_release_unit_id *int64
	notice_release_status     *int64
	addnotice_release_status  *int64
	notice_release_time       *date.DateTime
	notice_role_ids           *string
	notice_unit_ids           *string
	group_or_unit             *int64
	addgroup_or_unit          *int64
	unit_query_ids            *string
	is_deleted                *int64
	addis_deleted             *int64
	status                    *int64
	addstatus                 *int64
	create_user               *int64
	addcreate_user            *int64
	update_user               *int64
	addupdate_user            *int64
	create_time               *date.DateTime
	update_time               *date.DateTime
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*AsMarketAppNotice, error)
	predicates                []predicate.AsMarketAppNotice
}

var _ ent.Mutation = (*AsMarketAppNoticeMutation)(nil)

// asmarketappnoticeOption allows management of the mutation configuration using functional options.
type asmarketappnoticeOption func(*AsMarketAppNoticeMutation)

// newAsMarketAppNoticeMutation creates new mutation for the AsMarketAppNotice entity.
func newAsMarketAppNoticeMutation(c config, op Op, opts ...asmarketappnoticeOption) *AsMarketAppNoticeMutation {
	m := &AsMarketAppNoticeMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketAppNotice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppNoticeID sets the ID field of the mutation.
func withAsMarketAppNoticeID(id int64) asmarketappnoticeOption {
	return func(m *AsMarketAppNoticeMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketAppNotice
		)
		m.oldValue = func(ctx context.Context) (*AsMarketAppNotice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketAppNotice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketAppNotice sets the old AsMarketAppNotice of the mutation.
func withAsMarketAppNotice(node *AsMarketAppNotice) asmarketappnoticeOption {
	return func(m *AsMarketAppNoticeMutation) {
		m.oldValue = func(context.Context) (*AsMarketAppNotice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppNoticeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppNoticeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketAppNotice entities.
func (m *AsMarketAppNoticeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppNoticeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppNoticeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketAppNotice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNoticeTitle sets the "notice_title" field.
func (m *AsMarketAppNoticeMutation) SetNoticeTitle(s string) {
	m.notice_title = &s
}

// NoticeTitle returns the value of the "notice_title" field in the mutation.
func (m *AsMarketAppNoticeMutation) NoticeTitle() (r string, exists bool) {
	v := m.notice_title
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeTitle returns the old "notice_title" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldNoticeTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeTitle: %w", err)
	}
	return oldValue.NoticeTitle, nil
}

// ClearNoticeTitle clears the value of the "notice_title" field.
func (m *AsMarketAppNoticeMutation) ClearNoticeTitle() {
	m.notice_title = nil
	m.clearedFields[asmarketappnotice.FieldNoticeTitle] = struct{}{}
}

// NoticeTitleCleared returns if the "notice_title" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) NoticeTitleCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldNoticeTitle]
	return ok
}

// ResetNoticeTitle resets all changes to the "notice_title" field.
func (m *AsMarketAppNoticeMutation) ResetNoticeTitle() {
	m.notice_title = nil
	delete(m.clearedFields, asmarketappnotice.FieldNoticeTitle)
}

// SetNoticeContent sets the "notice_content" field.
func (m *AsMarketAppNoticeMutation) SetNoticeContent(s string) {
	m.notice_content = &s
}

// NoticeContent returns the value of the "notice_content" field in the mutation.
func (m *AsMarketAppNoticeMutation) NoticeContent() (r string, exists bool) {
	v := m.notice_content
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeContent returns the old "notice_content" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldNoticeContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeContent: %w", err)
	}
	return oldValue.NoticeContent, nil
}

// ClearNoticeContent clears the value of the "notice_content" field.
func (m *AsMarketAppNoticeMutation) ClearNoticeContent() {
	m.notice_content = nil
	m.clearedFields[asmarketappnotice.FieldNoticeContent] = struct{}{}
}

// NoticeContentCleared returns if the "notice_content" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) NoticeContentCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldNoticeContent]
	return ok
}

// ResetNoticeContent resets all changes to the "notice_content" field.
func (m *AsMarketAppNoticeMutation) ResetNoticeContent() {
	m.notice_content = nil
	delete(m.clearedFields, asmarketappnotice.FieldNoticeContent)
}

// SetNoticeReleaseUnitID sets the "notice_release_unit_id" field.
func (m *AsMarketAppNoticeMutation) SetNoticeReleaseUnitID(i int64) {
	m.notice_release_unit_id = &i
	m.addnotice_release_unit_id = nil
}

// NoticeReleaseUnitID returns the value of the "notice_release_unit_id" field in the mutation.
func (m *AsMarketAppNoticeMutation) NoticeReleaseUnitID() (r int64, exists bool) {
	v := m.notice_release_unit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeReleaseUnitID returns the old "notice_release_unit_id" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldNoticeReleaseUnitID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeReleaseUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeReleaseUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeReleaseUnitID: %w", err)
	}
	return oldValue.NoticeReleaseUnitID, nil
}

// AddNoticeReleaseUnitID adds i to the "notice_release_unit_id" field.
func (m *AsMarketAppNoticeMutation) AddNoticeReleaseUnitID(i int64) {
	if m.addnotice_release_unit_id != nil {
		*m.addnotice_release_unit_id += i
	} else {
		m.addnotice_release_unit_id = &i
	}
}

// AddedNoticeReleaseUnitID returns the value that was added to the "notice_release_unit_id" field in this mutation.
func (m *AsMarketAppNoticeMutation) AddedNoticeReleaseUnitID() (r int64, exists bool) {
	v := m.addnotice_release_unit_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearNoticeReleaseUnitID clears the value of the "notice_release_unit_id" field.
func (m *AsMarketAppNoticeMutation) ClearNoticeReleaseUnitID() {
	m.notice_release_unit_id = nil
	m.addnotice_release_unit_id = nil
	m.clearedFields[asmarketappnotice.FieldNoticeReleaseUnitID] = struct{}{}
}

// NoticeReleaseUnitIDCleared returns if the "notice_release_unit_id" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) NoticeReleaseUnitIDCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldNoticeReleaseUnitID]
	return ok
}

// ResetNoticeReleaseUnitID resets all changes to the "notice_release_unit_id" field.
func (m *AsMarketAppNoticeMutation) ResetNoticeReleaseUnitID() {
	m.notice_release_unit_id = nil
	m.addnotice_release_unit_id = nil
	delete(m.clearedFields, asmarketappnotice.FieldNoticeReleaseUnitID)
}

// SetNoticeReleaseStatus sets the "notice_release_status" field.
func (m *AsMarketAppNoticeMutation) SetNoticeReleaseStatus(i int64) {
	m.notice_release_status = &i
	m.addnotice_release_status = nil
}

// NoticeReleaseStatus returns the value of the "notice_release_status" field in the mutation.
func (m *AsMarketAppNoticeMutation) NoticeReleaseStatus() (r int64, exists bool) {
	v := m.notice_release_status
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeReleaseStatus returns the old "notice_release_status" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldNoticeReleaseStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeReleaseStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeReleaseStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeReleaseStatus: %w", err)
	}
	return oldValue.NoticeReleaseStatus, nil
}

// AddNoticeReleaseStatus adds i to the "notice_release_status" field.
func (m *AsMarketAppNoticeMutation) AddNoticeReleaseStatus(i int64) {
	if m.addnotice_release_status != nil {
		*m.addnotice_release_status += i
	} else {
		m.addnotice_release_status = &i
	}
}

// AddedNoticeReleaseStatus returns the value that was added to the "notice_release_status" field in this mutation.
func (m *AsMarketAppNoticeMutation) AddedNoticeReleaseStatus() (r int64, exists bool) {
	v := m.addnotice_release_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetNoticeReleaseStatus resets all changes to the "notice_release_status" field.
func (m *AsMarketAppNoticeMutation) ResetNoticeReleaseStatus() {
	m.notice_release_status = nil
	m.addnotice_release_status = nil
}

// SetNoticeReleaseTime sets the "notice_release_time" field.
func (m *AsMarketAppNoticeMutation) SetNoticeReleaseTime(dt date.DateTime) {
	m.notice_release_time = &dt
}

// NoticeReleaseTime returns the value of the "notice_release_time" field in the mutation.
func (m *AsMarketAppNoticeMutation) NoticeReleaseTime() (r date.DateTime, exists bool) {
	v := m.notice_release_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeReleaseTime returns the old "notice_release_time" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldNoticeReleaseTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeReleaseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeReleaseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeReleaseTime: %w", err)
	}
	return oldValue.NoticeReleaseTime, nil
}

// ClearNoticeReleaseTime clears the value of the "notice_release_time" field.
func (m *AsMarketAppNoticeMutation) ClearNoticeReleaseTime() {
	m.notice_release_time = nil
	m.clearedFields[asmarketappnotice.FieldNoticeReleaseTime] = struct{}{}
}

// NoticeReleaseTimeCleared returns if the "notice_release_time" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) NoticeReleaseTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldNoticeReleaseTime]
	return ok
}

// ResetNoticeReleaseTime resets all changes to the "notice_release_time" field.
func (m *AsMarketAppNoticeMutation) ResetNoticeReleaseTime() {
	m.notice_release_time = nil
	delete(m.clearedFields, asmarketappnotice.FieldNoticeReleaseTime)
}

// SetNoticeRoleIds sets the "notice_role_ids" field.
func (m *AsMarketAppNoticeMutation) SetNoticeRoleIds(s string) {
	m.notice_role_ids = &s
}

// NoticeRoleIds returns the value of the "notice_role_ids" field in the mutation.
func (m *AsMarketAppNoticeMutation) NoticeRoleIds() (r string, exists bool) {
	v := m.notice_role_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeRoleIds returns the old "notice_role_ids" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldNoticeRoleIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeRoleIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeRoleIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeRoleIds: %w", err)
	}
	return oldValue.NoticeRoleIds, nil
}

// ClearNoticeRoleIds clears the value of the "notice_role_ids" field.
func (m *AsMarketAppNoticeMutation) ClearNoticeRoleIds() {
	m.notice_role_ids = nil
	m.clearedFields[asmarketappnotice.FieldNoticeRoleIds] = struct{}{}
}

// NoticeRoleIdsCleared returns if the "notice_role_ids" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) NoticeRoleIdsCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldNoticeRoleIds]
	return ok
}

// ResetNoticeRoleIds resets all changes to the "notice_role_ids" field.
func (m *AsMarketAppNoticeMutation) ResetNoticeRoleIds() {
	m.notice_role_ids = nil
	delete(m.clearedFields, asmarketappnotice.FieldNoticeRoleIds)
}

// SetNoticeUnitIds sets the "notice_unit_ids" field.
func (m *AsMarketAppNoticeMutation) SetNoticeUnitIds(s string) {
	m.notice_unit_ids = &s
}

// NoticeUnitIds returns the value of the "notice_unit_ids" field in the mutation.
func (m *AsMarketAppNoticeMutation) NoticeUnitIds() (r string, exists bool) {
	v := m.notice_unit_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeUnitIds returns the old "notice_unit_ids" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldNoticeUnitIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeUnitIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeUnitIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeUnitIds: %w", err)
	}
	return oldValue.NoticeUnitIds, nil
}

// ClearNoticeUnitIds clears the value of the "notice_unit_ids" field.
func (m *AsMarketAppNoticeMutation) ClearNoticeUnitIds() {
	m.notice_unit_ids = nil
	m.clearedFields[asmarketappnotice.FieldNoticeUnitIds] = struct{}{}
}

// NoticeUnitIdsCleared returns if the "notice_unit_ids" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) NoticeUnitIdsCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldNoticeUnitIds]
	return ok
}

// ResetNoticeUnitIds resets all changes to the "notice_unit_ids" field.
func (m *AsMarketAppNoticeMutation) ResetNoticeUnitIds() {
	m.notice_unit_ids = nil
	delete(m.clearedFields, asmarketappnotice.FieldNoticeUnitIds)
}

// SetGroupOrUnit sets the "group_or_unit" field.
func (m *AsMarketAppNoticeMutation) SetGroupOrUnit(i int64) {
	m.group_or_unit = &i
	m.addgroup_or_unit = nil
}

// GroupOrUnit returns the value of the "group_or_unit" field in the mutation.
func (m *AsMarketAppNoticeMutation) GroupOrUnit() (r int64, exists bool) {
	v := m.group_or_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupOrUnit returns the old "group_or_unit" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldGroupOrUnit(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupOrUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupOrUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupOrUnit: %w", err)
	}
	return oldValue.GroupOrUnit, nil
}

// AddGroupOrUnit adds i to the "group_or_unit" field.
func (m *AsMarketAppNoticeMutation) AddGroupOrUnit(i int64) {
	if m.addgroup_or_unit != nil {
		*m.addgroup_or_unit += i
	} else {
		m.addgroup_or_unit = &i
	}
}

// AddedGroupOrUnit returns the value that was added to the "group_or_unit" field in this mutation.
func (m *AsMarketAppNoticeMutation) AddedGroupOrUnit() (r int64, exists bool) {
	v := m.addgroup_or_unit
	if v == nil {
		return
	}
	return *v, true
}

// ClearGroupOrUnit clears the value of the "group_or_unit" field.
func (m *AsMarketAppNoticeMutation) ClearGroupOrUnit() {
	m.group_or_unit = nil
	m.addgroup_or_unit = nil
	m.clearedFields[asmarketappnotice.FieldGroupOrUnit] = struct{}{}
}

// GroupOrUnitCleared returns if the "group_or_unit" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) GroupOrUnitCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldGroupOrUnit]
	return ok
}

// ResetGroupOrUnit resets all changes to the "group_or_unit" field.
func (m *AsMarketAppNoticeMutation) ResetGroupOrUnit() {
	m.group_or_unit = nil
	m.addgroup_or_unit = nil
	delete(m.clearedFields, asmarketappnotice.FieldGroupOrUnit)
}

// SetUnitQueryIds sets the "unit_query_ids" field.
func (m *AsMarketAppNoticeMutation) SetUnitQueryIds(s string) {
	m.unit_query_ids = &s
}

// UnitQueryIds returns the value of the "unit_query_ids" field in the mutation.
func (m *AsMarketAppNoticeMutation) UnitQueryIds() (r string, exists bool) {
	v := m.unit_query_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitQueryIds returns the old "unit_query_ids" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldUnitQueryIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitQueryIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitQueryIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitQueryIds: %w", err)
	}
	return oldValue.UnitQueryIds, nil
}

// ClearUnitQueryIds clears the value of the "unit_query_ids" field.
func (m *AsMarketAppNoticeMutation) ClearUnitQueryIds() {
	m.unit_query_ids = nil
	m.clearedFields[asmarketappnotice.FieldUnitQueryIds] = struct{}{}
}

// UnitQueryIdsCleared returns if the "unit_query_ids" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) UnitQueryIdsCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldUnitQueryIds]
	return ok
}

// ResetUnitQueryIds resets all changes to the "unit_query_ids" field.
func (m *AsMarketAppNoticeMutation) ResetUnitQueryIds() {
	m.unit_query_ids = nil
	delete(m.clearedFields, asmarketappnotice.FieldUnitQueryIds)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppNoticeMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppNoticeMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppNoticeMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppNoticeMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppNoticeMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppNoticeMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppNoticeMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppNoticeMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppNoticeMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppNoticeMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketappnotice.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppNoticeMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketappnotice.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppNoticeMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppNoticeMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppNoticeMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppNoticeMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppNoticeMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketappnotice.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppNoticeMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketappnotice.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppNoticeMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppNoticeMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppNoticeMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppNoticeMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppNoticeMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketappnotice.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppNoticeMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketappnotice.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppNoticeMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppNoticeMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppNoticeMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketappnotice.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppNoticeMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketappnotice.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppNoticeMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppNoticeMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketAppNotice entity.
// If the AsMarketAppNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppNoticeMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppNoticeMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketappnotice.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappnotice.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppNoticeMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketappnotice.FieldUpdateTime)
}

// Where appends a list predicates to the AsMarketAppNoticeMutation builder.
func (m *AsMarketAppNoticeMutation) Where(ps ...predicate.AsMarketAppNotice) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppNoticeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketAppNotice).
func (m *AsMarketAppNoticeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppNoticeMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.notice_title != nil {
		fields = append(fields, asmarketappnotice.FieldNoticeTitle)
	}
	if m.notice_content != nil {
		fields = append(fields, asmarketappnotice.FieldNoticeContent)
	}
	if m.notice_release_unit_id != nil {
		fields = append(fields, asmarketappnotice.FieldNoticeReleaseUnitID)
	}
	if m.notice_release_status != nil {
		fields = append(fields, asmarketappnotice.FieldNoticeReleaseStatus)
	}
	if m.notice_release_time != nil {
		fields = append(fields, asmarketappnotice.FieldNoticeReleaseTime)
	}
	if m.notice_role_ids != nil {
		fields = append(fields, asmarketappnotice.FieldNoticeRoleIds)
	}
	if m.notice_unit_ids != nil {
		fields = append(fields, asmarketappnotice.FieldNoticeUnitIds)
	}
	if m.group_or_unit != nil {
		fields = append(fields, asmarketappnotice.FieldGroupOrUnit)
	}
	if m.unit_query_ids != nil {
		fields = append(fields, asmarketappnotice.FieldUnitQueryIds)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketappnotice.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketappnotice.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketappnotice.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketappnotice.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketappnotice.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketappnotice.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppNoticeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketappnotice.FieldNoticeTitle:
		return m.NoticeTitle()
	case asmarketappnotice.FieldNoticeContent:
		return m.NoticeContent()
	case asmarketappnotice.FieldNoticeReleaseUnitID:
		return m.NoticeReleaseUnitID()
	case asmarketappnotice.FieldNoticeReleaseStatus:
		return m.NoticeReleaseStatus()
	case asmarketappnotice.FieldNoticeReleaseTime:
		return m.NoticeReleaseTime()
	case asmarketappnotice.FieldNoticeRoleIds:
		return m.NoticeRoleIds()
	case asmarketappnotice.FieldNoticeUnitIds:
		return m.NoticeUnitIds()
	case asmarketappnotice.FieldGroupOrUnit:
		return m.GroupOrUnit()
	case asmarketappnotice.FieldUnitQueryIds:
		return m.UnitQueryIds()
	case asmarketappnotice.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketappnotice.FieldStatus:
		return m.Status()
	case asmarketappnotice.FieldCreateUser:
		return m.CreateUser()
	case asmarketappnotice.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketappnotice.FieldCreateTime:
		return m.CreateTime()
	case asmarketappnotice.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppNoticeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketappnotice.FieldNoticeTitle:
		return m.OldNoticeTitle(ctx)
	case asmarketappnotice.FieldNoticeContent:
		return m.OldNoticeContent(ctx)
	case asmarketappnotice.FieldNoticeReleaseUnitID:
		return m.OldNoticeReleaseUnitID(ctx)
	case asmarketappnotice.FieldNoticeReleaseStatus:
		return m.OldNoticeReleaseStatus(ctx)
	case asmarketappnotice.FieldNoticeReleaseTime:
		return m.OldNoticeReleaseTime(ctx)
	case asmarketappnotice.FieldNoticeRoleIds:
		return m.OldNoticeRoleIds(ctx)
	case asmarketappnotice.FieldNoticeUnitIds:
		return m.OldNoticeUnitIds(ctx)
	case asmarketappnotice.FieldGroupOrUnit:
		return m.OldGroupOrUnit(ctx)
	case asmarketappnotice.FieldUnitQueryIds:
		return m.OldUnitQueryIds(ctx)
	case asmarketappnotice.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketappnotice.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketappnotice.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketappnotice.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketappnotice.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketappnotice.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketAppNotice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppNoticeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketappnotice.FieldNoticeTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeTitle(v)
		return nil
	case asmarketappnotice.FieldNoticeContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeContent(v)
		return nil
	case asmarketappnotice.FieldNoticeReleaseUnitID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeReleaseUnitID(v)
		return nil
	case asmarketappnotice.FieldNoticeReleaseStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeReleaseStatus(v)
		return nil
	case asmarketappnotice.FieldNoticeReleaseTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeReleaseTime(v)
		return nil
	case asmarketappnotice.FieldNoticeRoleIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeRoleIds(v)
		return nil
	case asmarketappnotice.FieldNoticeUnitIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeUnitIds(v)
		return nil
	case asmarketappnotice.FieldGroupOrUnit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupOrUnit(v)
		return nil
	case asmarketappnotice.FieldUnitQueryIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitQueryIds(v)
		return nil
	case asmarketappnotice.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketappnotice.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketappnotice.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketappnotice.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketappnotice.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketappnotice.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppNotice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppNoticeMutation) AddedFields() []string {
	var fields []string
	if m.addnotice_release_unit_id != nil {
		fields = append(fields, asmarketappnotice.FieldNoticeReleaseUnitID)
	}
	if m.addnotice_release_status != nil {
		fields = append(fields, asmarketappnotice.FieldNoticeReleaseStatus)
	}
	if m.addgroup_or_unit != nil {
		fields = append(fields, asmarketappnotice.FieldGroupOrUnit)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketappnotice.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketappnotice.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketappnotice.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketappnotice.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppNoticeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketappnotice.FieldNoticeReleaseUnitID:
		return m.AddedNoticeReleaseUnitID()
	case asmarketappnotice.FieldNoticeReleaseStatus:
		return m.AddedNoticeReleaseStatus()
	case asmarketappnotice.FieldGroupOrUnit:
		return m.AddedGroupOrUnit()
	case asmarketappnotice.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketappnotice.FieldStatus:
		return m.AddedStatus()
	case asmarketappnotice.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketappnotice.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppNoticeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketappnotice.FieldNoticeReleaseUnitID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNoticeReleaseUnitID(v)
		return nil
	case asmarketappnotice.FieldNoticeReleaseStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNoticeReleaseStatus(v)
		return nil
	case asmarketappnotice.FieldGroupOrUnit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupOrUnit(v)
		return nil
	case asmarketappnotice.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketappnotice.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketappnotice.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketappnotice.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppNotice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppNoticeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketappnotice.FieldNoticeTitle) {
		fields = append(fields, asmarketappnotice.FieldNoticeTitle)
	}
	if m.FieldCleared(asmarketappnotice.FieldNoticeContent) {
		fields = append(fields, asmarketappnotice.FieldNoticeContent)
	}
	if m.FieldCleared(asmarketappnotice.FieldNoticeReleaseUnitID) {
		fields = append(fields, asmarketappnotice.FieldNoticeReleaseUnitID)
	}
	if m.FieldCleared(asmarketappnotice.FieldNoticeReleaseTime) {
		fields = append(fields, asmarketappnotice.FieldNoticeReleaseTime)
	}
	if m.FieldCleared(asmarketappnotice.FieldNoticeRoleIds) {
		fields = append(fields, asmarketappnotice.FieldNoticeRoleIds)
	}
	if m.FieldCleared(asmarketappnotice.FieldNoticeUnitIds) {
		fields = append(fields, asmarketappnotice.FieldNoticeUnitIds)
	}
	if m.FieldCleared(asmarketappnotice.FieldGroupOrUnit) {
		fields = append(fields, asmarketappnotice.FieldGroupOrUnit)
	}
	if m.FieldCleared(asmarketappnotice.FieldUnitQueryIds) {
		fields = append(fields, asmarketappnotice.FieldUnitQueryIds)
	}
	if m.FieldCleared(asmarketappnotice.FieldStatus) {
		fields = append(fields, asmarketappnotice.FieldStatus)
	}
	if m.FieldCleared(asmarketappnotice.FieldCreateUser) {
		fields = append(fields, asmarketappnotice.FieldCreateUser)
	}
	if m.FieldCleared(asmarketappnotice.FieldUpdateUser) {
		fields = append(fields, asmarketappnotice.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketappnotice.FieldCreateTime) {
		fields = append(fields, asmarketappnotice.FieldCreateTime)
	}
	if m.FieldCleared(asmarketappnotice.FieldUpdateTime) {
		fields = append(fields, asmarketappnotice.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppNoticeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppNoticeMutation) ClearField(name string) error {
	switch name {
	case asmarketappnotice.FieldNoticeTitle:
		m.ClearNoticeTitle()
		return nil
	case asmarketappnotice.FieldNoticeContent:
		m.ClearNoticeContent()
		return nil
	case asmarketappnotice.FieldNoticeReleaseUnitID:
		m.ClearNoticeReleaseUnitID()
		return nil
	case asmarketappnotice.FieldNoticeReleaseTime:
		m.ClearNoticeReleaseTime()
		return nil
	case asmarketappnotice.FieldNoticeRoleIds:
		m.ClearNoticeRoleIds()
		return nil
	case asmarketappnotice.FieldNoticeUnitIds:
		m.ClearNoticeUnitIds()
		return nil
	case asmarketappnotice.FieldGroupOrUnit:
		m.ClearGroupOrUnit()
		return nil
	case asmarketappnotice.FieldUnitQueryIds:
		m.ClearUnitQueryIds()
		return nil
	case asmarketappnotice.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketappnotice.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketappnotice.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketappnotice.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketappnotice.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppNotice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppNoticeMutation) ResetField(name string) error {
	switch name {
	case asmarketappnotice.FieldNoticeTitle:
		m.ResetNoticeTitle()
		return nil
	case asmarketappnotice.FieldNoticeContent:
		m.ResetNoticeContent()
		return nil
	case asmarketappnotice.FieldNoticeReleaseUnitID:
		m.ResetNoticeReleaseUnitID()
		return nil
	case asmarketappnotice.FieldNoticeReleaseStatus:
		m.ResetNoticeReleaseStatus()
		return nil
	case asmarketappnotice.FieldNoticeReleaseTime:
		m.ResetNoticeReleaseTime()
		return nil
	case asmarketappnotice.FieldNoticeRoleIds:
		m.ResetNoticeRoleIds()
		return nil
	case asmarketappnotice.FieldNoticeUnitIds:
		m.ResetNoticeUnitIds()
		return nil
	case asmarketappnotice.FieldGroupOrUnit:
		m.ResetGroupOrUnit()
		return nil
	case asmarketappnotice.FieldUnitQueryIds:
		m.ResetUnitQueryIds()
		return nil
	case asmarketappnotice.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketappnotice.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketappnotice.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketappnotice.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketappnotice.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketappnotice.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppNotice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppNoticeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppNoticeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppNoticeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppNoticeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppNoticeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppNoticeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppNoticeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AsMarketAppNotice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppNoticeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AsMarketAppNotice edge %s", name)
}

// AsMarketAppPurchaseMutation represents an operation that mutates the AsMarketAppPurchase nodes in the graph.
type AsMarketAppPurchaseMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	tenant_id      *string
	use_status     *int64
	adduse_status  *int64
	remark         *string
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	appx           *int64
	clearedappx    bool
	groupx         *int64
	clearedgroupx  bool
	done           bool
	oldValue       func(context.Context) (*AsMarketAppPurchase, error)
	predicates     []predicate.AsMarketAppPurchase
}

var _ ent.Mutation = (*AsMarketAppPurchaseMutation)(nil)

// asmarketapppurchaseOption allows management of the mutation configuration using functional options.
type asmarketapppurchaseOption func(*AsMarketAppPurchaseMutation)

// newAsMarketAppPurchaseMutation creates new mutation for the AsMarketAppPurchase entity.
func newAsMarketAppPurchaseMutation(c config, op Op, opts ...asmarketapppurchaseOption) *AsMarketAppPurchaseMutation {
	m := &AsMarketAppPurchaseMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketAppPurchase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppPurchaseID sets the ID field of the mutation.
func withAsMarketAppPurchaseID(id int64) asmarketapppurchaseOption {
	return func(m *AsMarketAppPurchaseMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketAppPurchase
		)
		m.oldValue = func(ctx context.Context) (*AsMarketAppPurchase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketAppPurchase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketAppPurchase sets the old AsMarketAppPurchase of the mutation.
func withAsMarketAppPurchase(node *AsMarketAppPurchase) asmarketapppurchaseOption {
	return func(m *AsMarketAppPurchaseMutation) {
		m.oldValue = func(context.Context) (*AsMarketAppPurchase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppPurchaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppPurchaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketAppPurchase entities.
func (m *AsMarketAppPurchaseMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppPurchaseMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppPurchaseMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketAppPurchase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AsMarketAppPurchaseMutation) SetAppID(i int64) {
	m.appx = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsMarketAppPurchaseMutation) AppID() (r int64, exists bool) {
	v := m.appx
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AsMarketAppPurchaseMutation) ClearAppID() {
	m.appx = nil
	m.clearedFields[asmarketapppurchase.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[asmarketapppurchase.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsMarketAppPurchaseMutation) ResetAppID() {
	m.appx = nil
	delete(m.clearedFields, asmarketapppurchase.FieldAppID)
}

// SetTenantID sets the "tenant_id" field.
func (m *AsMarketAppPurchaseMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AsMarketAppPurchaseMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AsMarketAppPurchaseMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[asmarketapppurchase.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[asmarketapppurchase.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AsMarketAppPurchaseMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, asmarketapppurchase.FieldTenantID)
}

// SetGroupID sets the "group_id" field.
func (m *AsMarketAppPurchaseMutation) SetGroupID(i int64) {
	m.groupx = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *AsMarketAppPurchaseMutation) GroupID() (r int64, exists bool) {
	v := m.groupx
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *AsMarketAppPurchaseMutation) ClearGroupID() {
	m.groupx = nil
	m.clearedFields[asmarketapppurchase.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[asmarketapppurchase.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *AsMarketAppPurchaseMutation) ResetGroupID() {
	m.groupx = nil
	delete(m.clearedFields, asmarketapppurchase.FieldGroupID)
}

// SetUseStatus sets the "use_status" field.
func (m *AsMarketAppPurchaseMutation) SetUseStatus(i int64) {
	m.use_status = &i
	m.adduse_status = nil
}

// UseStatus returns the value of the "use_status" field in the mutation.
func (m *AsMarketAppPurchaseMutation) UseStatus() (r int64, exists bool) {
	v := m.use_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUseStatus returns the old "use_status" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldUseStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseStatus: %w", err)
	}
	return oldValue.UseStatus, nil
}

// AddUseStatus adds i to the "use_status" field.
func (m *AsMarketAppPurchaseMutation) AddUseStatus(i int64) {
	if m.adduse_status != nil {
		*m.adduse_status += i
	} else {
		m.adduse_status = &i
	}
}

// AddedUseStatus returns the value that was added to the "use_status" field in this mutation.
func (m *AsMarketAppPurchaseMutation) AddedUseStatus() (r int64, exists bool) {
	v := m.adduse_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearUseStatus clears the value of the "use_status" field.
func (m *AsMarketAppPurchaseMutation) ClearUseStatus() {
	m.use_status = nil
	m.adduse_status = nil
	m.clearedFields[asmarketapppurchase.FieldUseStatus] = struct{}{}
}

// UseStatusCleared returns if the "use_status" field was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) UseStatusCleared() bool {
	_, ok := m.clearedFields[asmarketapppurchase.FieldUseStatus]
	return ok
}

// ResetUseStatus resets all changes to the "use_status" field.
func (m *AsMarketAppPurchaseMutation) ResetUseStatus() {
	m.use_status = nil
	m.adduse_status = nil
	delete(m.clearedFields, asmarketapppurchase.FieldUseStatus)
}

// SetRemark sets the "remark" field.
func (m *AsMarketAppPurchaseMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AsMarketAppPurchaseMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AsMarketAppPurchaseMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[asmarketapppurchase.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[asmarketapppurchase.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AsMarketAppPurchaseMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, asmarketapppurchase.FieldRemark)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppPurchaseMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppPurchaseMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppPurchaseMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppPurchaseMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppPurchaseMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppPurchaseMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppPurchaseMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppPurchaseMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppPurchaseMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppPurchaseMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketapppurchase.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketapppurchase.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppPurchaseMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketapppurchase.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppPurchaseMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppPurchaseMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppPurchaseMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppPurchaseMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppPurchaseMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketapppurchase.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketapppurchase.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppPurchaseMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketapppurchase.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppPurchaseMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppPurchaseMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppPurchaseMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppPurchaseMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppPurchaseMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketapppurchase.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketapppurchase.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppPurchaseMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketapppurchase.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppPurchaseMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppPurchaseMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppPurchaseMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketapppurchase.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketapppurchase.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppPurchaseMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketapppurchase.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppPurchaseMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppPurchaseMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketAppPurchase entity.
// If the AsMarketAppPurchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppPurchaseMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppPurchaseMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketapppurchase.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketapppurchase.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppPurchaseMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketapppurchase.FieldUpdateTime)
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsMarketAppPurchaseMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsMarketAppPurchaseMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsMarketAppPurchaseMutation) AppxCleared() bool {
	return m.AppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsMarketAppPurchaseMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppPurchaseMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsMarketAppPurchaseMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// SetGroupxID sets the "groupx" edge to the AsAllGroup entity by id.
func (m *AsMarketAppPurchaseMutation) SetGroupxID(id int64) {
	m.groupx = &id
}

// ClearGroupx clears the "groupx" edge to the AsAllGroup entity.
func (m *AsMarketAppPurchaseMutation) ClearGroupx() {
	m.clearedgroupx = true
}

// GroupxCleared reports if the "groupx" edge to the AsAllGroup entity was cleared.
func (m *AsMarketAppPurchaseMutation) GroupxCleared() bool {
	return m.GroupIDCleared() || m.clearedgroupx
}

// GroupxID returns the "groupx" edge ID in the mutation.
func (m *AsMarketAppPurchaseMutation) GroupxID() (id int64, exists bool) {
	if m.groupx != nil {
		return *m.groupx, true
	}
	return
}

// GroupxIDs returns the "groupx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppPurchaseMutation) GroupxIDs() (ids []int64) {
	if id := m.groupx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupx resets all changes to the "groupx" edge.
func (m *AsMarketAppPurchaseMutation) ResetGroupx() {
	m.groupx = nil
	m.clearedgroupx = false
}

// Where appends a list predicates to the AsMarketAppPurchaseMutation builder.
func (m *AsMarketAppPurchaseMutation) Where(ps ...predicate.AsMarketAppPurchase) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppPurchaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketAppPurchase).
func (m *AsMarketAppPurchaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppPurchaseMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.appx != nil {
		fields = append(fields, asmarketapppurchase.FieldAppID)
	}
	if m.tenant_id != nil {
		fields = append(fields, asmarketapppurchase.FieldTenantID)
	}
	if m.groupx != nil {
		fields = append(fields, asmarketapppurchase.FieldGroupID)
	}
	if m.use_status != nil {
		fields = append(fields, asmarketapppurchase.FieldUseStatus)
	}
	if m.remark != nil {
		fields = append(fields, asmarketapppurchase.FieldRemark)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketapppurchase.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketapppurchase.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketapppurchase.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketapppurchase.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketapppurchase.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketapppurchase.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppPurchaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketapppurchase.FieldAppID:
		return m.AppID()
	case asmarketapppurchase.FieldTenantID:
		return m.TenantID()
	case asmarketapppurchase.FieldGroupID:
		return m.GroupID()
	case asmarketapppurchase.FieldUseStatus:
		return m.UseStatus()
	case asmarketapppurchase.FieldRemark:
		return m.Remark()
	case asmarketapppurchase.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketapppurchase.FieldStatus:
		return m.Status()
	case asmarketapppurchase.FieldCreateUser:
		return m.CreateUser()
	case asmarketapppurchase.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketapppurchase.FieldCreateTime:
		return m.CreateTime()
	case asmarketapppurchase.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppPurchaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketapppurchase.FieldAppID:
		return m.OldAppID(ctx)
	case asmarketapppurchase.FieldTenantID:
		return m.OldTenantID(ctx)
	case asmarketapppurchase.FieldGroupID:
		return m.OldGroupID(ctx)
	case asmarketapppurchase.FieldUseStatus:
		return m.OldUseStatus(ctx)
	case asmarketapppurchase.FieldRemark:
		return m.OldRemark(ctx)
	case asmarketapppurchase.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketapppurchase.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketapppurchase.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketapppurchase.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketapppurchase.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketapppurchase.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketAppPurchase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppPurchaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketapppurchase.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asmarketapppurchase.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case asmarketapppurchase.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case asmarketapppurchase.FieldUseStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseStatus(v)
		return nil
	case asmarketapppurchase.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case asmarketapppurchase.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketapppurchase.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketapppurchase.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketapppurchase.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketapppurchase.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketapppurchase.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppPurchase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppPurchaseMutation) AddedFields() []string {
	var fields []string
	if m.adduse_status != nil {
		fields = append(fields, asmarketapppurchase.FieldUseStatus)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketapppurchase.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketapppurchase.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketapppurchase.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketapppurchase.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppPurchaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketapppurchase.FieldUseStatus:
		return m.AddedUseStatus()
	case asmarketapppurchase.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketapppurchase.FieldStatus:
		return m.AddedStatus()
	case asmarketapppurchase.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketapppurchase.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppPurchaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketapppurchase.FieldUseStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseStatus(v)
		return nil
	case asmarketapppurchase.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketapppurchase.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketapppurchase.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketapppurchase.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppPurchase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppPurchaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketapppurchase.FieldAppID) {
		fields = append(fields, asmarketapppurchase.FieldAppID)
	}
	if m.FieldCleared(asmarketapppurchase.FieldTenantID) {
		fields = append(fields, asmarketapppurchase.FieldTenantID)
	}
	if m.FieldCleared(asmarketapppurchase.FieldGroupID) {
		fields = append(fields, asmarketapppurchase.FieldGroupID)
	}
	if m.FieldCleared(asmarketapppurchase.FieldUseStatus) {
		fields = append(fields, asmarketapppurchase.FieldUseStatus)
	}
	if m.FieldCleared(asmarketapppurchase.FieldRemark) {
		fields = append(fields, asmarketapppurchase.FieldRemark)
	}
	if m.FieldCleared(asmarketapppurchase.FieldStatus) {
		fields = append(fields, asmarketapppurchase.FieldStatus)
	}
	if m.FieldCleared(asmarketapppurchase.FieldCreateUser) {
		fields = append(fields, asmarketapppurchase.FieldCreateUser)
	}
	if m.FieldCleared(asmarketapppurchase.FieldUpdateUser) {
		fields = append(fields, asmarketapppurchase.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketapppurchase.FieldCreateTime) {
		fields = append(fields, asmarketapppurchase.FieldCreateTime)
	}
	if m.FieldCleared(asmarketapppurchase.FieldUpdateTime) {
		fields = append(fields, asmarketapppurchase.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppPurchaseMutation) ClearField(name string) error {
	switch name {
	case asmarketapppurchase.FieldAppID:
		m.ClearAppID()
		return nil
	case asmarketapppurchase.FieldTenantID:
		m.ClearTenantID()
		return nil
	case asmarketapppurchase.FieldGroupID:
		m.ClearGroupID()
		return nil
	case asmarketapppurchase.FieldUseStatus:
		m.ClearUseStatus()
		return nil
	case asmarketapppurchase.FieldRemark:
		m.ClearRemark()
		return nil
	case asmarketapppurchase.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketapppurchase.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketapppurchase.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketapppurchase.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketapppurchase.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppPurchase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppPurchaseMutation) ResetField(name string) error {
	switch name {
	case asmarketapppurchase.FieldAppID:
		m.ResetAppID()
		return nil
	case asmarketapppurchase.FieldTenantID:
		m.ResetTenantID()
		return nil
	case asmarketapppurchase.FieldGroupID:
		m.ResetGroupID()
		return nil
	case asmarketapppurchase.FieldUseStatus:
		m.ResetUseStatus()
		return nil
	case asmarketapppurchase.FieldRemark:
		m.ResetRemark()
		return nil
	case asmarketapppurchase.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketapppurchase.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketapppurchase.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketapppurchase.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketapppurchase.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketapppurchase.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppPurchase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppPurchaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.appx != nil {
		edges = append(edges, asmarketapppurchase.EdgeAppx)
	}
	if m.groupx != nil {
		edges = append(edges, asmarketapppurchase.EdgeGroupx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppPurchaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketapppurchase.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	case asmarketapppurchase.EdgeGroupx:
		if id := m.groupx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppPurchaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppPurchaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedappx {
		edges = append(edges, asmarketapppurchase.EdgeAppx)
	}
	if m.clearedgroupx {
		edges = append(edges, asmarketapppurchase.EdgeGroupx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppPurchaseMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketapppurchase.EdgeAppx:
		return m.clearedappx
	case asmarketapppurchase.EdgeGroupx:
		return m.clearedgroupx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppPurchaseMutation) ClearEdge(name string) error {
	switch name {
	case asmarketapppurchase.EdgeAppx:
		m.ClearAppx()
		return nil
	case asmarketapppurchase.EdgeGroupx:
		m.ClearGroupx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppPurchase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppPurchaseMutation) ResetEdge(name string) error {
	switch name {
	case asmarketapppurchase.EdgeAppx:
		m.ResetAppx()
		return nil
	case asmarketapppurchase.EdgeGroupx:
		m.ResetGroupx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppPurchase edge %s", name)
}

// AsMarketAppRoleMutation represents an operation that mutates the AsMarketAppRole nodes in the graph.
type AsMarketAppRoleMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	role_name           *string
	is_deleted          *int64
	addis_deleted       *int64
	status              *int64
	addstatus           *int64
	create_user         *int64
	addcreate_user      *int64
	update_user         *int64
	addupdate_user      *int64
	create_time         *date.DateTime
	update_time         *date.DateTime
	clearedFields       map[string]struct{}
	roleDistribs        map[int64]struct{}
	removedroleDistribs map[int64]struct{}
	clearedroleDistribs bool
	roleMenus           map[int64]struct{}
	removedroleMenus    map[int64]struct{}
	clearedroleMenus    bool
	menus               map[int64]struct{}
	removedmenus        map[int64]struct{}
	clearedmenus        bool
	appx                *int64
	clearedappx         bool
	done                bool
	oldValue            func(context.Context) (*AsMarketAppRole, error)
	predicates          []predicate.AsMarketAppRole
}

var _ ent.Mutation = (*AsMarketAppRoleMutation)(nil)

// asmarketapproleOption allows management of the mutation configuration using functional options.
type asmarketapproleOption func(*AsMarketAppRoleMutation)

// newAsMarketAppRoleMutation creates new mutation for the AsMarketAppRole entity.
func newAsMarketAppRoleMutation(c config, op Op, opts ...asmarketapproleOption) *AsMarketAppRoleMutation {
	m := &AsMarketAppRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketAppRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppRoleID sets the ID field of the mutation.
func withAsMarketAppRoleID(id int64) asmarketapproleOption {
	return func(m *AsMarketAppRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketAppRole
		)
		m.oldValue = func(ctx context.Context) (*AsMarketAppRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketAppRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketAppRole sets the old AsMarketAppRole of the mutation.
func withAsMarketAppRole(node *AsMarketAppRole) asmarketapproleOption {
	return func(m *AsMarketAppRoleMutation) {
		m.oldValue = func(context.Context) (*AsMarketAppRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketAppRole entities.
func (m *AsMarketAppRoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppRoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppRoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketAppRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleName sets the "role_name" field.
func (m *AsMarketAppRoleMutation) SetRoleName(s string) {
	m.role_name = &s
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *AsMarketAppRoleMutation) RoleName() (r string, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the AsMarketAppRole entity.
// If the AsMarketAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppRoleMutation) OldRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ClearRoleName clears the value of the "role_name" field.
func (m *AsMarketAppRoleMutation) ClearRoleName() {
	m.role_name = nil
	m.clearedFields[asmarketapprole.FieldRoleName] = struct{}{}
}

// RoleNameCleared returns if the "role_name" field was cleared in this mutation.
func (m *AsMarketAppRoleMutation) RoleNameCleared() bool {
	_, ok := m.clearedFields[asmarketapprole.FieldRoleName]
	return ok
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *AsMarketAppRoleMutation) ResetRoleName() {
	m.role_name = nil
	delete(m.clearedFields, asmarketapprole.FieldRoleName)
}

// SetAppID sets the "app_id" field.
func (m *AsMarketAppRoleMutation) SetAppID(i int64) {
	m.appx = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsMarketAppRoleMutation) AppID() (r int64, exists bool) {
	v := m.appx
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsMarketAppRole entity.
// If the AsMarketAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppRoleMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AsMarketAppRoleMutation) ClearAppID() {
	m.appx = nil
	m.clearedFields[asmarketapprole.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AsMarketAppRoleMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[asmarketapprole.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsMarketAppRoleMutation) ResetAppID() {
	m.appx = nil
	delete(m.clearedFields, asmarketapprole.FieldAppID)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppRoleMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppRoleMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketAppRole entity.
// If the AsMarketAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppRoleMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppRoleMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppRoleMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppRoleMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppRoleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppRoleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketAppRole entity.
// If the AsMarketAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppRoleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppRoleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppRoleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppRoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketapprole.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppRoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketapprole.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppRoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketapprole.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppRoleMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppRoleMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketAppRole entity.
// If the AsMarketAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppRoleMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppRoleMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppRoleMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppRoleMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketapprole.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppRoleMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketapprole.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppRoleMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketapprole.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppRoleMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppRoleMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketAppRole entity.
// If the AsMarketAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppRoleMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppRoleMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppRoleMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppRoleMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketapprole.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppRoleMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketapprole.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppRoleMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketapprole.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppRoleMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppRoleMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketAppRole entity.
// If the AsMarketAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppRoleMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppRoleMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketapprole.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppRoleMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketapprole.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppRoleMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketapprole.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppRoleMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppRoleMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketAppRole entity.
// If the AsMarketAppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppRoleMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppRoleMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketapprole.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppRoleMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketapprole.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppRoleMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketapprole.FieldUpdateTime)
}

// AddRoleDistribIDs adds the "roleDistribs" edge to the AsMarketRoleDistribution entity by ids.
func (m *AsMarketAppRoleMutation) AddRoleDistribIDs(ids ...int64) {
	if m.roleDistribs == nil {
		m.roleDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		m.roleDistribs[ids[i]] = struct{}{}
	}
}

// ClearRoleDistribs clears the "roleDistribs" edge to the AsMarketRoleDistribution entity.
func (m *AsMarketAppRoleMutation) ClearRoleDistribs() {
	m.clearedroleDistribs = true
}

// RoleDistribsCleared reports if the "roleDistribs" edge to the AsMarketRoleDistribution entity was cleared.
func (m *AsMarketAppRoleMutation) RoleDistribsCleared() bool {
	return m.clearedroleDistribs
}

// RemoveRoleDistribIDs removes the "roleDistribs" edge to the AsMarketRoleDistribution entity by IDs.
func (m *AsMarketAppRoleMutation) RemoveRoleDistribIDs(ids ...int64) {
	if m.removedroleDistribs == nil {
		m.removedroleDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roleDistribs, ids[i])
		m.removedroleDistribs[ids[i]] = struct{}{}
	}
}

// RemovedRoleDistribs returns the removed IDs of the "roleDistribs" edge to the AsMarketRoleDistribution entity.
func (m *AsMarketAppRoleMutation) RemovedRoleDistribsIDs() (ids []int64) {
	for id := range m.removedroleDistribs {
		ids = append(ids, id)
	}
	return
}

// RoleDistribsIDs returns the "roleDistribs" edge IDs in the mutation.
func (m *AsMarketAppRoleMutation) RoleDistribsIDs() (ids []int64) {
	for id := range m.roleDistribs {
		ids = append(ids, id)
	}
	return
}

// ResetRoleDistribs resets all changes to the "roleDistribs" edge.
func (m *AsMarketAppRoleMutation) ResetRoleDistribs() {
	m.roleDistribs = nil
	m.clearedroleDistribs = false
	m.removedroleDistribs = nil
}

// AddRoleMenuIDs adds the "roleMenus" edge to the AsMarketRoleMenu entity by ids.
func (m *AsMarketAppRoleMutation) AddRoleMenuIDs(ids ...int64) {
	if m.roleMenus == nil {
		m.roleMenus = make(map[int64]struct{})
	}
	for i := range ids {
		m.roleMenus[ids[i]] = struct{}{}
	}
}

// ClearRoleMenus clears the "roleMenus" edge to the AsMarketRoleMenu entity.
func (m *AsMarketAppRoleMutation) ClearRoleMenus() {
	m.clearedroleMenus = true
}

// RoleMenusCleared reports if the "roleMenus" edge to the AsMarketRoleMenu entity was cleared.
func (m *AsMarketAppRoleMutation) RoleMenusCleared() bool {
	return m.clearedroleMenus
}

// RemoveRoleMenuIDs removes the "roleMenus" edge to the AsMarketRoleMenu entity by IDs.
func (m *AsMarketAppRoleMutation) RemoveRoleMenuIDs(ids ...int64) {
	if m.removedroleMenus == nil {
		m.removedroleMenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roleMenus, ids[i])
		m.removedroleMenus[ids[i]] = struct{}{}
	}
}

// RemovedRoleMenus returns the removed IDs of the "roleMenus" edge to the AsMarketRoleMenu entity.
func (m *AsMarketAppRoleMutation) RemovedRoleMenusIDs() (ids []int64) {
	for id := range m.removedroleMenus {
		ids = append(ids, id)
	}
	return
}

// RoleMenusIDs returns the "roleMenus" edge IDs in the mutation.
func (m *AsMarketAppRoleMutation) RoleMenusIDs() (ids []int64) {
	for id := range m.roleMenus {
		ids = append(ids, id)
	}
	return
}

// ResetRoleMenus resets all changes to the "roleMenus" edge.
func (m *AsMarketAppRoleMutation) ResetRoleMenus() {
	m.roleMenus = nil
	m.clearedroleMenus = false
	m.removedroleMenus = nil
}

// AddMenuIDs adds the "menus" edge to the AsMarketMenu entity by ids.
func (m *AsMarketAppRoleMutation) AddMenuIDs(ids ...int64) {
	if m.menus == nil {
		m.menus = make(map[int64]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the AsMarketMenu entity.
func (m *AsMarketAppRoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the AsMarketMenu entity was cleared.
func (m *AsMarketAppRoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the AsMarketMenu entity by IDs.
func (m *AsMarketAppRoleMutation) RemoveMenuIDs(ids ...int64) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the AsMarketMenu entity.
func (m *AsMarketAppRoleMutation) RemovedMenusIDs() (ids []int64) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *AsMarketAppRoleMutation) MenusIDs() (ids []int64) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *AsMarketAppRoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsMarketAppRoleMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsMarketAppRoleMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsMarketAppRoleMutation) AppxCleared() bool {
	return m.AppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsMarketAppRoleMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppRoleMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsMarketAppRoleMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// Where appends a list predicates to the AsMarketAppRoleMutation builder.
func (m *AsMarketAppRoleMutation) Where(ps ...predicate.AsMarketAppRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketAppRole).
func (m *AsMarketAppRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppRoleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.role_name != nil {
		fields = append(fields, asmarketapprole.FieldRoleName)
	}
	if m.appx != nil {
		fields = append(fields, asmarketapprole.FieldAppID)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketapprole.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketapprole.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketapprole.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketapprole.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketapprole.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketapprole.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketapprole.FieldRoleName:
		return m.RoleName()
	case asmarketapprole.FieldAppID:
		return m.AppID()
	case asmarketapprole.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketapprole.FieldStatus:
		return m.Status()
	case asmarketapprole.FieldCreateUser:
		return m.CreateUser()
	case asmarketapprole.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketapprole.FieldCreateTime:
		return m.CreateTime()
	case asmarketapprole.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketapprole.FieldRoleName:
		return m.OldRoleName(ctx)
	case asmarketapprole.FieldAppID:
		return m.OldAppID(ctx)
	case asmarketapprole.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketapprole.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketapprole.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketapprole.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketapprole.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketapprole.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketAppRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketapprole.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case asmarketapprole.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asmarketapprole.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketapprole.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketapprole.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketapprole.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketapprole.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketapprole.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppRoleMutation) AddedFields() []string {
	var fields []string
	if m.addis_deleted != nil {
		fields = append(fields, asmarketapprole.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketapprole.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketapprole.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketapprole.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketapprole.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketapprole.FieldStatus:
		return m.AddedStatus()
	case asmarketapprole.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketapprole.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketapprole.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketapprole.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketapprole.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketapprole.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketapprole.FieldRoleName) {
		fields = append(fields, asmarketapprole.FieldRoleName)
	}
	if m.FieldCleared(asmarketapprole.FieldAppID) {
		fields = append(fields, asmarketapprole.FieldAppID)
	}
	if m.FieldCleared(asmarketapprole.FieldStatus) {
		fields = append(fields, asmarketapprole.FieldStatus)
	}
	if m.FieldCleared(asmarketapprole.FieldCreateUser) {
		fields = append(fields, asmarketapprole.FieldCreateUser)
	}
	if m.FieldCleared(asmarketapprole.FieldUpdateUser) {
		fields = append(fields, asmarketapprole.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketapprole.FieldCreateTime) {
		fields = append(fields, asmarketapprole.FieldCreateTime)
	}
	if m.FieldCleared(asmarketapprole.FieldUpdateTime) {
		fields = append(fields, asmarketapprole.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppRoleMutation) ClearField(name string) error {
	switch name {
	case asmarketapprole.FieldRoleName:
		m.ClearRoleName()
		return nil
	case asmarketapprole.FieldAppID:
		m.ClearAppID()
		return nil
	case asmarketapprole.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketapprole.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketapprole.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketapprole.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketapprole.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppRoleMutation) ResetField(name string) error {
	switch name {
	case asmarketapprole.FieldRoleName:
		m.ResetRoleName()
		return nil
	case asmarketapprole.FieldAppID:
		m.ResetAppID()
		return nil
	case asmarketapprole.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketapprole.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketapprole.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketapprole.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketapprole.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketapprole.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.roleDistribs != nil {
		edges = append(edges, asmarketapprole.EdgeRoleDistribs)
	}
	if m.roleMenus != nil {
		edges = append(edges, asmarketapprole.EdgeRoleMenus)
	}
	if m.menus != nil {
		edges = append(edges, asmarketapprole.EdgeMenus)
	}
	if m.appx != nil {
		edges = append(edges, asmarketapprole.EdgeAppx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketapprole.EdgeRoleDistribs:
		ids := make([]ent.Value, 0, len(m.roleDistribs))
		for id := range m.roleDistribs {
			ids = append(ids, id)
		}
		return ids
	case asmarketapprole.EdgeRoleMenus:
		ids := make([]ent.Value, 0, len(m.roleMenus))
		for id := range m.roleMenus {
			ids = append(ids, id)
		}
		return ids
	case asmarketapprole.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case asmarketapprole.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedroleDistribs != nil {
		edges = append(edges, asmarketapprole.EdgeRoleDistribs)
	}
	if m.removedroleMenus != nil {
		edges = append(edges, asmarketapprole.EdgeRoleMenus)
	}
	if m.removedmenus != nil {
		edges = append(edges, asmarketapprole.EdgeMenus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asmarketapprole.EdgeRoleDistribs:
		ids := make([]ent.Value, 0, len(m.removedroleDistribs))
		for id := range m.removedroleDistribs {
			ids = append(ids, id)
		}
		return ids
	case asmarketapprole.EdgeRoleMenus:
		ids := make([]ent.Value, 0, len(m.removedroleMenus))
		for id := range m.removedroleMenus {
			ids = append(ids, id)
		}
		return ids
	case asmarketapprole.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedroleDistribs {
		edges = append(edges, asmarketapprole.EdgeRoleDistribs)
	}
	if m.clearedroleMenus {
		edges = append(edges, asmarketapprole.EdgeRoleMenus)
	}
	if m.clearedmenus {
		edges = append(edges, asmarketapprole.EdgeMenus)
	}
	if m.clearedappx {
		edges = append(edges, asmarketapprole.EdgeAppx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketapprole.EdgeRoleDistribs:
		return m.clearedroleDistribs
	case asmarketapprole.EdgeRoleMenus:
		return m.clearedroleMenus
	case asmarketapprole.EdgeMenus:
		return m.clearedmenus
	case asmarketapprole.EdgeAppx:
		return m.clearedappx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppRoleMutation) ClearEdge(name string) error {
	switch name {
	case asmarketapprole.EdgeAppx:
		m.ClearAppx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppRoleMutation) ResetEdge(name string) error {
	switch name {
	case asmarketapprole.EdgeRoleDistribs:
		m.ResetRoleDistribs()
		return nil
	case asmarketapprole.EdgeRoleMenus:
		m.ResetRoleMenus()
		return nil
	case asmarketapprole.EdgeMenus:
		m.ResetMenus()
		return nil
	case asmarketapprole.EdgeAppx:
		m.ResetAppx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppRole edge %s", name)
}

// AsMarketAppUserTemplateMutation represents an operation that mutates the AsMarketAppUserTemplate nodes in the graph.
type AsMarketAppUserTemplateMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	use_status       *int64
	adduse_status    *int64
	is_deleted       *int64
	addis_deleted    *int64
	status           *int64
	addstatus        *int64
	create_user      *int64
	addcreate_user   *int64
	update_user      *int64
	addupdate_user   *int64
	create_time      *date.DateTime
	update_time      *date.DateTime
	clearedFields    map[string]struct{}
	userx            *int64
	cleareduserx     bool
	templatex        *int64
	clearedtemplatex bool
	done             bool
	oldValue         func(context.Context) (*AsMarketAppUserTemplate, error)
	predicates       []predicate.AsMarketAppUserTemplate
}

var _ ent.Mutation = (*AsMarketAppUserTemplateMutation)(nil)

// asmarketappusertemplateOption allows management of the mutation configuration using functional options.
type asmarketappusertemplateOption func(*AsMarketAppUserTemplateMutation)

// newAsMarketAppUserTemplateMutation creates new mutation for the AsMarketAppUserTemplate entity.
func newAsMarketAppUserTemplateMutation(c config, op Op, opts ...asmarketappusertemplateOption) *AsMarketAppUserTemplateMutation {
	m := &AsMarketAppUserTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketAppUserTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketAppUserTemplateID sets the ID field of the mutation.
func withAsMarketAppUserTemplateID(id int64) asmarketappusertemplateOption {
	return func(m *AsMarketAppUserTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketAppUserTemplate
		)
		m.oldValue = func(ctx context.Context) (*AsMarketAppUserTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketAppUserTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketAppUserTemplate sets the old AsMarketAppUserTemplate of the mutation.
func withAsMarketAppUserTemplate(node *AsMarketAppUserTemplate) asmarketappusertemplateOption {
	return func(m *AsMarketAppUserTemplateMutation) {
		m.oldValue = func(context.Context) (*AsMarketAppUserTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketAppUserTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketAppUserTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketAppUserTemplate entities.
func (m *AsMarketAppUserTemplateMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketAppUserTemplateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketAppUserTemplateMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketAppUserTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AsMarketAppUserTemplateMutation) SetUserID(i int64) {
	m.userx = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AsMarketAppUserTemplateMutation) UserID() (r int64, exists bool) {
	v := m.userx
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AsMarketAppUserTemplate entity.
// If the AsMarketAppUserTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppUserTemplateMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AsMarketAppUserTemplateMutation) ClearUserID() {
	m.userx = nil
	m.clearedFields[asmarketappusertemplate.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[asmarketappusertemplate.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AsMarketAppUserTemplateMutation) ResetUserID() {
	m.userx = nil
	delete(m.clearedFields, asmarketappusertemplate.FieldUserID)
}

// SetTemplateID sets the "template_id" field.
func (m *AsMarketAppUserTemplateMutation) SetTemplateID(i int64) {
	m.templatex = &i
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *AsMarketAppUserTemplateMutation) TemplateID() (r int64, exists bool) {
	v := m.templatex
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the AsMarketAppUserTemplate entity.
// If the AsMarketAppUserTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppUserTemplateMutation) OldTemplateID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ClearTemplateID clears the value of the "template_id" field.
func (m *AsMarketAppUserTemplateMutation) ClearTemplateID() {
	m.templatex = nil
	m.clearedFields[asmarketappusertemplate.FieldTemplateID] = struct{}{}
}

// TemplateIDCleared returns if the "template_id" field was cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) TemplateIDCleared() bool {
	_, ok := m.clearedFields[asmarketappusertemplate.FieldTemplateID]
	return ok
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *AsMarketAppUserTemplateMutation) ResetTemplateID() {
	m.templatex = nil
	delete(m.clearedFields, asmarketappusertemplate.FieldTemplateID)
}

// SetUseStatus sets the "use_status" field.
func (m *AsMarketAppUserTemplateMutation) SetUseStatus(i int64) {
	m.use_status = &i
	m.adduse_status = nil
}

// UseStatus returns the value of the "use_status" field in the mutation.
func (m *AsMarketAppUserTemplateMutation) UseStatus() (r int64, exists bool) {
	v := m.use_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUseStatus returns the old "use_status" field's value of the AsMarketAppUserTemplate entity.
// If the AsMarketAppUserTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppUserTemplateMutation) OldUseStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseStatus: %w", err)
	}
	return oldValue.UseStatus, nil
}

// AddUseStatus adds i to the "use_status" field.
func (m *AsMarketAppUserTemplateMutation) AddUseStatus(i int64) {
	if m.adduse_status != nil {
		*m.adduse_status += i
	} else {
		m.adduse_status = &i
	}
}

// AddedUseStatus returns the value that was added to the "use_status" field in this mutation.
func (m *AsMarketAppUserTemplateMutation) AddedUseStatus() (r int64, exists bool) {
	v := m.adduse_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearUseStatus clears the value of the "use_status" field.
func (m *AsMarketAppUserTemplateMutation) ClearUseStatus() {
	m.use_status = nil
	m.adduse_status = nil
	m.clearedFields[asmarketappusertemplate.FieldUseStatus] = struct{}{}
}

// UseStatusCleared returns if the "use_status" field was cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) UseStatusCleared() bool {
	_, ok := m.clearedFields[asmarketappusertemplate.FieldUseStatus]
	return ok
}

// ResetUseStatus resets all changes to the "use_status" field.
func (m *AsMarketAppUserTemplateMutation) ResetUseStatus() {
	m.use_status = nil
	m.adduse_status = nil
	delete(m.clearedFields, asmarketappusertemplate.FieldUseStatus)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketAppUserTemplateMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketAppUserTemplateMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketAppUserTemplate entity.
// If the AsMarketAppUserTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppUserTemplateMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketAppUserTemplateMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketAppUserTemplateMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketAppUserTemplateMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketAppUserTemplateMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketAppUserTemplateMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketAppUserTemplate entity.
// If the AsMarketAppUserTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppUserTemplateMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketAppUserTemplateMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketAppUserTemplateMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketAppUserTemplateMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketappusertemplate.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketappusertemplate.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketAppUserTemplateMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketappusertemplate.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketAppUserTemplateMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketAppUserTemplateMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketAppUserTemplate entity.
// If the AsMarketAppUserTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppUserTemplateMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketAppUserTemplateMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketAppUserTemplateMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketAppUserTemplateMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketappusertemplate.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappusertemplate.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketAppUserTemplateMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketappusertemplate.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketAppUserTemplateMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketAppUserTemplateMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketAppUserTemplate entity.
// If the AsMarketAppUserTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppUserTemplateMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketAppUserTemplateMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketAppUserTemplateMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketAppUserTemplateMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketappusertemplate.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketappusertemplate.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketAppUserTemplateMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketappusertemplate.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketAppUserTemplateMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketAppUserTemplateMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketAppUserTemplate entity.
// If the AsMarketAppUserTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppUserTemplateMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketAppUserTemplateMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketappusertemplate.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappusertemplate.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketAppUserTemplateMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketappusertemplate.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketAppUserTemplateMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketAppUserTemplateMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketAppUserTemplate entity.
// If the AsMarketAppUserTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketAppUserTemplateMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketAppUserTemplateMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketappusertemplate.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketappusertemplate.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketAppUserTemplateMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketappusertemplate.FieldUpdateTime)
}

// SetUserxID sets the "userx" edge to the AsUser entity by id.
func (m *AsMarketAppUserTemplateMutation) SetUserxID(id int64) {
	m.userx = &id
}

// ClearUserx clears the "userx" edge to the AsUser entity.
func (m *AsMarketAppUserTemplateMutation) ClearUserx() {
	m.cleareduserx = true
}

// UserxCleared reports if the "userx" edge to the AsUser entity was cleared.
func (m *AsMarketAppUserTemplateMutation) UserxCleared() bool {
	return m.UserIDCleared() || m.cleareduserx
}

// UserxID returns the "userx" edge ID in the mutation.
func (m *AsMarketAppUserTemplateMutation) UserxID() (id int64, exists bool) {
	if m.userx != nil {
		return *m.userx, true
	}
	return
}

// UserxIDs returns the "userx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserxID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppUserTemplateMutation) UserxIDs() (ids []int64) {
	if id := m.userx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserx resets all changes to the "userx" edge.
func (m *AsMarketAppUserTemplateMutation) ResetUserx() {
	m.userx = nil
	m.cleareduserx = false
}

// SetTemplatexID sets the "templatex" edge to the AsMarketAppComponentTemplate entity by id.
func (m *AsMarketAppUserTemplateMutation) SetTemplatexID(id int64) {
	m.templatex = &id
}

// ClearTemplatex clears the "templatex" edge to the AsMarketAppComponentTemplate entity.
func (m *AsMarketAppUserTemplateMutation) ClearTemplatex() {
	m.clearedtemplatex = true
}

// TemplatexCleared reports if the "templatex" edge to the AsMarketAppComponentTemplate entity was cleared.
func (m *AsMarketAppUserTemplateMutation) TemplatexCleared() bool {
	return m.TemplateIDCleared() || m.clearedtemplatex
}

// TemplatexID returns the "templatex" edge ID in the mutation.
func (m *AsMarketAppUserTemplateMutation) TemplatexID() (id int64, exists bool) {
	if m.templatex != nil {
		return *m.templatex, true
	}
	return
}

// TemplatexIDs returns the "templatex" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplatexID instead. It exists only for internal usage by the builders.
func (m *AsMarketAppUserTemplateMutation) TemplatexIDs() (ids []int64) {
	if id := m.templatex; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplatex resets all changes to the "templatex" edge.
func (m *AsMarketAppUserTemplateMutation) ResetTemplatex() {
	m.templatex = nil
	m.clearedtemplatex = false
}

// Where appends a list predicates to the AsMarketAppUserTemplateMutation builder.
func (m *AsMarketAppUserTemplateMutation) Where(ps ...predicate.AsMarketAppUserTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketAppUserTemplateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketAppUserTemplate).
func (m *AsMarketAppUserTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketAppUserTemplateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.userx != nil {
		fields = append(fields, asmarketappusertemplate.FieldUserID)
	}
	if m.templatex != nil {
		fields = append(fields, asmarketappusertemplate.FieldTemplateID)
	}
	if m.use_status != nil {
		fields = append(fields, asmarketappusertemplate.FieldUseStatus)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketappusertemplate.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketappusertemplate.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketappusertemplate.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketappusertemplate.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketappusertemplate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketappusertemplate.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketAppUserTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketappusertemplate.FieldUserID:
		return m.UserID()
	case asmarketappusertemplate.FieldTemplateID:
		return m.TemplateID()
	case asmarketappusertemplate.FieldUseStatus:
		return m.UseStatus()
	case asmarketappusertemplate.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketappusertemplate.FieldStatus:
		return m.Status()
	case asmarketappusertemplate.FieldCreateUser:
		return m.CreateUser()
	case asmarketappusertemplate.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketappusertemplate.FieldCreateTime:
		return m.CreateTime()
	case asmarketappusertemplate.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketAppUserTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketappusertemplate.FieldUserID:
		return m.OldUserID(ctx)
	case asmarketappusertemplate.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case asmarketappusertemplate.FieldUseStatus:
		return m.OldUseStatus(ctx)
	case asmarketappusertemplate.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketappusertemplate.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketappusertemplate.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketappusertemplate.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketappusertemplate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketappusertemplate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketAppUserTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppUserTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketappusertemplate.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case asmarketappusertemplate.FieldTemplateID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case asmarketappusertemplate.FieldUseStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseStatus(v)
		return nil
	case asmarketappusertemplate.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketappusertemplate.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketappusertemplate.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketappusertemplate.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketappusertemplate.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketappusertemplate.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppUserTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketAppUserTemplateMutation) AddedFields() []string {
	var fields []string
	if m.adduse_status != nil {
		fields = append(fields, asmarketappusertemplate.FieldUseStatus)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketappusertemplate.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketappusertemplate.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketappusertemplate.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketappusertemplate.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketAppUserTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketappusertemplate.FieldUseStatus:
		return m.AddedUseStatus()
	case asmarketappusertemplate.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketappusertemplate.FieldStatus:
		return m.AddedStatus()
	case asmarketappusertemplate.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketappusertemplate.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketAppUserTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketappusertemplate.FieldUseStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseStatus(v)
		return nil
	case asmarketappusertemplate.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketappusertemplate.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketappusertemplate.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketappusertemplate.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppUserTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketAppUserTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketappusertemplate.FieldUserID) {
		fields = append(fields, asmarketappusertemplate.FieldUserID)
	}
	if m.FieldCleared(asmarketappusertemplate.FieldTemplateID) {
		fields = append(fields, asmarketappusertemplate.FieldTemplateID)
	}
	if m.FieldCleared(asmarketappusertemplate.FieldUseStatus) {
		fields = append(fields, asmarketappusertemplate.FieldUseStatus)
	}
	if m.FieldCleared(asmarketappusertemplate.FieldStatus) {
		fields = append(fields, asmarketappusertemplate.FieldStatus)
	}
	if m.FieldCleared(asmarketappusertemplate.FieldCreateUser) {
		fields = append(fields, asmarketappusertemplate.FieldCreateUser)
	}
	if m.FieldCleared(asmarketappusertemplate.FieldUpdateUser) {
		fields = append(fields, asmarketappusertemplate.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketappusertemplate.FieldCreateTime) {
		fields = append(fields, asmarketappusertemplate.FieldCreateTime)
	}
	if m.FieldCleared(asmarketappusertemplate.FieldUpdateTime) {
		fields = append(fields, asmarketappusertemplate.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketAppUserTemplateMutation) ClearField(name string) error {
	switch name {
	case asmarketappusertemplate.FieldUserID:
		m.ClearUserID()
		return nil
	case asmarketappusertemplate.FieldTemplateID:
		m.ClearTemplateID()
		return nil
	case asmarketappusertemplate.FieldUseStatus:
		m.ClearUseStatus()
		return nil
	case asmarketappusertemplate.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketappusertemplate.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketappusertemplate.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketappusertemplate.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketappusertemplate.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppUserTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketAppUserTemplateMutation) ResetField(name string) error {
	switch name {
	case asmarketappusertemplate.FieldUserID:
		m.ResetUserID()
		return nil
	case asmarketappusertemplate.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case asmarketappusertemplate.FieldUseStatus:
		m.ResetUseStatus()
		return nil
	case asmarketappusertemplate.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketappusertemplate.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketappusertemplate.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketappusertemplate.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketappusertemplate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketappusertemplate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppUserTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketAppUserTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.userx != nil {
		edges = append(edges, asmarketappusertemplate.EdgeUserx)
	}
	if m.templatex != nil {
		edges = append(edges, asmarketappusertemplate.EdgeTemplatex)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketAppUserTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketappusertemplate.EdgeUserx:
		if id := m.userx; id != nil {
			return []ent.Value{*id}
		}
	case asmarketappusertemplate.EdgeTemplatex:
		if id := m.templatex; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketAppUserTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketAppUserTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduserx {
		edges = append(edges, asmarketappusertemplate.EdgeUserx)
	}
	if m.clearedtemplatex {
		edges = append(edges, asmarketappusertemplate.EdgeTemplatex)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketAppUserTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketappusertemplate.EdgeUserx:
		return m.cleareduserx
	case asmarketappusertemplate.EdgeTemplatex:
		return m.clearedtemplatex
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketAppUserTemplateMutation) ClearEdge(name string) error {
	switch name {
	case asmarketappusertemplate.EdgeUserx:
		m.ClearUserx()
		return nil
	case asmarketappusertemplate.EdgeTemplatex:
		m.ClearTemplatex()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppUserTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketAppUserTemplateMutation) ResetEdge(name string) error {
	switch name {
	case asmarketappusertemplate.EdgeUserx:
		m.ResetUserx()
		return nil
	case asmarketappusertemplate.EdgeTemplatex:
		m.ResetTemplatex()
		return nil
	}
	return fmt.Errorf("unknown AsMarketAppUserTemplate edge %s", name)
}

// AsMarketMenuMutation represents an operation that mutates the AsMarketMenu nodes in the graph.
type AsMarketMenuMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	menu_name         *string
	menu_url          *string
	menu_column       *string
	icon              *string
	sort              *int64
	addsort           *int64
	https_menu_url    *string
	reform_status     *int64
	addreform_status  *int64
	out_ip_menu_url   *string
	is_deleted        *int64
	addis_deleted     *int64
	status            *int64
	addstatus         *int64
	create_user       *int64
	addcreate_user    *int64
	update_user       *int64
	addupdate_user    *int64
	create_time       *date.DateTime
	update_time       *date.DateTime
	clearedFields     map[string]struct{}
	parent            *int64
	clearedparent     bool
	childrens         map[int64]struct{}
	removedchildrens  map[int64]struct{}
	clearedchildrens  bool
	appx              *int64
	clearedappx       bool
	roleMenus         map[int64]struct{}
	removedroleMenus  map[int64]struct{}
	clearedroleMenus  bool
	roles             map[int64]struct{}
	removedroles      map[int64]struct{}
	clearedroles      bool
	_UserSorts        map[int64]struct{}
	removed_UserSorts map[int64]struct{}
	cleared_UserSorts bool
	done              bool
	oldValue          func(context.Context) (*AsMarketMenu, error)
	predicates        []predicate.AsMarketMenu
}

var _ ent.Mutation = (*AsMarketMenuMutation)(nil)

// asmarketmenuOption allows management of the mutation configuration using functional options.
type asmarketmenuOption func(*AsMarketMenuMutation)

// newAsMarketMenuMutation creates new mutation for the AsMarketMenu entity.
func newAsMarketMenuMutation(c config, op Op, opts ...asmarketmenuOption) *AsMarketMenuMutation {
	m := &AsMarketMenuMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketMenuID sets the ID field of the mutation.
func withAsMarketMenuID(id int64) asmarketmenuOption {
	return func(m *AsMarketMenuMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketMenu
		)
		m.oldValue = func(ctx context.Context) (*AsMarketMenu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketMenu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketMenu sets the old AsMarketMenu of the mutation.
func withAsMarketMenu(node *AsMarketMenu) asmarketmenuOption {
	return func(m *AsMarketMenuMutation) {
		m.oldValue = func(context.Context) (*AsMarketMenu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketMenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketMenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketMenu entities.
func (m *AsMarketMenuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketMenuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketMenuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketMenu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AsMarketMenuMutation) SetAppID(i int64) {
	m.appx = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsMarketMenuMutation) AppID() (r int64, exists bool) {
	v := m.appx
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AsMarketMenuMutation) ClearAppID() {
	m.appx = nil
	m.clearedFields[asmarketmenu.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AsMarketMenuMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsMarketMenuMutation) ResetAppID() {
	m.appx = nil
	delete(m.clearedFields, asmarketmenu.FieldAppID)
}

// SetParentID sets the "parent_id" field.
func (m *AsMarketMenuMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *AsMarketMenuMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *AsMarketMenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[asmarketmenu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *AsMarketMenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *AsMarketMenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, asmarketmenu.FieldParentID)
}

// SetMenuName sets the "menu_name" field.
func (m *AsMarketMenuMutation) SetMenuName(s string) {
	m.menu_name = &s
}

// MenuName returns the value of the "menu_name" field in the mutation.
func (m *AsMarketMenuMutation) MenuName() (r string, exists bool) {
	v := m.menu_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuName returns the old "menu_name" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldMenuName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuName: %w", err)
	}
	return oldValue.MenuName, nil
}

// ClearMenuName clears the value of the "menu_name" field.
func (m *AsMarketMenuMutation) ClearMenuName() {
	m.menu_name = nil
	m.clearedFields[asmarketmenu.FieldMenuName] = struct{}{}
}

// MenuNameCleared returns if the "menu_name" field was cleared in this mutation.
func (m *AsMarketMenuMutation) MenuNameCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldMenuName]
	return ok
}

// ResetMenuName resets all changes to the "menu_name" field.
func (m *AsMarketMenuMutation) ResetMenuName() {
	m.menu_name = nil
	delete(m.clearedFields, asmarketmenu.FieldMenuName)
}

// SetMenuURL sets the "menu_url" field.
func (m *AsMarketMenuMutation) SetMenuURL(s string) {
	m.menu_url = &s
}

// MenuURL returns the value of the "menu_url" field in the mutation.
func (m *AsMarketMenuMutation) MenuURL() (r string, exists bool) {
	v := m.menu_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuURL returns the old "menu_url" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldMenuURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuURL: %w", err)
	}
	return oldValue.MenuURL, nil
}

// ClearMenuURL clears the value of the "menu_url" field.
func (m *AsMarketMenuMutation) ClearMenuURL() {
	m.menu_url = nil
	m.clearedFields[asmarketmenu.FieldMenuURL] = struct{}{}
}

// MenuURLCleared returns if the "menu_url" field was cleared in this mutation.
func (m *AsMarketMenuMutation) MenuURLCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldMenuURL]
	return ok
}

// ResetMenuURL resets all changes to the "menu_url" field.
func (m *AsMarketMenuMutation) ResetMenuURL() {
	m.menu_url = nil
	delete(m.clearedFields, asmarketmenu.FieldMenuURL)
}

// SetMenuColumn sets the "menu_column" field.
func (m *AsMarketMenuMutation) SetMenuColumn(s string) {
	m.menu_column = &s
}

// MenuColumn returns the value of the "menu_column" field in the mutation.
func (m *AsMarketMenuMutation) MenuColumn() (r string, exists bool) {
	v := m.menu_column
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuColumn returns the old "menu_column" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldMenuColumn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuColumn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuColumn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuColumn: %w", err)
	}
	return oldValue.MenuColumn, nil
}

// ClearMenuColumn clears the value of the "menu_column" field.
func (m *AsMarketMenuMutation) ClearMenuColumn() {
	m.menu_column = nil
	m.clearedFields[asmarketmenu.FieldMenuColumn] = struct{}{}
}

// MenuColumnCleared returns if the "menu_column" field was cleared in this mutation.
func (m *AsMarketMenuMutation) MenuColumnCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldMenuColumn]
	return ok
}

// ResetMenuColumn resets all changes to the "menu_column" field.
func (m *AsMarketMenuMutation) ResetMenuColumn() {
	m.menu_column = nil
	delete(m.clearedFields, asmarketmenu.FieldMenuColumn)
}

// SetIcon sets the "icon" field.
func (m *AsMarketMenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AsMarketMenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *AsMarketMenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[asmarketmenu.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *AsMarketMenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *AsMarketMenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, asmarketmenu.FieldIcon)
}

// SetSort sets the "sort" field.
func (m *AsMarketMenuMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AsMarketMenuMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AsMarketMenuMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AsMarketMenuMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *AsMarketMenuMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[asmarketmenu.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *AsMarketMenuMutation) SortCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *AsMarketMenuMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, asmarketmenu.FieldSort)
}

// SetHTTPSMenuURL sets the "https_menu_url" field.
func (m *AsMarketMenuMutation) SetHTTPSMenuURL(s string) {
	m.https_menu_url = &s
}

// HTTPSMenuURL returns the value of the "https_menu_url" field in the mutation.
func (m *AsMarketMenuMutation) HTTPSMenuURL() (r string, exists bool) {
	v := m.https_menu_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHTTPSMenuURL returns the old "https_menu_url" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldHTTPSMenuURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTTPSMenuURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTTPSMenuURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTTPSMenuURL: %w", err)
	}
	return oldValue.HTTPSMenuURL, nil
}

// ClearHTTPSMenuURL clears the value of the "https_menu_url" field.
func (m *AsMarketMenuMutation) ClearHTTPSMenuURL() {
	m.https_menu_url = nil
	m.clearedFields[asmarketmenu.FieldHTTPSMenuURL] = struct{}{}
}

// HTTPSMenuURLCleared returns if the "https_menu_url" field was cleared in this mutation.
func (m *AsMarketMenuMutation) HTTPSMenuURLCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldHTTPSMenuURL]
	return ok
}

// ResetHTTPSMenuURL resets all changes to the "https_menu_url" field.
func (m *AsMarketMenuMutation) ResetHTTPSMenuURL() {
	m.https_menu_url = nil
	delete(m.clearedFields, asmarketmenu.FieldHTTPSMenuURL)
}

// SetReformStatus sets the "reform_status" field.
func (m *AsMarketMenuMutation) SetReformStatus(i int64) {
	m.reform_status = &i
	m.addreform_status = nil
}

// ReformStatus returns the value of the "reform_status" field in the mutation.
func (m *AsMarketMenuMutation) ReformStatus() (r int64, exists bool) {
	v := m.reform_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReformStatus returns the old "reform_status" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldReformStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReformStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReformStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReformStatus: %w", err)
	}
	return oldValue.ReformStatus, nil
}

// AddReformStatus adds i to the "reform_status" field.
func (m *AsMarketMenuMutation) AddReformStatus(i int64) {
	if m.addreform_status != nil {
		*m.addreform_status += i
	} else {
		m.addreform_status = &i
	}
}

// AddedReformStatus returns the value that was added to the "reform_status" field in this mutation.
func (m *AsMarketMenuMutation) AddedReformStatus() (r int64, exists bool) {
	v := m.addreform_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetReformStatus resets all changes to the "reform_status" field.
func (m *AsMarketMenuMutation) ResetReformStatus() {
	m.reform_status = nil
	m.addreform_status = nil
}

// SetOutIPMenuURL sets the "out_ip_menu_url" field.
func (m *AsMarketMenuMutation) SetOutIPMenuURL(s string) {
	m.out_ip_menu_url = &s
}

// OutIPMenuURL returns the value of the "out_ip_menu_url" field in the mutation.
func (m *AsMarketMenuMutation) OutIPMenuURL() (r string, exists bool) {
	v := m.out_ip_menu_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOutIPMenuURL returns the old "out_ip_menu_url" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldOutIPMenuURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutIPMenuURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutIPMenuURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutIPMenuURL: %w", err)
	}
	return oldValue.OutIPMenuURL, nil
}

// ClearOutIPMenuURL clears the value of the "out_ip_menu_url" field.
func (m *AsMarketMenuMutation) ClearOutIPMenuURL() {
	m.out_ip_menu_url = nil
	m.clearedFields[asmarketmenu.FieldOutIPMenuURL] = struct{}{}
}

// OutIPMenuURLCleared returns if the "out_ip_menu_url" field was cleared in this mutation.
func (m *AsMarketMenuMutation) OutIPMenuURLCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldOutIPMenuURL]
	return ok
}

// ResetOutIPMenuURL resets all changes to the "out_ip_menu_url" field.
func (m *AsMarketMenuMutation) ResetOutIPMenuURL() {
	m.out_ip_menu_url = nil
	delete(m.clearedFields, asmarketmenu.FieldOutIPMenuURL)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketMenuMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketMenuMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketMenuMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketMenuMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketMenuMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketMenuMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketMenuMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketMenuMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketMenuMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketMenuMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketmenu.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketMenuMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketMenuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketmenu.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketMenuMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketMenuMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketMenuMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketMenuMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketMenuMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketmenu.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketMenuMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketMenuMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketmenu.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketMenuMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketMenuMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketMenuMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketMenuMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketMenuMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketmenu.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketMenuMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketMenuMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketmenu.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketMenuMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketMenuMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketMenuMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketmenu.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketMenuMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketMenuMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketmenu.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketMenuMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketMenuMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketMenu entity.
// If the AsMarketMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketMenuMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketmenu.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketMenuMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketmenu.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketMenuMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketmenu.FieldUpdateTime)
}

// ClearParent clears the "parent" edge to the AsMarketMenu entity.
func (m *AsMarketMenuMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the AsMarketMenu entity was cleared.
func (m *AsMarketMenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *AsMarketMenuMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *AsMarketMenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildrenIDs adds the "childrens" edge to the AsMarketMenu entity by ids.
func (m *AsMarketMenuMutation) AddChildrenIDs(ids ...int64) {
	if m.childrens == nil {
		m.childrens = make(map[int64]struct{})
	}
	for i := range ids {
		m.childrens[ids[i]] = struct{}{}
	}
}

// ClearChildrens clears the "childrens" edge to the AsMarketMenu entity.
func (m *AsMarketMenuMutation) ClearChildrens() {
	m.clearedchildrens = true
}

// ChildrensCleared reports if the "childrens" edge to the AsMarketMenu entity was cleared.
func (m *AsMarketMenuMutation) ChildrensCleared() bool {
	return m.clearedchildrens
}

// RemoveChildrenIDs removes the "childrens" edge to the AsMarketMenu entity by IDs.
func (m *AsMarketMenuMutation) RemoveChildrenIDs(ids ...int64) {
	if m.removedchildrens == nil {
		m.removedchildrens = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.childrens, ids[i])
		m.removedchildrens[ids[i]] = struct{}{}
	}
}

// RemovedChildrens returns the removed IDs of the "childrens" edge to the AsMarketMenu entity.
func (m *AsMarketMenuMutation) RemovedChildrensIDs() (ids []int64) {
	for id := range m.removedchildrens {
		ids = append(ids, id)
	}
	return
}

// ChildrensIDs returns the "childrens" edge IDs in the mutation.
func (m *AsMarketMenuMutation) ChildrensIDs() (ids []int64) {
	for id := range m.childrens {
		ids = append(ids, id)
	}
	return
}

// ResetChildrens resets all changes to the "childrens" edge.
func (m *AsMarketMenuMutation) ResetChildrens() {
	m.childrens = nil
	m.clearedchildrens = false
	m.removedchildrens = nil
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsMarketMenuMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsMarketMenuMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsMarketMenuMutation) AppxCleared() bool {
	return m.AppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsMarketMenuMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsMarketMenuMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsMarketMenuMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// AddRoleMenuIDs adds the "roleMenus" edge to the AsMarketRoleMenu entity by ids.
func (m *AsMarketMenuMutation) AddRoleMenuIDs(ids ...int64) {
	if m.roleMenus == nil {
		m.roleMenus = make(map[int64]struct{})
	}
	for i := range ids {
		m.roleMenus[ids[i]] = struct{}{}
	}
}

// ClearRoleMenus clears the "roleMenus" edge to the AsMarketRoleMenu entity.
func (m *AsMarketMenuMutation) ClearRoleMenus() {
	m.clearedroleMenus = true
}

// RoleMenusCleared reports if the "roleMenus" edge to the AsMarketRoleMenu entity was cleared.
func (m *AsMarketMenuMutation) RoleMenusCleared() bool {
	return m.clearedroleMenus
}

// RemoveRoleMenuIDs removes the "roleMenus" edge to the AsMarketRoleMenu entity by IDs.
func (m *AsMarketMenuMutation) RemoveRoleMenuIDs(ids ...int64) {
	if m.removedroleMenus == nil {
		m.removedroleMenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roleMenus, ids[i])
		m.removedroleMenus[ids[i]] = struct{}{}
	}
}

// RemovedRoleMenus returns the removed IDs of the "roleMenus" edge to the AsMarketRoleMenu entity.
func (m *AsMarketMenuMutation) RemovedRoleMenusIDs() (ids []int64) {
	for id := range m.removedroleMenus {
		ids = append(ids, id)
	}
	return
}

// RoleMenusIDs returns the "roleMenus" edge IDs in the mutation.
func (m *AsMarketMenuMutation) RoleMenusIDs() (ids []int64) {
	for id := range m.roleMenus {
		ids = append(ids, id)
	}
	return
}

// ResetRoleMenus resets all changes to the "roleMenus" edge.
func (m *AsMarketMenuMutation) ResetRoleMenus() {
	m.roleMenus = nil
	m.clearedroleMenus = false
	m.removedroleMenus = nil
}

// AddRoleIDs adds the "roles" edge to the AsMarketAppRole entity by ids.
func (m *AsMarketMenuMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the AsMarketAppRole entity.
func (m *AsMarketMenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AsMarketAppRole entity was cleared.
func (m *AsMarketMenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the AsMarketAppRole entity by IDs.
func (m *AsMarketMenuMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the AsMarketAppRole entity.
func (m *AsMarketMenuMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AsMarketMenuMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AsMarketMenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddUserSortIDs adds the "UserSorts" edge to the AsMarketMenuUserSort entity by ids.
func (m *AsMarketMenuMutation) AddUserSortIDs(ids ...int64) {
	if m._UserSorts == nil {
		m._UserSorts = make(map[int64]struct{})
	}
	for i := range ids {
		m._UserSorts[ids[i]] = struct{}{}
	}
}

// ClearUserSorts clears the "UserSorts" edge to the AsMarketMenuUserSort entity.
func (m *AsMarketMenuMutation) ClearUserSorts() {
	m.cleared_UserSorts = true
}

// UserSortsCleared reports if the "UserSorts" edge to the AsMarketMenuUserSort entity was cleared.
func (m *AsMarketMenuMutation) UserSortsCleared() bool {
	return m.cleared_UserSorts
}

// RemoveUserSortIDs removes the "UserSorts" edge to the AsMarketMenuUserSort entity by IDs.
func (m *AsMarketMenuMutation) RemoveUserSortIDs(ids ...int64) {
	if m.removed_UserSorts == nil {
		m.removed_UserSorts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._UserSorts, ids[i])
		m.removed_UserSorts[ids[i]] = struct{}{}
	}
}

// RemovedUserSorts returns the removed IDs of the "UserSorts" edge to the AsMarketMenuUserSort entity.
func (m *AsMarketMenuMutation) RemovedUserSortsIDs() (ids []int64) {
	for id := range m.removed_UserSorts {
		ids = append(ids, id)
	}
	return
}

// UserSortsIDs returns the "UserSorts" edge IDs in the mutation.
func (m *AsMarketMenuMutation) UserSortsIDs() (ids []int64) {
	for id := range m._UserSorts {
		ids = append(ids, id)
	}
	return
}

// ResetUserSorts resets all changes to the "UserSorts" edge.
func (m *AsMarketMenuMutation) ResetUserSorts() {
	m._UserSorts = nil
	m.cleared_UserSorts = false
	m.removed_UserSorts = nil
}

// Where appends a list predicates to the AsMarketMenuMutation builder.
func (m *AsMarketMenuMutation) Where(ps ...predicate.AsMarketMenu) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketMenuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketMenu).
func (m *AsMarketMenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketMenuMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.appx != nil {
		fields = append(fields, asmarketmenu.FieldAppID)
	}
	if m.parent != nil {
		fields = append(fields, asmarketmenu.FieldParentID)
	}
	if m.menu_name != nil {
		fields = append(fields, asmarketmenu.FieldMenuName)
	}
	if m.menu_url != nil {
		fields = append(fields, asmarketmenu.FieldMenuURL)
	}
	if m.menu_column != nil {
		fields = append(fields, asmarketmenu.FieldMenuColumn)
	}
	if m.icon != nil {
		fields = append(fields, asmarketmenu.FieldIcon)
	}
	if m.sort != nil {
		fields = append(fields, asmarketmenu.FieldSort)
	}
	if m.https_menu_url != nil {
		fields = append(fields, asmarketmenu.FieldHTTPSMenuURL)
	}
	if m.reform_status != nil {
		fields = append(fields, asmarketmenu.FieldReformStatus)
	}
	if m.out_ip_menu_url != nil {
		fields = append(fields, asmarketmenu.FieldOutIPMenuURL)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketmenu.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketmenu.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketmenu.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketmenu.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketmenu.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketmenu.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketMenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketmenu.FieldAppID:
		return m.AppID()
	case asmarketmenu.FieldParentID:
		return m.ParentID()
	case asmarketmenu.FieldMenuName:
		return m.MenuName()
	case asmarketmenu.FieldMenuURL:
		return m.MenuURL()
	case asmarketmenu.FieldMenuColumn:
		return m.MenuColumn()
	case asmarketmenu.FieldIcon:
		return m.Icon()
	case asmarketmenu.FieldSort:
		return m.Sort()
	case asmarketmenu.FieldHTTPSMenuURL:
		return m.HTTPSMenuURL()
	case asmarketmenu.FieldReformStatus:
		return m.ReformStatus()
	case asmarketmenu.FieldOutIPMenuURL:
		return m.OutIPMenuURL()
	case asmarketmenu.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketmenu.FieldStatus:
		return m.Status()
	case asmarketmenu.FieldCreateUser:
		return m.CreateUser()
	case asmarketmenu.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketmenu.FieldCreateTime:
		return m.CreateTime()
	case asmarketmenu.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketMenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketmenu.FieldAppID:
		return m.OldAppID(ctx)
	case asmarketmenu.FieldParentID:
		return m.OldParentID(ctx)
	case asmarketmenu.FieldMenuName:
		return m.OldMenuName(ctx)
	case asmarketmenu.FieldMenuURL:
		return m.OldMenuURL(ctx)
	case asmarketmenu.FieldMenuColumn:
		return m.OldMenuColumn(ctx)
	case asmarketmenu.FieldIcon:
		return m.OldIcon(ctx)
	case asmarketmenu.FieldSort:
		return m.OldSort(ctx)
	case asmarketmenu.FieldHTTPSMenuURL:
		return m.OldHTTPSMenuURL(ctx)
	case asmarketmenu.FieldReformStatus:
		return m.OldReformStatus(ctx)
	case asmarketmenu.FieldOutIPMenuURL:
		return m.OldOutIPMenuURL(ctx)
	case asmarketmenu.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketmenu.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketmenu.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketmenu.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketmenu.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketmenu.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketMenu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketMenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketmenu.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asmarketmenu.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case asmarketmenu.FieldMenuName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuName(v)
		return nil
	case asmarketmenu.FieldMenuURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuURL(v)
		return nil
	case asmarketmenu.FieldMenuColumn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuColumn(v)
		return nil
	case asmarketmenu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case asmarketmenu.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case asmarketmenu.FieldHTTPSMenuURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTTPSMenuURL(v)
		return nil
	case asmarketmenu.FieldReformStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReformStatus(v)
		return nil
	case asmarketmenu.FieldOutIPMenuURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutIPMenuURL(v)
		return nil
	case asmarketmenu.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketmenu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketmenu.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketmenu.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketmenu.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketmenu.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketMenuMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, asmarketmenu.FieldSort)
	}
	if m.addreform_status != nil {
		fields = append(fields, asmarketmenu.FieldReformStatus)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketmenu.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketmenu.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketmenu.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketmenu.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketMenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketmenu.FieldSort:
		return m.AddedSort()
	case asmarketmenu.FieldReformStatus:
		return m.AddedReformStatus()
	case asmarketmenu.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketmenu.FieldStatus:
		return m.AddedStatus()
	case asmarketmenu.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketmenu.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketMenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketmenu.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case asmarketmenu.FieldReformStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReformStatus(v)
		return nil
	case asmarketmenu.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketmenu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketmenu.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketmenu.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketMenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketmenu.FieldAppID) {
		fields = append(fields, asmarketmenu.FieldAppID)
	}
	if m.FieldCleared(asmarketmenu.FieldParentID) {
		fields = append(fields, asmarketmenu.FieldParentID)
	}
	if m.FieldCleared(asmarketmenu.FieldMenuName) {
		fields = append(fields, asmarketmenu.FieldMenuName)
	}
	if m.FieldCleared(asmarketmenu.FieldMenuURL) {
		fields = append(fields, asmarketmenu.FieldMenuURL)
	}
	if m.FieldCleared(asmarketmenu.FieldMenuColumn) {
		fields = append(fields, asmarketmenu.FieldMenuColumn)
	}
	if m.FieldCleared(asmarketmenu.FieldIcon) {
		fields = append(fields, asmarketmenu.FieldIcon)
	}
	if m.FieldCleared(asmarketmenu.FieldSort) {
		fields = append(fields, asmarketmenu.FieldSort)
	}
	if m.FieldCleared(asmarketmenu.FieldHTTPSMenuURL) {
		fields = append(fields, asmarketmenu.FieldHTTPSMenuURL)
	}
	if m.FieldCleared(asmarketmenu.FieldOutIPMenuURL) {
		fields = append(fields, asmarketmenu.FieldOutIPMenuURL)
	}
	if m.FieldCleared(asmarketmenu.FieldStatus) {
		fields = append(fields, asmarketmenu.FieldStatus)
	}
	if m.FieldCleared(asmarketmenu.FieldCreateUser) {
		fields = append(fields, asmarketmenu.FieldCreateUser)
	}
	if m.FieldCleared(asmarketmenu.FieldUpdateUser) {
		fields = append(fields, asmarketmenu.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketmenu.FieldCreateTime) {
		fields = append(fields, asmarketmenu.FieldCreateTime)
	}
	if m.FieldCleared(asmarketmenu.FieldUpdateTime) {
		fields = append(fields, asmarketmenu.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketMenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketMenuMutation) ClearField(name string) error {
	switch name {
	case asmarketmenu.FieldAppID:
		m.ClearAppID()
		return nil
	case asmarketmenu.FieldParentID:
		m.ClearParentID()
		return nil
	case asmarketmenu.FieldMenuName:
		m.ClearMenuName()
		return nil
	case asmarketmenu.FieldMenuURL:
		m.ClearMenuURL()
		return nil
	case asmarketmenu.FieldMenuColumn:
		m.ClearMenuColumn()
		return nil
	case asmarketmenu.FieldIcon:
		m.ClearIcon()
		return nil
	case asmarketmenu.FieldSort:
		m.ClearSort()
		return nil
	case asmarketmenu.FieldHTTPSMenuURL:
		m.ClearHTTPSMenuURL()
		return nil
	case asmarketmenu.FieldOutIPMenuURL:
		m.ClearOutIPMenuURL()
		return nil
	case asmarketmenu.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketmenu.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketmenu.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketmenu.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketmenu.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketMenuMutation) ResetField(name string) error {
	switch name {
	case asmarketmenu.FieldAppID:
		m.ResetAppID()
		return nil
	case asmarketmenu.FieldParentID:
		m.ResetParentID()
		return nil
	case asmarketmenu.FieldMenuName:
		m.ResetMenuName()
		return nil
	case asmarketmenu.FieldMenuURL:
		m.ResetMenuURL()
		return nil
	case asmarketmenu.FieldMenuColumn:
		m.ResetMenuColumn()
		return nil
	case asmarketmenu.FieldIcon:
		m.ResetIcon()
		return nil
	case asmarketmenu.FieldSort:
		m.ResetSort()
		return nil
	case asmarketmenu.FieldHTTPSMenuURL:
		m.ResetHTTPSMenuURL()
		return nil
	case asmarketmenu.FieldReformStatus:
		m.ResetReformStatus()
		return nil
	case asmarketmenu.FieldOutIPMenuURL:
		m.ResetOutIPMenuURL()
		return nil
	case asmarketmenu.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketmenu.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketmenu.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketmenu.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketmenu.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketmenu.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketMenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.parent != nil {
		edges = append(edges, asmarketmenu.EdgeParent)
	}
	if m.childrens != nil {
		edges = append(edges, asmarketmenu.EdgeChildrens)
	}
	if m.appx != nil {
		edges = append(edges, asmarketmenu.EdgeAppx)
	}
	if m.roleMenus != nil {
		edges = append(edges, asmarketmenu.EdgeRoleMenus)
	}
	if m.roles != nil {
		edges = append(edges, asmarketmenu.EdgeRoles)
	}
	if m._UserSorts != nil {
		edges = append(edges, asmarketmenu.EdgeUserSorts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketMenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketmenu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case asmarketmenu.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.childrens))
		for id := range m.childrens {
			ids = append(ids, id)
		}
		return ids
	case asmarketmenu.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	case asmarketmenu.EdgeRoleMenus:
		ids := make([]ent.Value, 0, len(m.roleMenus))
		for id := range m.roleMenus {
			ids = append(ids, id)
		}
		return ids
	case asmarketmenu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case asmarketmenu.EdgeUserSorts:
		ids := make([]ent.Value, 0, len(m._UserSorts))
		for id := range m._UserSorts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketMenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedchildrens != nil {
		edges = append(edges, asmarketmenu.EdgeChildrens)
	}
	if m.removedroleMenus != nil {
		edges = append(edges, asmarketmenu.EdgeRoleMenus)
	}
	if m.removedroles != nil {
		edges = append(edges, asmarketmenu.EdgeRoles)
	}
	if m.removed_UserSorts != nil {
		edges = append(edges, asmarketmenu.EdgeUserSorts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketMenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asmarketmenu.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.removedchildrens))
		for id := range m.removedchildrens {
			ids = append(ids, id)
		}
		return ids
	case asmarketmenu.EdgeRoleMenus:
		ids := make([]ent.Value, 0, len(m.removedroleMenus))
		for id := range m.removedroleMenus {
			ids = append(ids, id)
		}
		return ids
	case asmarketmenu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case asmarketmenu.EdgeUserSorts:
		ids := make([]ent.Value, 0, len(m.removed_UserSorts))
		for id := range m.removed_UserSorts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketMenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedparent {
		edges = append(edges, asmarketmenu.EdgeParent)
	}
	if m.clearedchildrens {
		edges = append(edges, asmarketmenu.EdgeChildrens)
	}
	if m.clearedappx {
		edges = append(edges, asmarketmenu.EdgeAppx)
	}
	if m.clearedroleMenus {
		edges = append(edges, asmarketmenu.EdgeRoleMenus)
	}
	if m.clearedroles {
		edges = append(edges, asmarketmenu.EdgeRoles)
	}
	if m.cleared_UserSorts {
		edges = append(edges, asmarketmenu.EdgeUserSorts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketMenuMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketmenu.EdgeParent:
		return m.clearedparent
	case asmarketmenu.EdgeChildrens:
		return m.clearedchildrens
	case asmarketmenu.EdgeAppx:
		return m.clearedappx
	case asmarketmenu.EdgeRoleMenus:
		return m.clearedroleMenus
	case asmarketmenu.EdgeRoles:
		return m.clearedroles
	case asmarketmenu.EdgeUserSorts:
		return m.cleared_UserSorts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketMenuMutation) ClearEdge(name string) error {
	switch name {
	case asmarketmenu.EdgeParent:
		m.ClearParent()
		return nil
	case asmarketmenu.EdgeAppx:
		m.ClearAppx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketMenuMutation) ResetEdge(name string) error {
	switch name {
	case asmarketmenu.EdgeParent:
		m.ResetParent()
		return nil
	case asmarketmenu.EdgeChildrens:
		m.ResetChildrens()
		return nil
	case asmarketmenu.EdgeAppx:
		m.ResetAppx()
		return nil
	case asmarketmenu.EdgeRoleMenus:
		m.ResetRoleMenus()
		return nil
	case asmarketmenu.EdgeRoles:
		m.ResetRoles()
		return nil
	case asmarketmenu.EdgeUserSorts:
		m.ResetUserSorts()
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenu edge %s", name)
}

// AsMarketMenuUserSortMutation represents an operation that mutates the AsMarketMenuUserSort nodes in the graph.
type AsMarketMenuUserSortMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	sort            *int64
	addsort         *int64
	is_deleted      *int64
	addis_deleted   *int64
	status          *int64
	addstatus       *int64
	create_user     *int64
	addcreate_user  *int64
	update_user     *int64
	addupdate_user  *int64
	create_time     *date.DateTime
	update_time     *date.DateTime
	clearedFields   map[string]struct{}
	userx           *int64
	cleareduserx    bool
	appmenux        *int64
	clearedappmenux bool
	done            bool
	oldValue        func(context.Context) (*AsMarketMenuUserSort, error)
	predicates      []predicate.AsMarketMenuUserSort
}

var _ ent.Mutation = (*AsMarketMenuUserSortMutation)(nil)

// asmarketmenuusersortOption allows management of the mutation configuration using functional options.
type asmarketmenuusersortOption func(*AsMarketMenuUserSortMutation)

// newAsMarketMenuUserSortMutation creates new mutation for the AsMarketMenuUserSort entity.
func newAsMarketMenuUserSortMutation(c config, op Op, opts ...asmarketmenuusersortOption) *AsMarketMenuUserSortMutation {
	m := &AsMarketMenuUserSortMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketMenuUserSort,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketMenuUserSortID sets the ID field of the mutation.
func withAsMarketMenuUserSortID(id int64) asmarketmenuusersortOption {
	return func(m *AsMarketMenuUserSortMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketMenuUserSort
		)
		m.oldValue = func(ctx context.Context) (*AsMarketMenuUserSort, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketMenuUserSort.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketMenuUserSort sets the old AsMarketMenuUserSort of the mutation.
func withAsMarketMenuUserSort(node *AsMarketMenuUserSort) asmarketmenuusersortOption {
	return func(m *AsMarketMenuUserSortMutation) {
		m.oldValue = func(context.Context) (*AsMarketMenuUserSort, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketMenuUserSortMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketMenuUserSortMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketMenuUserSort entities.
func (m *AsMarketMenuUserSortMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketMenuUserSortMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketMenuUserSortMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketMenuUserSort.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AsMarketMenuUserSortMutation) SetUserID(i int64) {
	m.userx = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AsMarketMenuUserSortMutation) UserID() (r int64, exists bool) {
	v := m.userx
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AsMarketMenuUserSort entity.
// If the AsMarketMenuUserSort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuUserSortMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AsMarketMenuUserSortMutation) ClearUserID() {
	m.userx = nil
	m.clearedFields[asmarketmenuusersort.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[asmarketmenuusersort.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AsMarketMenuUserSortMutation) ResetUserID() {
	m.userx = nil
	delete(m.clearedFields, asmarketmenuusersort.FieldUserID)
}

// SetMenuID sets the "menu_id" field.
func (m *AsMarketMenuUserSortMutation) SetMenuID(i int64) {
	m.appmenux = &i
}

// MenuID returns the value of the "menu_id" field in the mutation.
func (m *AsMarketMenuUserSortMutation) MenuID() (r int64, exists bool) {
	v := m.appmenux
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuID returns the old "menu_id" field's value of the AsMarketMenuUserSort entity.
// If the AsMarketMenuUserSort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuUserSortMutation) OldMenuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuID: %w", err)
	}
	return oldValue.MenuID, nil
}

// ClearMenuID clears the value of the "menu_id" field.
func (m *AsMarketMenuUserSortMutation) ClearMenuID() {
	m.appmenux = nil
	m.clearedFields[asmarketmenuusersort.FieldMenuID] = struct{}{}
}

// MenuIDCleared returns if the "menu_id" field was cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) MenuIDCleared() bool {
	_, ok := m.clearedFields[asmarketmenuusersort.FieldMenuID]
	return ok
}

// ResetMenuID resets all changes to the "menu_id" field.
func (m *AsMarketMenuUserSortMutation) ResetMenuID() {
	m.appmenux = nil
	delete(m.clearedFields, asmarketmenuusersort.FieldMenuID)
}

// SetSort sets the "sort" field.
func (m *AsMarketMenuUserSortMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AsMarketMenuUserSortMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the AsMarketMenuUserSort entity.
// If the AsMarketMenuUserSort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuUserSortMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AsMarketMenuUserSortMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AsMarketMenuUserSortMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *AsMarketMenuUserSortMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[asmarketmenuusersort.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) SortCleared() bool {
	_, ok := m.clearedFields[asmarketmenuusersort.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *AsMarketMenuUserSortMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, asmarketmenuusersort.FieldSort)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketMenuUserSortMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketMenuUserSortMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketMenuUserSort entity.
// If the AsMarketMenuUserSort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuUserSortMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketMenuUserSortMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketMenuUserSortMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketMenuUserSortMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketMenuUserSortMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketMenuUserSortMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketMenuUserSort entity.
// If the AsMarketMenuUserSort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuUserSortMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketMenuUserSortMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketMenuUserSortMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketMenuUserSortMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketmenuusersort.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketmenuusersort.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketMenuUserSortMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketmenuusersort.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketMenuUserSortMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketMenuUserSortMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketMenuUserSort entity.
// If the AsMarketMenuUserSort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuUserSortMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketMenuUserSortMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketMenuUserSortMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketMenuUserSortMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketmenuusersort.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketmenuusersort.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketMenuUserSortMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketmenuusersort.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketMenuUserSortMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketMenuUserSortMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketMenuUserSort entity.
// If the AsMarketMenuUserSort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuUserSortMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketMenuUserSortMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketMenuUserSortMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketMenuUserSortMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketmenuusersort.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketmenuusersort.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketMenuUserSortMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketmenuusersort.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketMenuUserSortMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketMenuUserSortMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketMenuUserSort entity.
// If the AsMarketMenuUserSort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuUserSortMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketMenuUserSortMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketmenuusersort.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketmenuusersort.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketMenuUserSortMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketmenuusersort.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketMenuUserSortMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketMenuUserSortMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketMenuUserSort entity.
// If the AsMarketMenuUserSort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketMenuUserSortMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketMenuUserSortMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketmenuusersort.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketmenuusersort.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketMenuUserSortMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketmenuusersort.FieldUpdateTime)
}

// SetUserxID sets the "userx" edge to the AsUser entity by id.
func (m *AsMarketMenuUserSortMutation) SetUserxID(id int64) {
	m.userx = &id
}

// ClearUserx clears the "userx" edge to the AsUser entity.
func (m *AsMarketMenuUserSortMutation) ClearUserx() {
	m.cleareduserx = true
}

// UserxCleared reports if the "userx" edge to the AsUser entity was cleared.
func (m *AsMarketMenuUserSortMutation) UserxCleared() bool {
	return m.UserIDCleared() || m.cleareduserx
}

// UserxID returns the "userx" edge ID in the mutation.
func (m *AsMarketMenuUserSortMutation) UserxID() (id int64, exists bool) {
	if m.userx != nil {
		return *m.userx, true
	}
	return
}

// UserxIDs returns the "userx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserxID instead. It exists only for internal usage by the builders.
func (m *AsMarketMenuUserSortMutation) UserxIDs() (ids []int64) {
	if id := m.userx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserx resets all changes to the "userx" edge.
func (m *AsMarketMenuUserSortMutation) ResetUserx() {
	m.userx = nil
	m.cleareduserx = false
}

// SetAppmenuxID sets the "appmenux" edge to the AsMarketMenu entity by id.
func (m *AsMarketMenuUserSortMutation) SetAppmenuxID(id int64) {
	m.appmenux = &id
}

// ClearAppmenux clears the "appmenux" edge to the AsMarketMenu entity.
func (m *AsMarketMenuUserSortMutation) ClearAppmenux() {
	m.clearedappmenux = true
}

// AppmenuxCleared reports if the "appmenux" edge to the AsMarketMenu entity was cleared.
func (m *AsMarketMenuUserSortMutation) AppmenuxCleared() bool {
	return m.MenuIDCleared() || m.clearedappmenux
}

// AppmenuxID returns the "appmenux" edge ID in the mutation.
func (m *AsMarketMenuUserSortMutation) AppmenuxID() (id int64, exists bool) {
	if m.appmenux != nil {
		return *m.appmenux, true
	}
	return
}

// AppmenuxIDs returns the "appmenux" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppmenuxID instead. It exists only for internal usage by the builders.
func (m *AsMarketMenuUserSortMutation) AppmenuxIDs() (ids []int64) {
	if id := m.appmenux; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppmenux resets all changes to the "appmenux" edge.
func (m *AsMarketMenuUserSortMutation) ResetAppmenux() {
	m.appmenux = nil
	m.clearedappmenux = false
}

// Where appends a list predicates to the AsMarketMenuUserSortMutation builder.
func (m *AsMarketMenuUserSortMutation) Where(ps ...predicate.AsMarketMenuUserSort) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketMenuUserSortMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketMenuUserSort).
func (m *AsMarketMenuUserSortMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketMenuUserSortMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.userx != nil {
		fields = append(fields, asmarketmenuusersort.FieldUserID)
	}
	if m.appmenux != nil {
		fields = append(fields, asmarketmenuusersort.FieldMenuID)
	}
	if m.sort != nil {
		fields = append(fields, asmarketmenuusersort.FieldSort)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketmenuusersort.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketmenuusersort.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketmenuusersort.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketmenuusersort.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketmenuusersort.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketmenuusersort.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketMenuUserSortMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketmenuusersort.FieldUserID:
		return m.UserID()
	case asmarketmenuusersort.FieldMenuID:
		return m.MenuID()
	case asmarketmenuusersort.FieldSort:
		return m.Sort()
	case asmarketmenuusersort.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketmenuusersort.FieldStatus:
		return m.Status()
	case asmarketmenuusersort.FieldCreateUser:
		return m.CreateUser()
	case asmarketmenuusersort.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketmenuusersort.FieldCreateTime:
		return m.CreateTime()
	case asmarketmenuusersort.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketMenuUserSortMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketmenuusersort.FieldUserID:
		return m.OldUserID(ctx)
	case asmarketmenuusersort.FieldMenuID:
		return m.OldMenuID(ctx)
	case asmarketmenuusersort.FieldSort:
		return m.OldSort(ctx)
	case asmarketmenuusersort.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketmenuusersort.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketmenuusersort.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketmenuusersort.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketmenuusersort.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketmenuusersort.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketMenuUserSort field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketMenuUserSortMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketmenuusersort.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case asmarketmenuusersort.FieldMenuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuID(v)
		return nil
	case asmarketmenuusersort.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case asmarketmenuusersort.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketmenuusersort.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketmenuusersort.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketmenuusersort.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketmenuusersort.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketmenuusersort.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenuUserSort field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketMenuUserSortMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, asmarketmenuusersort.FieldSort)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketmenuusersort.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketmenuusersort.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketmenuusersort.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketmenuusersort.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketMenuUserSortMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketmenuusersort.FieldSort:
		return m.AddedSort()
	case asmarketmenuusersort.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketmenuusersort.FieldStatus:
		return m.AddedStatus()
	case asmarketmenuusersort.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketmenuusersort.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketMenuUserSortMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketmenuusersort.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case asmarketmenuusersort.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketmenuusersort.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketmenuusersort.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketmenuusersort.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenuUserSort numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketMenuUserSortMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketmenuusersort.FieldUserID) {
		fields = append(fields, asmarketmenuusersort.FieldUserID)
	}
	if m.FieldCleared(asmarketmenuusersort.FieldMenuID) {
		fields = append(fields, asmarketmenuusersort.FieldMenuID)
	}
	if m.FieldCleared(asmarketmenuusersort.FieldSort) {
		fields = append(fields, asmarketmenuusersort.FieldSort)
	}
	if m.FieldCleared(asmarketmenuusersort.FieldStatus) {
		fields = append(fields, asmarketmenuusersort.FieldStatus)
	}
	if m.FieldCleared(asmarketmenuusersort.FieldCreateUser) {
		fields = append(fields, asmarketmenuusersort.FieldCreateUser)
	}
	if m.FieldCleared(asmarketmenuusersort.FieldUpdateUser) {
		fields = append(fields, asmarketmenuusersort.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketmenuusersort.FieldCreateTime) {
		fields = append(fields, asmarketmenuusersort.FieldCreateTime)
	}
	if m.FieldCleared(asmarketmenuusersort.FieldUpdateTime) {
		fields = append(fields, asmarketmenuusersort.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketMenuUserSortMutation) ClearField(name string) error {
	switch name {
	case asmarketmenuusersort.FieldUserID:
		m.ClearUserID()
		return nil
	case asmarketmenuusersort.FieldMenuID:
		m.ClearMenuID()
		return nil
	case asmarketmenuusersort.FieldSort:
		m.ClearSort()
		return nil
	case asmarketmenuusersort.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketmenuusersort.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketmenuusersort.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketmenuusersort.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketmenuusersort.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenuUserSort nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketMenuUserSortMutation) ResetField(name string) error {
	switch name {
	case asmarketmenuusersort.FieldUserID:
		m.ResetUserID()
		return nil
	case asmarketmenuusersort.FieldMenuID:
		m.ResetMenuID()
		return nil
	case asmarketmenuusersort.FieldSort:
		m.ResetSort()
		return nil
	case asmarketmenuusersort.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketmenuusersort.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketmenuusersort.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketmenuusersort.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketmenuusersort.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketmenuusersort.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenuUserSort field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketMenuUserSortMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.userx != nil {
		edges = append(edges, asmarketmenuusersort.EdgeUserx)
	}
	if m.appmenux != nil {
		edges = append(edges, asmarketmenuusersort.EdgeAppmenux)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketMenuUserSortMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketmenuusersort.EdgeUserx:
		if id := m.userx; id != nil {
			return []ent.Value{*id}
		}
	case asmarketmenuusersort.EdgeAppmenux:
		if id := m.appmenux; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketMenuUserSortMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketMenuUserSortMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduserx {
		edges = append(edges, asmarketmenuusersort.EdgeUserx)
	}
	if m.clearedappmenux {
		edges = append(edges, asmarketmenuusersort.EdgeAppmenux)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketMenuUserSortMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketmenuusersort.EdgeUserx:
		return m.cleareduserx
	case asmarketmenuusersort.EdgeAppmenux:
		return m.clearedappmenux
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketMenuUserSortMutation) ClearEdge(name string) error {
	switch name {
	case asmarketmenuusersort.EdgeUserx:
		m.ClearUserx()
		return nil
	case asmarketmenuusersort.EdgeAppmenux:
		m.ClearAppmenux()
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenuUserSort unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketMenuUserSortMutation) ResetEdge(name string) error {
	switch name {
	case asmarketmenuusersort.EdgeUserx:
		m.ResetUserx()
		return nil
	case asmarketmenuusersort.EdgeAppmenux:
		m.ResetAppmenux()
		return nil
	}
	return fmt.Errorf("unknown AsMarketMenuUserSort edge %s", name)
}

// AsMarketRoleDistributionMutation represents an operation that mutates the AsMarketRoleDistribution nodes in the graph.
type AsMarketRoleDistributionMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	tenant_code    *string
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	userx          *int64
	cleareduserx   bool
	agencyx        *int64
	clearedagencyx bool
	jobx           *int64
	clearedjobx    bool
	rolex          *int64
	clearedrolex   bool
	done           bool
	oldValue       func(context.Context) (*AsMarketRoleDistribution, error)
	predicates     []predicate.AsMarketRoleDistribution
}

var _ ent.Mutation = (*AsMarketRoleDistributionMutation)(nil)

// asmarketroledistributionOption allows management of the mutation configuration using functional options.
type asmarketroledistributionOption func(*AsMarketRoleDistributionMutation)

// newAsMarketRoleDistributionMutation creates new mutation for the AsMarketRoleDistribution entity.
func newAsMarketRoleDistributionMutation(c config, op Op, opts ...asmarketroledistributionOption) *AsMarketRoleDistributionMutation {
	m := &AsMarketRoleDistributionMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketRoleDistribution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketRoleDistributionID sets the ID field of the mutation.
func withAsMarketRoleDistributionID(id int64) asmarketroledistributionOption {
	return func(m *AsMarketRoleDistributionMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketRoleDistribution
		)
		m.oldValue = func(ctx context.Context) (*AsMarketRoleDistribution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketRoleDistribution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketRoleDistribution sets the old AsMarketRoleDistribution of the mutation.
func withAsMarketRoleDistribution(node *AsMarketRoleDistribution) asmarketroledistributionOption {
	return func(m *AsMarketRoleDistributionMutation) {
		m.oldValue = func(context.Context) (*AsMarketRoleDistribution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketRoleDistributionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketRoleDistributionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketRoleDistribution entities.
func (m *AsMarketRoleDistributionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketRoleDistributionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketRoleDistributionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketRoleDistribution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleID sets the "role_id" field.
func (m *AsMarketRoleDistributionMutation) SetRoleID(i int64) {
	m.rolex = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AsMarketRoleDistributionMutation) RoleID() (r int64, exists bool) {
	v := m.rolex
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *AsMarketRoleDistributionMutation) ClearRoleID() {
	m.rolex = nil
	m.clearedFields[asmarketroledistribution.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[asmarketroledistribution.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AsMarketRoleDistributionMutation) ResetRoleID() {
	m.rolex = nil
	delete(m.clearedFields, asmarketroledistribution.FieldRoleID)
}

// SetUserID sets the "user_id" field.
func (m *AsMarketRoleDistributionMutation) SetUserID(i int64) {
	m.userx = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AsMarketRoleDistributionMutation) UserID() (r int64, exists bool) {
	v := m.userx
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AsMarketRoleDistributionMutation) ClearUserID() {
	m.userx = nil
	m.clearedFields[asmarketroledistribution.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[asmarketroledistribution.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AsMarketRoleDistributionMutation) ResetUserID() {
	m.userx = nil
	delete(m.clearedFields, asmarketroledistribution.FieldUserID)
}

// SetAgencyID sets the "agency_id" field.
func (m *AsMarketRoleDistributionMutation) SetAgencyID(i int64) {
	m.agencyx = &i
}

// AgencyID returns the value of the "agency_id" field in the mutation.
func (m *AsMarketRoleDistributionMutation) AgencyID() (r int64, exists bool) {
	v := m.agencyx
	if v == nil {
		return
	}
	return *v, true
}

// OldAgencyID returns the old "agency_id" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldAgencyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgencyID: %w", err)
	}
	return oldValue.AgencyID, nil
}

// ClearAgencyID clears the value of the "agency_id" field.
func (m *AsMarketRoleDistributionMutation) ClearAgencyID() {
	m.agencyx = nil
	m.clearedFields[asmarketroledistribution.FieldAgencyID] = struct{}{}
}

// AgencyIDCleared returns if the "agency_id" field was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) AgencyIDCleared() bool {
	_, ok := m.clearedFields[asmarketroledistribution.FieldAgencyID]
	return ok
}

// ResetAgencyID resets all changes to the "agency_id" field.
func (m *AsMarketRoleDistributionMutation) ResetAgencyID() {
	m.agencyx = nil
	delete(m.clearedFields, asmarketroledistribution.FieldAgencyID)
}

// SetJobID sets the "job_id" field.
func (m *AsMarketRoleDistributionMutation) SetJobID(i int64) {
	m.jobx = &i
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *AsMarketRoleDistributionMutation) JobID() (r int64, exists bool) {
	v := m.jobx
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldJobID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ClearJobID clears the value of the "job_id" field.
func (m *AsMarketRoleDistributionMutation) ClearJobID() {
	m.jobx = nil
	m.clearedFields[asmarketroledistribution.FieldJobID] = struct{}{}
}

// JobIDCleared returns if the "job_id" field was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) JobIDCleared() bool {
	_, ok := m.clearedFields[asmarketroledistribution.FieldJobID]
	return ok
}

// ResetJobID resets all changes to the "job_id" field.
func (m *AsMarketRoleDistributionMutation) ResetJobID() {
	m.jobx = nil
	delete(m.clearedFields, asmarketroledistribution.FieldJobID)
}

// SetTenantCode sets the "tenant_code" field.
func (m *AsMarketRoleDistributionMutation) SetTenantCode(s string) {
	m.tenant_code = &s
}

// TenantCode returns the value of the "tenant_code" field in the mutation.
func (m *AsMarketRoleDistributionMutation) TenantCode() (r string, exists bool) {
	v := m.tenant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantCode returns the old "tenant_code" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldTenantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantCode: %w", err)
	}
	return oldValue.TenantCode, nil
}

// ClearTenantCode clears the value of the "tenant_code" field.
func (m *AsMarketRoleDistributionMutation) ClearTenantCode() {
	m.tenant_code = nil
	m.clearedFields[asmarketroledistribution.FieldTenantCode] = struct{}{}
}

// TenantCodeCleared returns if the "tenant_code" field was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) TenantCodeCleared() bool {
	_, ok := m.clearedFields[asmarketroledistribution.FieldTenantCode]
	return ok
}

// ResetTenantCode resets all changes to the "tenant_code" field.
func (m *AsMarketRoleDistributionMutation) ResetTenantCode() {
	m.tenant_code = nil
	delete(m.clearedFields, asmarketroledistribution.FieldTenantCode)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketRoleDistributionMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketRoleDistributionMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketRoleDistributionMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketRoleDistributionMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketRoleDistributionMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketRoleDistributionMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketRoleDistributionMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketRoleDistributionMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketRoleDistributionMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketRoleDistributionMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketroledistribution.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketroledistribution.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketRoleDistributionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketroledistribution.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketRoleDistributionMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketRoleDistributionMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketRoleDistributionMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketRoleDistributionMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketRoleDistributionMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketroledistribution.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketroledistribution.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketRoleDistributionMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketroledistribution.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketRoleDistributionMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketRoleDistributionMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketRoleDistributionMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketRoleDistributionMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketRoleDistributionMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketroledistribution.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketroledistribution.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketRoleDistributionMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketroledistribution.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketRoleDistributionMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketRoleDistributionMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketRoleDistributionMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketroledistribution.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketroledistribution.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketRoleDistributionMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketroledistribution.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketRoleDistributionMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketRoleDistributionMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketRoleDistribution entity.
// If the AsMarketRoleDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleDistributionMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketRoleDistributionMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketroledistribution.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketroledistribution.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketRoleDistributionMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketroledistribution.FieldUpdateTime)
}

// SetUserxID sets the "userx" edge to the AsUser entity by id.
func (m *AsMarketRoleDistributionMutation) SetUserxID(id int64) {
	m.userx = &id
}

// ClearUserx clears the "userx" edge to the AsUser entity.
func (m *AsMarketRoleDistributionMutation) ClearUserx() {
	m.cleareduserx = true
}

// UserxCleared reports if the "userx" edge to the AsUser entity was cleared.
func (m *AsMarketRoleDistributionMutation) UserxCleared() bool {
	return m.UserIDCleared() || m.cleareduserx
}

// UserxID returns the "userx" edge ID in the mutation.
func (m *AsMarketRoleDistributionMutation) UserxID() (id int64, exists bool) {
	if m.userx != nil {
		return *m.userx, true
	}
	return
}

// UserxIDs returns the "userx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserxID instead. It exists only for internal usage by the builders.
func (m *AsMarketRoleDistributionMutation) UserxIDs() (ids []int64) {
	if id := m.userx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserx resets all changes to the "userx" edge.
func (m *AsMarketRoleDistributionMutation) ResetUserx() {
	m.userx = nil
	m.cleareduserx = false
}

// SetAgencyxID sets the "agencyx" edge to the AsInnerAgency entity by id.
func (m *AsMarketRoleDistributionMutation) SetAgencyxID(id int64) {
	m.agencyx = &id
}

// ClearAgencyx clears the "agencyx" edge to the AsInnerAgency entity.
func (m *AsMarketRoleDistributionMutation) ClearAgencyx() {
	m.clearedagencyx = true
}

// AgencyxCleared reports if the "agencyx" edge to the AsInnerAgency entity was cleared.
func (m *AsMarketRoleDistributionMutation) AgencyxCleared() bool {
	return m.AgencyIDCleared() || m.clearedagencyx
}

// AgencyxID returns the "agencyx" edge ID in the mutation.
func (m *AsMarketRoleDistributionMutation) AgencyxID() (id int64, exists bool) {
	if m.agencyx != nil {
		return *m.agencyx, true
	}
	return
}

// AgencyxIDs returns the "agencyx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgencyxID instead. It exists only for internal usage by the builders.
func (m *AsMarketRoleDistributionMutation) AgencyxIDs() (ids []int64) {
	if id := m.agencyx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgencyx resets all changes to the "agencyx" edge.
func (m *AsMarketRoleDistributionMutation) ResetAgencyx() {
	m.agencyx = nil
	m.clearedagencyx = false
}

// SetJobxID sets the "jobx" edge to the AsJob entity by id.
func (m *AsMarketRoleDistributionMutation) SetJobxID(id int64) {
	m.jobx = &id
}

// ClearJobx clears the "jobx" edge to the AsJob entity.
func (m *AsMarketRoleDistributionMutation) ClearJobx() {
	m.clearedjobx = true
}

// JobxCleared reports if the "jobx" edge to the AsJob entity was cleared.
func (m *AsMarketRoleDistributionMutation) JobxCleared() bool {
	return m.JobIDCleared() || m.clearedjobx
}

// JobxID returns the "jobx" edge ID in the mutation.
func (m *AsMarketRoleDistributionMutation) JobxID() (id int64, exists bool) {
	if m.jobx != nil {
		return *m.jobx, true
	}
	return
}

// JobxIDs returns the "jobx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobxID instead. It exists only for internal usage by the builders.
func (m *AsMarketRoleDistributionMutation) JobxIDs() (ids []int64) {
	if id := m.jobx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobx resets all changes to the "jobx" edge.
func (m *AsMarketRoleDistributionMutation) ResetJobx() {
	m.jobx = nil
	m.clearedjobx = false
}

// SetRolexID sets the "rolex" edge to the AsMarketAppRole entity by id.
func (m *AsMarketRoleDistributionMutation) SetRolexID(id int64) {
	m.rolex = &id
}

// ClearRolex clears the "rolex" edge to the AsMarketAppRole entity.
func (m *AsMarketRoleDistributionMutation) ClearRolex() {
	m.clearedrolex = true
}

// RolexCleared reports if the "rolex" edge to the AsMarketAppRole entity was cleared.
func (m *AsMarketRoleDistributionMutation) RolexCleared() bool {
	return m.RoleIDCleared() || m.clearedrolex
}

// RolexID returns the "rolex" edge ID in the mutation.
func (m *AsMarketRoleDistributionMutation) RolexID() (id int64, exists bool) {
	if m.rolex != nil {
		return *m.rolex, true
	}
	return
}

// RolexIDs returns the "rolex" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolexID instead. It exists only for internal usage by the builders.
func (m *AsMarketRoleDistributionMutation) RolexIDs() (ids []int64) {
	if id := m.rolex; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRolex resets all changes to the "rolex" edge.
func (m *AsMarketRoleDistributionMutation) ResetRolex() {
	m.rolex = nil
	m.clearedrolex = false
}

// Where appends a list predicates to the AsMarketRoleDistributionMutation builder.
func (m *AsMarketRoleDistributionMutation) Where(ps ...predicate.AsMarketRoleDistribution) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketRoleDistributionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketRoleDistribution).
func (m *AsMarketRoleDistributionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketRoleDistributionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.rolex != nil {
		fields = append(fields, asmarketroledistribution.FieldRoleID)
	}
	if m.userx != nil {
		fields = append(fields, asmarketroledistribution.FieldUserID)
	}
	if m.agencyx != nil {
		fields = append(fields, asmarketroledistribution.FieldAgencyID)
	}
	if m.jobx != nil {
		fields = append(fields, asmarketroledistribution.FieldJobID)
	}
	if m.tenant_code != nil {
		fields = append(fields, asmarketroledistribution.FieldTenantCode)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketroledistribution.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketroledistribution.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketroledistribution.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketroledistribution.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketroledistribution.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketroledistribution.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketRoleDistributionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketroledistribution.FieldRoleID:
		return m.RoleID()
	case asmarketroledistribution.FieldUserID:
		return m.UserID()
	case asmarketroledistribution.FieldAgencyID:
		return m.AgencyID()
	case asmarketroledistribution.FieldJobID:
		return m.JobID()
	case asmarketroledistribution.FieldTenantCode:
		return m.TenantCode()
	case asmarketroledistribution.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketroledistribution.FieldStatus:
		return m.Status()
	case asmarketroledistribution.FieldCreateUser:
		return m.CreateUser()
	case asmarketroledistribution.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketroledistribution.FieldCreateTime:
		return m.CreateTime()
	case asmarketroledistribution.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketRoleDistributionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketroledistribution.FieldRoleID:
		return m.OldRoleID(ctx)
	case asmarketroledistribution.FieldUserID:
		return m.OldUserID(ctx)
	case asmarketroledistribution.FieldAgencyID:
		return m.OldAgencyID(ctx)
	case asmarketroledistribution.FieldJobID:
		return m.OldJobID(ctx)
	case asmarketroledistribution.FieldTenantCode:
		return m.OldTenantCode(ctx)
	case asmarketroledistribution.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketroledistribution.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketroledistribution.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketroledistribution.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketroledistribution.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketroledistribution.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketRoleDistribution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketRoleDistributionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketroledistribution.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case asmarketroledistribution.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case asmarketroledistribution.FieldAgencyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgencyID(v)
		return nil
	case asmarketroledistribution.FieldJobID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case asmarketroledistribution.FieldTenantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantCode(v)
		return nil
	case asmarketroledistribution.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketroledistribution.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketroledistribution.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketroledistribution.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketroledistribution.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketroledistribution.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleDistribution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketRoleDistributionMutation) AddedFields() []string {
	var fields []string
	if m.addis_deleted != nil {
		fields = append(fields, asmarketroledistribution.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketroledistribution.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketroledistribution.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketroledistribution.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketRoleDistributionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketroledistribution.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketroledistribution.FieldStatus:
		return m.AddedStatus()
	case asmarketroledistribution.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketroledistribution.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketRoleDistributionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketroledistribution.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketroledistribution.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketroledistribution.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketroledistribution.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleDistribution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketRoleDistributionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketroledistribution.FieldRoleID) {
		fields = append(fields, asmarketroledistribution.FieldRoleID)
	}
	if m.FieldCleared(asmarketroledistribution.FieldUserID) {
		fields = append(fields, asmarketroledistribution.FieldUserID)
	}
	if m.FieldCleared(asmarketroledistribution.FieldAgencyID) {
		fields = append(fields, asmarketroledistribution.FieldAgencyID)
	}
	if m.FieldCleared(asmarketroledistribution.FieldJobID) {
		fields = append(fields, asmarketroledistribution.FieldJobID)
	}
	if m.FieldCleared(asmarketroledistribution.FieldTenantCode) {
		fields = append(fields, asmarketroledistribution.FieldTenantCode)
	}
	if m.FieldCleared(asmarketroledistribution.FieldStatus) {
		fields = append(fields, asmarketroledistribution.FieldStatus)
	}
	if m.FieldCleared(asmarketroledistribution.FieldCreateUser) {
		fields = append(fields, asmarketroledistribution.FieldCreateUser)
	}
	if m.FieldCleared(asmarketroledistribution.FieldUpdateUser) {
		fields = append(fields, asmarketroledistribution.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketroledistribution.FieldCreateTime) {
		fields = append(fields, asmarketroledistribution.FieldCreateTime)
	}
	if m.FieldCleared(asmarketroledistribution.FieldUpdateTime) {
		fields = append(fields, asmarketroledistribution.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketRoleDistributionMutation) ClearField(name string) error {
	switch name {
	case asmarketroledistribution.FieldRoleID:
		m.ClearRoleID()
		return nil
	case asmarketroledistribution.FieldUserID:
		m.ClearUserID()
		return nil
	case asmarketroledistribution.FieldAgencyID:
		m.ClearAgencyID()
		return nil
	case asmarketroledistribution.FieldJobID:
		m.ClearJobID()
		return nil
	case asmarketroledistribution.FieldTenantCode:
		m.ClearTenantCode()
		return nil
	case asmarketroledistribution.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketroledistribution.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketroledistribution.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketroledistribution.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketroledistribution.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleDistribution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketRoleDistributionMutation) ResetField(name string) error {
	switch name {
	case asmarketroledistribution.FieldRoleID:
		m.ResetRoleID()
		return nil
	case asmarketroledistribution.FieldUserID:
		m.ResetUserID()
		return nil
	case asmarketroledistribution.FieldAgencyID:
		m.ResetAgencyID()
		return nil
	case asmarketroledistribution.FieldJobID:
		m.ResetJobID()
		return nil
	case asmarketroledistribution.FieldTenantCode:
		m.ResetTenantCode()
		return nil
	case asmarketroledistribution.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketroledistribution.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketroledistribution.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketroledistribution.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketroledistribution.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketroledistribution.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleDistribution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketRoleDistributionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.userx != nil {
		edges = append(edges, asmarketroledistribution.EdgeUserx)
	}
	if m.agencyx != nil {
		edges = append(edges, asmarketroledistribution.EdgeAgencyx)
	}
	if m.jobx != nil {
		edges = append(edges, asmarketroledistribution.EdgeJobx)
	}
	if m.rolex != nil {
		edges = append(edges, asmarketroledistribution.EdgeRolex)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketRoleDistributionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketroledistribution.EdgeUserx:
		if id := m.userx; id != nil {
			return []ent.Value{*id}
		}
	case asmarketroledistribution.EdgeAgencyx:
		if id := m.agencyx; id != nil {
			return []ent.Value{*id}
		}
	case asmarketroledistribution.EdgeJobx:
		if id := m.jobx; id != nil {
			return []ent.Value{*id}
		}
	case asmarketroledistribution.EdgeRolex:
		if id := m.rolex; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketRoleDistributionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketRoleDistributionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduserx {
		edges = append(edges, asmarketroledistribution.EdgeUserx)
	}
	if m.clearedagencyx {
		edges = append(edges, asmarketroledistribution.EdgeAgencyx)
	}
	if m.clearedjobx {
		edges = append(edges, asmarketroledistribution.EdgeJobx)
	}
	if m.clearedrolex {
		edges = append(edges, asmarketroledistribution.EdgeRolex)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketRoleDistributionMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketroledistribution.EdgeUserx:
		return m.cleareduserx
	case asmarketroledistribution.EdgeAgencyx:
		return m.clearedagencyx
	case asmarketroledistribution.EdgeJobx:
		return m.clearedjobx
	case asmarketroledistribution.EdgeRolex:
		return m.clearedrolex
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketRoleDistributionMutation) ClearEdge(name string) error {
	switch name {
	case asmarketroledistribution.EdgeUserx:
		m.ClearUserx()
		return nil
	case asmarketroledistribution.EdgeAgencyx:
		m.ClearAgencyx()
		return nil
	case asmarketroledistribution.EdgeJobx:
		m.ClearJobx()
		return nil
	case asmarketroledistribution.EdgeRolex:
		m.ClearRolex()
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleDistribution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketRoleDistributionMutation) ResetEdge(name string) error {
	switch name {
	case asmarketroledistribution.EdgeUserx:
		m.ResetUserx()
		return nil
	case asmarketroledistribution.EdgeAgencyx:
		m.ResetAgencyx()
		return nil
	case asmarketroledistribution.EdgeJobx:
		m.ResetJobx()
		return nil
	case asmarketroledistribution.EdgeRolex:
		m.ResetRolex()
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleDistribution edge %s", name)
}

// AsMarketRoleMenuMutation represents an operation that mutates the AsMarketRoleMenu nodes in the graph.
type AsMarketRoleMenuMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	menux          *int64
	clearedmenux   bool
	rolex          *int64
	clearedrolex   bool
	done           bool
	oldValue       func(context.Context) (*AsMarketRoleMenu, error)
	predicates     []predicate.AsMarketRoleMenu
}

var _ ent.Mutation = (*AsMarketRoleMenuMutation)(nil)

// asmarketrolemenuOption allows management of the mutation configuration using functional options.
type asmarketrolemenuOption func(*AsMarketRoleMenuMutation)

// newAsMarketRoleMenuMutation creates new mutation for the AsMarketRoleMenu entity.
func newAsMarketRoleMenuMutation(c config, op Op, opts ...asmarketrolemenuOption) *AsMarketRoleMenuMutation {
	m := &AsMarketRoleMenuMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketRoleMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketRoleMenuID sets the ID field of the mutation.
func withAsMarketRoleMenuID(id int64) asmarketrolemenuOption {
	return func(m *AsMarketRoleMenuMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketRoleMenu
		)
		m.oldValue = func(ctx context.Context) (*AsMarketRoleMenu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketRoleMenu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketRoleMenu sets the old AsMarketRoleMenu of the mutation.
func withAsMarketRoleMenu(node *AsMarketRoleMenu) asmarketrolemenuOption {
	return func(m *AsMarketRoleMenuMutation) {
		m.oldValue = func(context.Context) (*AsMarketRoleMenu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketRoleMenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketRoleMenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketRoleMenu entities.
func (m *AsMarketRoleMenuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketRoleMenuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketRoleMenuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketRoleMenu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleID sets the "role_id" field.
func (m *AsMarketRoleMenuMutation) SetRoleID(i int64) {
	m.rolex = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AsMarketRoleMenuMutation) RoleID() (r int64, exists bool) {
	v := m.rolex
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AsMarketRoleMenu entity.
// If the AsMarketRoleMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleMenuMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *AsMarketRoleMenuMutation) ClearRoleID() {
	m.rolex = nil
	m.clearedFields[asmarketrolemenu.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *AsMarketRoleMenuMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[asmarketrolemenu.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AsMarketRoleMenuMutation) ResetRoleID() {
	m.rolex = nil
	delete(m.clearedFields, asmarketrolemenu.FieldRoleID)
}

// SetMenuID sets the "menu_id" field.
func (m *AsMarketRoleMenuMutation) SetMenuID(i int64) {
	m.menux = &i
}

// MenuID returns the value of the "menu_id" field in the mutation.
func (m *AsMarketRoleMenuMutation) MenuID() (r int64, exists bool) {
	v := m.menux
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuID returns the old "menu_id" field's value of the AsMarketRoleMenu entity.
// If the AsMarketRoleMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleMenuMutation) OldMenuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuID: %w", err)
	}
	return oldValue.MenuID, nil
}

// ClearMenuID clears the value of the "menu_id" field.
func (m *AsMarketRoleMenuMutation) ClearMenuID() {
	m.menux = nil
	m.clearedFields[asmarketrolemenu.FieldMenuID] = struct{}{}
}

// MenuIDCleared returns if the "menu_id" field was cleared in this mutation.
func (m *AsMarketRoleMenuMutation) MenuIDCleared() bool {
	_, ok := m.clearedFields[asmarketrolemenu.FieldMenuID]
	return ok
}

// ResetMenuID resets all changes to the "menu_id" field.
func (m *AsMarketRoleMenuMutation) ResetMenuID() {
	m.menux = nil
	delete(m.clearedFields, asmarketrolemenu.FieldMenuID)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketRoleMenuMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketRoleMenuMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketRoleMenu entity.
// If the AsMarketRoleMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleMenuMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketRoleMenuMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketRoleMenuMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketRoleMenuMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketRoleMenuMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketRoleMenuMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketRoleMenu entity.
// If the AsMarketRoleMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleMenuMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketRoleMenuMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketRoleMenuMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketRoleMenuMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketrolemenu.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketRoleMenuMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketrolemenu.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketRoleMenuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketrolemenu.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketRoleMenuMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketRoleMenuMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketRoleMenu entity.
// If the AsMarketRoleMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleMenuMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketRoleMenuMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketRoleMenuMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketRoleMenuMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketrolemenu.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketRoleMenuMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketrolemenu.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketRoleMenuMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketrolemenu.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketRoleMenuMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketRoleMenuMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketRoleMenu entity.
// If the AsMarketRoleMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleMenuMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketRoleMenuMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketRoleMenuMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketRoleMenuMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketrolemenu.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketRoleMenuMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketrolemenu.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketRoleMenuMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketrolemenu.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketRoleMenuMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketRoleMenuMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketRoleMenu entity.
// If the AsMarketRoleMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleMenuMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketRoleMenuMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketrolemenu.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketRoleMenuMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketrolemenu.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketRoleMenuMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketrolemenu.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketRoleMenuMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketRoleMenuMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketRoleMenu entity.
// If the AsMarketRoleMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketRoleMenuMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketRoleMenuMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketrolemenu.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketRoleMenuMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketrolemenu.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketRoleMenuMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketrolemenu.FieldUpdateTime)
}

// SetMenuxID sets the "menux" edge to the AsMarketMenu entity by id.
func (m *AsMarketRoleMenuMutation) SetMenuxID(id int64) {
	m.menux = &id
}

// ClearMenux clears the "menux" edge to the AsMarketMenu entity.
func (m *AsMarketRoleMenuMutation) ClearMenux() {
	m.clearedmenux = true
}

// MenuxCleared reports if the "menux" edge to the AsMarketMenu entity was cleared.
func (m *AsMarketRoleMenuMutation) MenuxCleared() bool {
	return m.MenuIDCleared() || m.clearedmenux
}

// MenuxID returns the "menux" edge ID in the mutation.
func (m *AsMarketRoleMenuMutation) MenuxID() (id int64, exists bool) {
	if m.menux != nil {
		return *m.menux, true
	}
	return
}

// MenuxIDs returns the "menux" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenuxID instead. It exists only for internal usage by the builders.
func (m *AsMarketRoleMenuMutation) MenuxIDs() (ids []int64) {
	if id := m.menux; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenux resets all changes to the "menux" edge.
func (m *AsMarketRoleMenuMutation) ResetMenux() {
	m.menux = nil
	m.clearedmenux = false
}

// SetRolexID sets the "rolex" edge to the AsMarketAppRole entity by id.
func (m *AsMarketRoleMenuMutation) SetRolexID(id int64) {
	m.rolex = &id
}

// ClearRolex clears the "rolex" edge to the AsMarketAppRole entity.
func (m *AsMarketRoleMenuMutation) ClearRolex() {
	m.clearedrolex = true
}

// RolexCleared reports if the "rolex" edge to the AsMarketAppRole entity was cleared.
func (m *AsMarketRoleMenuMutation) RolexCleared() bool {
	return m.RoleIDCleared() || m.clearedrolex
}

// RolexID returns the "rolex" edge ID in the mutation.
func (m *AsMarketRoleMenuMutation) RolexID() (id int64, exists bool) {
	if m.rolex != nil {
		return *m.rolex, true
	}
	return
}

// RolexIDs returns the "rolex" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolexID instead. It exists only for internal usage by the builders.
func (m *AsMarketRoleMenuMutation) RolexIDs() (ids []int64) {
	if id := m.rolex; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRolex resets all changes to the "rolex" edge.
func (m *AsMarketRoleMenuMutation) ResetRolex() {
	m.rolex = nil
	m.clearedrolex = false
}

// Where appends a list predicates to the AsMarketRoleMenuMutation builder.
func (m *AsMarketRoleMenuMutation) Where(ps ...predicate.AsMarketRoleMenu) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketRoleMenuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketRoleMenu).
func (m *AsMarketRoleMenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketRoleMenuMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.rolex != nil {
		fields = append(fields, asmarketrolemenu.FieldRoleID)
	}
	if m.menux != nil {
		fields = append(fields, asmarketrolemenu.FieldMenuID)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketrolemenu.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketrolemenu.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketrolemenu.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketrolemenu.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketrolemenu.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketrolemenu.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketRoleMenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketrolemenu.FieldRoleID:
		return m.RoleID()
	case asmarketrolemenu.FieldMenuID:
		return m.MenuID()
	case asmarketrolemenu.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketrolemenu.FieldStatus:
		return m.Status()
	case asmarketrolemenu.FieldCreateUser:
		return m.CreateUser()
	case asmarketrolemenu.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketrolemenu.FieldCreateTime:
		return m.CreateTime()
	case asmarketrolemenu.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketRoleMenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketrolemenu.FieldRoleID:
		return m.OldRoleID(ctx)
	case asmarketrolemenu.FieldMenuID:
		return m.OldMenuID(ctx)
	case asmarketrolemenu.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketrolemenu.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketrolemenu.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketrolemenu.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketrolemenu.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketrolemenu.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketRoleMenu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketRoleMenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketrolemenu.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case asmarketrolemenu.FieldMenuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuID(v)
		return nil
	case asmarketrolemenu.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketrolemenu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketrolemenu.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketrolemenu.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketrolemenu.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketrolemenu.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleMenu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketRoleMenuMutation) AddedFields() []string {
	var fields []string
	if m.addis_deleted != nil {
		fields = append(fields, asmarketrolemenu.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketrolemenu.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketrolemenu.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketrolemenu.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketRoleMenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketrolemenu.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketrolemenu.FieldStatus:
		return m.AddedStatus()
	case asmarketrolemenu.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketrolemenu.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketRoleMenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketrolemenu.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketrolemenu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketrolemenu.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketrolemenu.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleMenu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketRoleMenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketrolemenu.FieldRoleID) {
		fields = append(fields, asmarketrolemenu.FieldRoleID)
	}
	if m.FieldCleared(asmarketrolemenu.FieldMenuID) {
		fields = append(fields, asmarketrolemenu.FieldMenuID)
	}
	if m.FieldCleared(asmarketrolemenu.FieldStatus) {
		fields = append(fields, asmarketrolemenu.FieldStatus)
	}
	if m.FieldCleared(asmarketrolemenu.FieldCreateUser) {
		fields = append(fields, asmarketrolemenu.FieldCreateUser)
	}
	if m.FieldCleared(asmarketrolemenu.FieldUpdateUser) {
		fields = append(fields, asmarketrolemenu.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketrolemenu.FieldCreateTime) {
		fields = append(fields, asmarketrolemenu.FieldCreateTime)
	}
	if m.FieldCleared(asmarketrolemenu.FieldUpdateTime) {
		fields = append(fields, asmarketrolemenu.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketRoleMenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketRoleMenuMutation) ClearField(name string) error {
	switch name {
	case asmarketrolemenu.FieldRoleID:
		m.ClearRoleID()
		return nil
	case asmarketrolemenu.FieldMenuID:
		m.ClearMenuID()
		return nil
	case asmarketrolemenu.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketrolemenu.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketrolemenu.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketrolemenu.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketrolemenu.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleMenu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketRoleMenuMutation) ResetField(name string) error {
	switch name {
	case asmarketrolemenu.FieldRoleID:
		m.ResetRoleID()
		return nil
	case asmarketrolemenu.FieldMenuID:
		m.ResetMenuID()
		return nil
	case asmarketrolemenu.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketrolemenu.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketrolemenu.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketrolemenu.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketrolemenu.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketrolemenu.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleMenu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketRoleMenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.menux != nil {
		edges = append(edges, asmarketrolemenu.EdgeMenux)
	}
	if m.rolex != nil {
		edges = append(edges, asmarketrolemenu.EdgeRolex)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketRoleMenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketrolemenu.EdgeMenux:
		if id := m.menux; id != nil {
			return []ent.Value{*id}
		}
	case asmarketrolemenu.EdgeRolex:
		if id := m.rolex; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketRoleMenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketRoleMenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketRoleMenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmenux {
		edges = append(edges, asmarketrolemenu.EdgeMenux)
	}
	if m.clearedrolex {
		edges = append(edges, asmarketrolemenu.EdgeRolex)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketRoleMenuMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketrolemenu.EdgeMenux:
		return m.clearedmenux
	case asmarketrolemenu.EdgeRolex:
		return m.clearedrolex
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketRoleMenuMutation) ClearEdge(name string) error {
	switch name {
	case asmarketrolemenu.EdgeMenux:
		m.ClearMenux()
		return nil
	case asmarketrolemenu.EdgeRolex:
		m.ClearRolex()
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleMenu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketRoleMenuMutation) ResetEdge(name string) error {
	switch name {
	case asmarketrolemenu.EdgeMenux:
		m.ResetMenux()
		return nil
	case asmarketrolemenu.EdgeRolex:
		m.ResetRolex()
		return nil
	}
	return fmt.Errorf("unknown AsMarketRoleMenu edge %s", name)
}

// AsMarketUsedAppMutation represents an operation that mutates the AsMarketUsedApp nodes in the graph.
type AsMarketUsedAppMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	user_id        *int64
	adduser_id     *int64
	sort           *int64
	addsort        *int64
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	appx           *int64
	clearedappx    bool
	userx          *int64
	cleareduserx   bool
	done           bool
	oldValue       func(context.Context) (*AsMarketUsedApp, error)
	predicates     []predicate.AsMarketUsedApp
}

var _ ent.Mutation = (*AsMarketUsedAppMutation)(nil)

// asmarketusedappOption allows management of the mutation configuration using functional options.
type asmarketusedappOption func(*AsMarketUsedAppMutation)

// newAsMarketUsedAppMutation creates new mutation for the AsMarketUsedApp entity.
func newAsMarketUsedAppMutation(c config, op Op, opts ...asmarketusedappOption) *AsMarketUsedAppMutation {
	m := &AsMarketUsedAppMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMarketUsedApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMarketUsedAppID sets the ID field of the mutation.
func withAsMarketUsedAppID(id int64) asmarketusedappOption {
	return func(m *AsMarketUsedAppMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMarketUsedApp
		)
		m.oldValue = func(ctx context.Context) (*AsMarketUsedApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMarketUsedApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMarketUsedApp sets the old AsMarketUsedApp of the mutation.
func withAsMarketUsedApp(node *AsMarketUsedApp) asmarketusedappOption {
	return func(m *AsMarketUsedAppMutation) {
		m.oldValue = func(context.Context) (*AsMarketUsedApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMarketUsedAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMarketUsedAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMarketUsedApp entities.
func (m *AsMarketUsedAppMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMarketUsedAppMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMarketUsedAppMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMarketUsedApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AsMarketUsedAppMutation) SetAppID(i int64) {
	m.userx = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsMarketUsedAppMutation) AppID() (r int64, exists bool) {
	v := m.userx
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsMarketUsedApp entity.
// If the AsMarketUsedApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketUsedAppMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AsMarketUsedAppMutation) ClearAppID() {
	m.userx = nil
	m.clearedFields[asmarketusedapp.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AsMarketUsedAppMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[asmarketusedapp.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsMarketUsedAppMutation) ResetAppID() {
	m.userx = nil
	delete(m.clearedFields, asmarketusedapp.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *AsMarketUsedAppMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AsMarketUsedAppMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AsMarketUsedApp entity.
// If the AsMarketUsedApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketUsedAppMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *AsMarketUsedAppMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AsMarketUsedAppMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *AsMarketUsedAppMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[asmarketusedapp.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AsMarketUsedAppMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[asmarketusedapp.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AsMarketUsedAppMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, asmarketusedapp.FieldUserID)
}

// SetSort sets the "sort" field.
func (m *AsMarketUsedAppMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AsMarketUsedAppMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the AsMarketUsedApp entity.
// If the AsMarketUsedApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketUsedAppMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AsMarketUsedAppMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AsMarketUsedAppMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *AsMarketUsedAppMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[asmarketusedapp.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *AsMarketUsedAppMutation) SortCleared() bool {
	_, ok := m.clearedFields[asmarketusedapp.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *AsMarketUsedAppMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, asmarketusedapp.FieldSort)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMarketUsedAppMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMarketUsedAppMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMarketUsedApp entity.
// If the AsMarketUsedApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketUsedAppMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMarketUsedAppMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMarketUsedAppMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMarketUsedAppMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMarketUsedAppMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMarketUsedAppMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMarketUsedApp entity.
// If the AsMarketUsedApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketUsedAppMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMarketUsedAppMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMarketUsedAppMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMarketUsedAppMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmarketusedapp.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMarketUsedAppMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmarketusedapp.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMarketUsedAppMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmarketusedapp.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMarketUsedAppMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMarketUsedAppMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMarketUsedApp entity.
// If the AsMarketUsedApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketUsedAppMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMarketUsedAppMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMarketUsedAppMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMarketUsedAppMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmarketusedapp.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMarketUsedAppMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmarketusedapp.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMarketUsedAppMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmarketusedapp.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMarketUsedAppMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMarketUsedAppMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMarketUsedApp entity.
// If the AsMarketUsedApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketUsedAppMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMarketUsedAppMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMarketUsedAppMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMarketUsedAppMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmarketusedapp.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMarketUsedAppMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmarketusedapp.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMarketUsedAppMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmarketusedapp.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMarketUsedAppMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMarketUsedAppMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMarketUsedApp entity.
// If the AsMarketUsedApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketUsedAppMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMarketUsedAppMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmarketusedapp.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMarketUsedAppMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketusedapp.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMarketUsedAppMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmarketusedapp.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMarketUsedAppMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMarketUsedAppMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMarketUsedApp entity.
// If the AsMarketUsedApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMarketUsedAppMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMarketUsedAppMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmarketusedapp.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMarketUsedAppMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmarketusedapp.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMarketUsedAppMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmarketusedapp.FieldUpdateTime)
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsMarketUsedAppMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsMarketUsedAppMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsMarketUsedAppMutation) AppxCleared() bool {
	return m.AppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsMarketUsedAppMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsMarketUsedAppMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsMarketUsedAppMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// SetUserxID sets the "userx" edge to the AsUser entity by id.
func (m *AsMarketUsedAppMutation) SetUserxID(id int64) {
	m.userx = &id
}

// ClearUserx clears the "userx" edge to the AsUser entity.
func (m *AsMarketUsedAppMutation) ClearUserx() {
	m.cleareduserx = true
}

// UserxCleared reports if the "userx" edge to the AsUser entity was cleared.
func (m *AsMarketUsedAppMutation) UserxCleared() bool {
	return m.AppIDCleared() || m.cleareduserx
}

// UserxID returns the "userx" edge ID in the mutation.
func (m *AsMarketUsedAppMutation) UserxID() (id int64, exists bool) {
	if m.userx != nil {
		return *m.userx, true
	}
	return
}

// UserxIDs returns the "userx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserxID instead. It exists only for internal usage by the builders.
func (m *AsMarketUsedAppMutation) UserxIDs() (ids []int64) {
	if id := m.userx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserx resets all changes to the "userx" edge.
func (m *AsMarketUsedAppMutation) ResetUserx() {
	m.userx = nil
	m.cleareduserx = false
}

// Where appends a list predicates to the AsMarketUsedAppMutation builder.
func (m *AsMarketUsedAppMutation) Where(ps ...predicate.AsMarketUsedApp) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMarketUsedAppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMarketUsedApp).
func (m *AsMarketUsedAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMarketUsedAppMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.userx != nil {
		fields = append(fields, asmarketusedapp.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, asmarketusedapp.FieldUserID)
	}
	if m.sort != nil {
		fields = append(fields, asmarketusedapp.FieldSort)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmarketusedapp.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmarketusedapp.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmarketusedapp.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmarketusedapp.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmarketusedapp.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmarketusedapp.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMarketUsedAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmarketusedapp.FieldAppID:
		return m.AppID()
	case asmarketusedapp.FieldUserID:
		return m.UserID()
	case asmarketusedapp.FieldSort:
		return m.Sort()
	case asmarketusedapp.FieldIsDeleted:
		return m.IsDeleted()
	case asmarketusedapp.FieldStatus:
		return m.Status()
	case asmarketusedapp.FieldCreateUser:
		return m.CreateUser()
	case asmarketusedapp.FieldUpdateUser:
		return m.UpdateUser()
	case asmarketusedapp.FieldCreateTime:
		return m.CreateTime()
	case asmarketusedapp.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMarketUsedAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmarketusedapp.FieldAppID:
		return m.OldAppID(ctx)
	case asmarketusedapp.FieldUserID:
		return m.OldUserID(ctx)
	case asmarketusedapp.FieldSort:
		return m.OldSort(ctx)
	case asmarketusedapp.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmarketusedapp.FieldStatus:
		return m.OldStatus(ctx)
	case asmarketusedapp.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmarketusedapp.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmarketusedapp.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmarketusedapp.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMarketUsedApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketUsedAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmarketusedapp.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asmarketusedapp.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case asmarketusedapp.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case asmarketusedapp.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmarketusedapp.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmarketusedapp.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmarketusedapp.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmarketusedapp.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmarketusedapp.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketUsedApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMarketUsedAppMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, asmarketusedapp.FieldUserID)
	}
	if m.addsort != nil {
		fields = append(fields, asmarketusedapp.FieldSort)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmarketusedapp.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmarketusedapp.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmarketusedapp.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmarketusedapp.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMarketUsedAppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmarketusedapp.FieldUserID:
		return m.AddedUserID()
	case asmarketusedapp.FieldSort:
		return m.AddedSort()
	case asmarketusedapp.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmarketusedapp.FieldStatus:
		return m.AddedStatus()
	case asmarketusedapp.FieldCreateUser:
		return m.AddedCreateUser()
	case asmarketusedapp.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMarketUsedAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmarketusedapp.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case asmarketusedapp.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case asmarketusedapp.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmarketusedapp.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmarketusedapp.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmarketusedapp.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMarketUsedApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMarketUsedAppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmarketusedapp.FieldAppID) {
		fields = append(fields, asmarketusedapp.FieldAppID)
	}
	if m.FieldCleared(asmarketusedapp.FieldUserID) {
		fields = append(fields, asmarketusedapp.FieldUserID)
	}
	if m.FieldCleared(asmarketusedapp.FieldSort) {
		fields = append(fields, asmarketusedapp.FieldSort)
	}
	if m.FieldCleared(asmarketusedapp.FieldStatus) {
		fields = append(fields, asmarketusedapp.FieldStatus)
	}
	if m.FieldCleared(asmarketusedapp.FieldCreateUser) {
		fields = append(fields, asmarketusedapp.FieldCreateUser)
	}
	if m.FieldCleared(asmarketusedapp.FieldUpdateUser) {
		fields = append(fields, asmarketusedapp.FieldUpdateUser)
	}
	if m.FieldCleared(asmarketusedapp.FieldCreateTime) {
		fields = append(fields, asmarketusedapp.FieldCreateTime)
	}
	if m.FieldCleared(asmarketusedapp.FieldUpdateTime) {
		fields = append(fields, asmarketusedapp.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMarketUsedAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMarketUsedAppMutation) ClearField(name string) error {
	switch name {
	case asmarketusedapp.FieldAppID:
		m.ClearAppID()
		return nil
	case asmarketusedapp.FieldUserID:
		m.ClearUserID()
		return nil
	case asmarketusedapp.FieldSort:
		m.ClearSort()
		return nil
	case asmarketusedapp.FieldStatus:
		m.ClearStatus()
		return nil
	case asmarketusedapp.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmarketusedapp.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmarketusedapp.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmarketusedapp.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketUsedApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMarketUsedAppMutation) ResetField(name string) error {
	switch name {
	case asmarketusedapp.FieldAppID:
		m.ResetAppID()
		return nil
	case asmarketusedapp.FieldUserID:
		m.ResetUserID()
		return nil
	case asmarketusedapp.FieldSort:
		m.ResetSort()
		return nil
	case asmarketusedapp.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmarketusedapp.FieldStatus:
		m.ResetStatus()
		return nil
	case asmarketusedapp.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmarketusedapp.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmarketusedapp.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmarketusedapp.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMarketUsedApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMarketUsedAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.appx != nil {
		edges = append(edges, asmarketusedapp.EdgeAppx)
	}
	if m.userx != nil {
		edges = append(edges, asmarketusedapp.EdgeUserx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMarketUsedAppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmarketusedapp.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	case asmarketusedapp.EdgeUserx:
		if id := m.userx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMarketUsedAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMarketUsedAppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMarketUsedAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedappx {
		edges = append(edges, asmarketusedapp.EdgeAppx)
	}
	if m.cleareduserx {
		edges = append(edges, asmarketusedapp.EdgeUserx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMarketUsedAppMutation) EdgeCleared(name string) bool {
	switch name {
	case asmarketusedapp.EdgeAppx:
		return m.clearedappx
	case asmarketusedapp.EdgeUserx:
		return m.cleareduserx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMarketUsedAppMutation) ClearEdge(name string) error {
	switch name {
	case asmarketusedapp.EdgeAppx:
		m.ClearAppx()
		return nil
	case asmarketusedapp.EdgeUserx:
		m.ClearUserx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketUsedApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMarketUsedAppMutation) ResetEdge(name string) error {
	switch name {
	case asmarketusedapp.EdgeAppx:
		m.ResetAppx()
		return nil
	case asmarketusedapp.EdgeUserx:
		m.ResetUserx()
		return nil
	}
	return fmt.Errorf("unknown AsMarketUsedApp edge %s", name)
}

// AsMenuMutation represents an operation that mutates the AsMenu nodes in the graph.
type AsMenuMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	name             *string
	alias            *string
	_path            *string
	icon             *string
	sort             *int64
	addsort          *int64
	category         *int64
	addcategory      *int64
	is_open          *int64
	addis_open       *int64
	remark           *string
	reform_status    *int64
	addreform_status *int64
	is_deleted       *int64
	addis_deleted    *int64
	status           *int64
	addstatus        *int64
	create_user      *int64
	addcreate_user   *int64
	update_user      *int64
	addupdate_user   *int64
	create_time      *date.DateTime
	update_time      *date.DateTime
	clearedFields    map[string]struct{}
	parentx          *int64
	clearedparentx   bool
	childrens        map[int64]struct{}
	removedchildrens map[int64]struct{}
	clearedchildrens bool
	roles            map[int64]struct{}
	removedroles     map[int64]struct{}
	clearedroles     bool
	done             bool
	oldValue         func(context.Context) (*AsMenu, error)
	predicates       []predicate.AsMenu
}

var _ ent.Mutation = (*AsMenuMutation)(nil)

// asmenuOption allows management of the mutation configuration using functional options.
type asmenuOption func(*AsMenuMutation)

// newAsMenuMutation creates new mutation for the AsMenu entity.
func newAsMenuMutation(c config, op Op, opts ...asmenuOption) *AsMenuMutation {
	m := &AsMenuMutation{
		config:        c,
		op:            op,
		typ:           TypeAsMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsMenuID sets the ID field of the mutation.
func withAsMenuID(id int64) asmenuOption {
	return func(m *AsMenuMutation) {
		var (
			err   error
			once  sync.Once
			value *AsMenu
		)
		m.oldValue = func(ctx context.Context) (*AsMenu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsMenu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsMenu sets the old AsMenu of the mutation.
func withAsMenu(node *AsMenu) asmenuOption {
	return func(m *AsMenuMutation) {
		m.oldValue = func(context.Context) (*AsMenu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsMenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsMenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsMenu entities.
func (m *AsMenuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsMenuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsMenuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsMenu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetParentID sets the "parent_id" field.
func (m *AsMenuMutation) SetParentID(i int64) {
	m.parentx = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *AsMenuMutation) ParentID() (r int64, exists bool) {
	v := m.parentx
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *AsMenuMutation) ClearParentID() {
	m.parentx = nil
	m.clearedFields[asmenu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *AsMenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *AsMenuMutation) ResetParentID() {
	m.parentx = nil
	delete(m.clearedFields, asmenu.FieldParentID)
}

// SetName sets the "name" field.
func (m *AsMenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AsMenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AsMenuMutation) ClearName() {
	m.name = nil
	m.clearedFields[asmenu.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AsMenuMutation) NameCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AsMenuMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, asmenu.FieldName)
}

// SetAlias sets the "alias" field.
func (m *AsMenuMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *AsMenuMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ClearAlias clears the value of the "alias" field.
func (m *AsMenuMutation) ClearAlias() {
	m.alias = nil
	m.clearedFields[asmenu.FieldAlias] = struct{}{}
}

// AliasCleared returns if the "alias" field was cleared in this mutation.
func (m *AsMenuMutation) AliasCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldAlias]
	return ok
}

// ResetAlias resets all changes to the "alias" field.
func (m *AsMenuMutation) ResetAlias() {
	m.alias = nil
	delete(m.clearedFields, asmenu.FieldAlias)
}

// SetPath sets the "path" field.
func (m *AsMenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *AsMenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *AsMenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[asmenu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *AsMenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *AsMenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, asmenu.FieldPath)
}

// SetIcon sets the "icon" field.
func (m *AsMenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AsMenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *AsMenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[asmenu.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *AsMenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *AsMenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, asmenu.FieldIcon)
}

// SetSort sets the "sort" field.
func (m *AsMenuMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AsMenuMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AsMenuMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AsMenuMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *AsMenuMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[asmenu.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *AsMenuMutation) SortCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *AsMenuMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, asmenu.FieldSort)
}

// SetCategory sets the "category" field.
func (m *AsMenuMutation) SetCategory(i int64) {
	m.category = &i
	m.addcategory = nil
}

// Category returns the value of the "category" field in the mutation.
func (m *AsMenuMutation) Category() (r int64, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldCategory(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// AddCategory adds i to the "category" field.
func (m *AsMenuMutation) AddCategory(i int64) {
	if m.addcategory != nil {
		*m.addcategory += i
	} else {
		m.addcategory = &i
	}
}

// AddedCategory returns the value that was added to the "category" field in this mutation.
func (m *AsMenuMutation) AddedCategory() (r int64, exists bool) {
	v := m.addcategory
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategory resets all changes to the "category" field.
func (m *AsMenuMutation) ResetCategory() {
	m.category = nil
	m.addcategory = nil
}

// SetIsOpen sets the "is_open" field.
func (m *AsMenuMutation) SetIsOpen(i int64) {
	m.is_open = &i
	m.addis_open = nil
}

// IsOpen returns the value of the "is_open" field in the mutation.
func (m *AsMenuMutation) IsOpen() (r int64, exists bool) {
	v := m.is_open
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOpen returns the old "is_open" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldIsOpen(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOpen: %w", err)
	}
	return oldValue.IsOpen, nil
}

// AddIsOpen adds i to the "is_open" field.
func (m *AsMenuMutation) AddIsOpen(i int64) {
	if m.addis_open != nil {
		*m.addis_open += i
	} else {
		m.addis_open = &i
	}
}

// AddedIsOpen returns the value that was added to the "is_open" field in this mutation.
func (m *AsMenuMutation) AddedIsOpen() (r int64, exists bool) {
	v := m.addis_open
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsOpen clears the value of the "is_open" field.
func (m *AsMenuMutation) ClearIsOpen() {
	m.is_open = nil
	m.addis_open = nil
	m.clearedFields[asmenu.FieldIsOpen] = struct{}{}
}

// IsOpenCleared returns if the "is_open" field was cleared in this mutation.
func (m *AsMenuMutation) IsOpenCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldIsOpen]
	return ok
}

// ResetIsOpen resets all changes to the "is_open" field.
func (m *AsMenuMutation) ResetIsOpen() {
	m.is_open = nil
	m.addis_open = nil
	delete(m.clearedFields, asmenu.FieldIsOpen)
}

// SetRemark sets the "remark" field.
func (m *AsMenuMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AsMenuMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AsMenuMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[asmenu.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AsMenuMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AsMenuMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, asmenu.FieldRemark)
}

// SetReformStatus sets the "reform_status" field.
func (m *AsMenuMutation) SetReformStatus(i int64) {
	m.reform_status = &i
	m.addreform_status = nil
}

// ReformStatus returns the value of the "reform_status" field in the mutation.
func (m *AsMenuMutation) ReformStatus() (r int64, exists bool) {
	v := m.reform_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReformStatus returns the old "reform_status" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldReformStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReformStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReformStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReformStatus: %w", err)
	}
	return oldValue.ReformStatus, nil
}

// AddReformStatus adds i to the "reform_status" field.
func (m *AsMenuMutation) AddReformStatus(i int64) {
	if m.addreform_status != nil {
		*m.addreform_status += i
	} else {
		m.addreform_status = &i
	}
}

// AddedReformStatus returns the value that was added to the "reform_status" field in this mutation.
func (m *AsMenuMutation) AddedReformStatus() (r int64, exists bool) {
	v := m.addreform_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearReformStatus clears the value of the "reform_status" field.
func (m *AsMenuMutation) ClearReformStatus() {
	m.reform_status = nil
	m.addreform_status = nil
	m.clearedFields[asmenu.FieldReformStatus] = struct{}{}
}

// ReformStatusCleared returns if the "reform_status" field was cleared in this mutation.
func (m *AsMenuMutation) ReformStatusCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldReformStatus]
	return ok
}

// ResetReformStatus resets all changes to the "reform_status" field.
func (m *AsMenuMutation) ResetReformStatus() {
	m.reform_status = nil
	m.addreform_status = nil
	delete(m.clearedFields, asmenu.FieldReformStatus)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsMenuMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsMenuMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsMenuMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsMenuMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsMenuMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsMenuMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsMenuMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsMenuMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsMenuMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsMenuMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asmenu.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsMenuMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsMenuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asmenu.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsMenuMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsMenuMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsMenuMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsMenuMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsMenuMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asmenu.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsMenuMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsMenuMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asmenu.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsMenuMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsMenuMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsMenuMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsMenuMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsMenuMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asmenu.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsMenuMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsMenuMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asmenu.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsMenuMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsMenuMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsMenuMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asmenu.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsMenuMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsMenuMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asmenu.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsMenuMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsMenuMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsMenu entity.
// If the AsMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsMenuMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsMenuMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asmenu.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsMenuMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asmenu.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsMenuMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asmenu.FieldUpdateTime)
}

// SetParentxID sets the "parentx" edge to the AsMenu entity by id.
func (m *AsMenuMutation) SetParentxID(id int64) {
	m.parentx = &id
}

// ClearParentx clears the "parentx" edge to the AsMenu entity.
func (m *AsMenuMutation) ClearParentx() {
	m.clearedparentx = true
}

// ParentxCleared reports if the "parentx" edge to the AsMenu entity was cleared.
func (m *AsMenuMutation) ParentxCleared() bool {
	return m.ParentIDCleared() || m.clearedparentx
}

// ParentxID returns the "parentx" edge ID in the mutation.
func (m *AsMenuMutation) ParentxID() (id int64, exists bool) {
	if m.parentx != nil {
		return *m.parentx, true
	}
	return
}

// ParentxIDs returns the "parentx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentxID instead. It exists only for internal usage by the builders.
func (m *AsMenuMutation) ParentxIDs() (ids []int64) {
	if id := m.parentx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentx resets all changes to the "parentx" edge.
func (m *AsMenuMutation) ResetParentx() {
	m.parentx = nil
	m.clearedparentx = false
}

// AddChildrenIDs adds the "childrens" edge to the AsMenu entity by ids.
func (m *AsMenuMutation) AddChildrenIDs(ids ...int64) {
	if m.childrens == nil {
		m.childrens = make(map[int64]struct{})
	}
	for i := range ids {
		m.childrens[ids[i]] = struct{}{}
	}
}

// ClearChildrens clears the "childrens" edge to the AsMenu entity.
func (m *AsMenuMutation) ClearChildrens() {
	m.clearedchildrens = true
}

// ChildrensCleared reports if the "childrens" edge to the AsMenu entity was cleared.
func (m *AsMenuMutation) ChildrensCleared() bool {
	return m.clearedchildrens
}

// RemoveChildrenIDs removes the "childrens" edge to the AsMenu entity by IDs.
func (m *AsMenuMutation) RemoveChildrenIDs(ids ...int64) {
	if m.removedchildrens == nil {
		m.removedchildrens = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.childrens, ids[i])
		m.removedchildrens[ids[i]] = struct{}{}
	}
}

// RemovedChildrens returns the removed IDs of the "childrens" edge to the AsMenu entity.
func (m *AsMenuMutation) RemovedChildrensIDs() (ids []int64) {
	for id := range m.removedchildrens {
		ids = append(ids, id)
	}
	return
}

// ChildrensIDs returns the "childrens" edge IDs in the mutation.
func (m *AsMenuMutation) ChildrensIDs() (ids []int64) {
	for id := range m.childrens {
		ids = append(ids, id)
	}
	return
}

// ResetChildrens resets all changes to the "childrens" edge.
func (m *AsMenuMutation) ResetChildrens() {
	m.childrens = nil
	m.clearedchildrens = false
	m.removedchildrens = nil
}

// AddRoleIDs adds the "roles" edge to the AsRole entity by ids.
func (m *AsMenuMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the AsRole entity.
func (m *AsMenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AsRole entity was cleared.
func (m *AsMenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the AsRole entity by IDs.
func (m *AsMenuMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the AsRole entity.
func (m *AsMenuMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AsMenuMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AsMenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the AsMenuMutation builder.
func (m *AsMenuMutation) Where(ps ...predicate.AsMenu) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsMenuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsMenu).
func (m *AsMenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsMenuMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.parentx != nil {
		fields = append(fields, asmenu.FieldParentID)
	}
	if m.name != nil {
		fields = append(fields, asmenu.FieldName)
	}
	if m.alias != nil {
		fields = append(fields, asmenu.FieldAlias)
	}
	if m._path != nil {
		fields = append(fields, asmenu.FieldPath)
	}
	if m.icon != nil {
		fields = append(fields, asmenu.FieldIcon)
	}
	if m.sort != nil {
		fields = append(fields, asmenu.FieldSort)
	}
	if m.category != nil {
		fields = append(fields, asmenu.FieldCategory)
	}
	if m.is_open != nil {
		fields = append(fields, asmenu.FieldIsOpen)
	}
	if m.remark != nil {
		fields = append(fields, asmenu.FieldRemark)
	}
	if m.reform_status != nil {
		fields = append(fields, asmenu.FieldReformStatus)
	}
	if m.is_deleted != nil {
		fields = append(fields, asmenu.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asmenu.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asmenu.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asmenu.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asmenu.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asmenu.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsMenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asmenu.FieldParentID:
		return m.ParentID()
	case asmenu.FieldName:
		return m.Name()
	case asmenu.FieldAlias:
		return m.Alias()
	case asmenu.FieldPath:
		return m.Path()
	case asmenu.FieldIcon:
		return m.Icon()
	case asmenu.FieldSort:
		return m.Sort()
	case asmenu.FieldCategory:
		return m.Category()
	case asmenu.FieldIsOpen:
		return m.IsOpen()
	case asmenu.FieldRemark:
		return m.Remark()
	case asmenu.FieldReformStatus:
		return m.ReformStatus()
	case asmenu.FieldIsDeleted:
		return m.IsDeleted()
	case asmenu.FieldStatus:
		return m.Status()
	case asmenu.FieldCreateUser:
		return m.CreateUser()
	case asmenu.FieldUpdateUser:
		return m.UpdateUser()
	case asmenu.FieldCreateTime:
		return m.CreateTime()
	case asmenu.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsMenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asmenu.FieldParentID:
		return m.OldParentID(ctx)
	case asmenu.FieldName:
		return m.OldName(ctx)
	case asmenu.FieldAlias:
		return m.OldAlias(ctx)
	case asmenu.FieldPath:
		return m.OldPath(ctx)
	case asmenu.FieldIcon:
		return m.OldIcon(ctx)
	case asmenu.FieldSort:
		return m.OldSort(ctx)
	case asmenu.FieldCategory:
		return m.OldCategory(ctx)
	case asmenu.FieldIsOpen:
		return m.OldIsOpen(ctx)
	case asmenu.FieldRemark:
		return m.OldRemark(ctx)
	case asmenu.FieldReformStatus:
		return m.OldReformStatus(ctx)
	case asmenu.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asmenu.FieldStatus:
		return m.OldStatus(ctx)
	case asmenu.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asmenu.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asmenu.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asmenu.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsMenu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asmenu.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case asmenu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case asmenu.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case asmenu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case asmenu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case asmenu.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case asmenu.FieldCategory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case asmenu.FieldIsOpen:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOpen(v)
		return nil
	case asmenu.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case asmenu.FieldReformStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReformStatus(v)
		return nil
	case asmenu.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asmenu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asmenu.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asmenu.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asmenu.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asmenu.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsMenu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsMenuMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, asmenu.FieldSort)
	}
	if m.addcategory != nil {
		fields = append(fields, asmenu.FieldCategory)
	}
	if m.addis_open != nil {
		fields = append(fields, asmenu.FieldIsOpen)
	}
	if m.addreform_status != nil {
		fields = append(fields, asmenu.FieldReformStatus)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asmenu.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asmenu.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asmenu.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asmenu.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsMenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asmenu.FieldSort:
		return m.AddedSort()
	case asmenu.FieldCategory:
		return m.AddedCategory()
	case asmenu.FieldIsOpen:
		return m.AddedIsOpen()
	case asmenu.FieldReformStatus:
		return m.AddedReformStatus()
	case asmenu.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asmenu.FieldStatus:
		return m.AddedStatus()
	case asmenu.FieldCreateUser:
		return m.AddedCreateUser()
	case asmenu.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsMenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asmenu.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case asmenu.FieldCategory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategory(v)
		return nil
	case asmenu.FieldIsOpen:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsOpen(v)
		return nil
	case asmenu.FieldReformStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReformStatus(v)
		return nil
	case asmenu.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asmenu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asmenu.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asmenu.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsMenu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsMenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asmenu.FieldParentID) {
		fields = append(fields, asmenu.FieldParentID)
	}
	if m.FieldCleared(asmenu.FieldName) {
		fields = append(fields, asmenu.FieldName)
	}
	if m.FieldCleared(asmenu.FieldAlias) {
		fields = append(fields, asmenu.FieldAlias)
	}
	if m.FieldCleared(asmenu.FieldPath) {
		fields = append(fields, asmenu.FieldPath)
	}
	if m.FieldCleared(asmenu.FieldIcon) {
		fields = append(fields, asmenu.FieldIcon)
	}
	if m.FieldCleared(asmenu.FieldSort) {
		fields = append(fields, asmenu.FieldSort)
	}
	if m.FieldCleared(asmenu.FieldIsOpen) {
		fields = append(fields, asmenu.FieldIsOpen)
	}
	if m.FieldCleared(asmenu.FieldRemark) {
		fields = append(fields, asmenu.FieldRemark)
	}
	if m.FieldCleared(asmenu.FieldReformStatus) {
		fields = append(fields, asmenu.FieldReformStatus)
	}
	if m.FieldCleared(asmenu.FieldStatus) {
		fields = append(fields, asmenu.FieldStatus)
	}
	if m.FieldCleared(asmenu.FieldCreateUser) {
		fields = append(fields, asmenu.FieldCreateUser)
	}
	if m.FieldCleared(asmenu.FieldUpdateUser) {
		fields = append(fields, asmenu.FieldUpdateUser)
	}
	if m.FieldCleared(asmenu.FieldCreateTime) {
		fields = append(fields, asmenu.FieldCreateTime)
	}
	if m.FieldCleared(asmenu.FieldUpdateTime) {
		fields = append(fields, asmenu.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsMenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsMenuMutation) ClearField(name string) error {
	switch name {
	case asmenu.FieldParentID:
		m.ClearParentID()
		return nil
	case asmenu.FieldName:
		m.ClearName()
		return nil
	case asmenu.FieldAlias:
		m.ClearAlias()
		return nil
	case asmenu.FieldPath:
		m.ClearPath()
		return nil
	case asmenu.FieldIcon:
		m.ClearIcon()
		return nil
	case asmenu.FieldSort:
		m.ClearSort()
		return nil
	case asmenu.FieldIsOpen:
		m.ClearIsOpen()
		return nil
	case asmenu.FieldRemark:
		m.ClearRemark()
		return nil
	case asmenu.FieldReformStatus:
		m.ClearReformStatus()
		return nil
	case asmenu.FieldStatus:
		m.ClearStatus()
		return nil
	case asmenu.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asmenu.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asmenu.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asmenu.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMenu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsMenuMutation) ResetField(name string) error {
	switch name {
	case asmenu.FieldParentID:
		m.ResetParentID()
		return nil
	case asmenu.FieldName:
		m.ResetName()
		return nil
	case asmenu.FieldAlias:
		m.ResetAlias()
		return nil
	case asmenu.FieldPath:
		m.ResetPath()
		return nil
	case asmenu.FieldIcon:
		m.ResetIcon()
		return nil
	case asmenu.FieldSort:
		m.ResetSort()
		return nil
	case asmenu.FieldCategory:
		m.ResetCategory()
		return nil
	case asmenu.FieldIsOpen:
		m.ResetIsOpen()
		return nil
	case asmenu.FieldRemark:
		m.ResetRemark()
		return nil
	case asmenu.FieldReformStatus:
		m.ResetReformStatus()
		return nil
	case asmenu.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asmenu.FieldStatus:
		m.ResetStatus()
		return nil
	case asmenu.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asmenu.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asmenu.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asmenu.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsMenu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsMenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parentx != nil {
		edges = append(edges, asmenu.EdgeParentx)
	}
	if m.childrens != nil {
		edges = append(edges, asmenu.EdgeChildrens)
	}
	if m.roles != nil {
		edges = append(edges, asmenu.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsMenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asmenu.EdgeParentx:
		if id := m.parentx; id != nil {
			return []ent.Value{*id}
		}
	case asmenu.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.childrens))
		for id := range m.childrens {
			ids = append(ids, id)
		}
		return ids
	case asmenu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsMenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildrens != nil {
		edges = append(edges, asmenu.EdgeChildrens)
	}
	if m.removedroles != nil {
		edges = append(edges, asmenu.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsMenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asmenu.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.removedchildrens))
		for id := range m.removedchildrens {
			ids = append(ids, id)
		}
		return ids
	case asmenu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsMenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparentx {
		edges = append(edges, asmenu.EdgeParentx)
	}
	if m.clearedchildrens {
		edges = append(edges, asmenu.EdgeChildrens)
	}
	if m.clearedroles {
		edges = append(edges, asmenu.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsMenuMutation) EdgeCleared(name string) bool {
	switch name {
	case asmenu.EdgeParentx:
		return m.clearedparentx
	case asmenu.EdgeChildrens:
		return m.clearedchildrens
	case asmenu.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsMenuMutation) ClearEdge(name string) error {
	switch name {
	case asmenu.EdgeParentx:
		m.ClearParentx()
		return nil
	}
	return fmt.Errorf("unknown AsMenu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsMenuMutation) ResetEdge(name string) error {
	switch name {
	case asmenu.EdgeParentx:
		m.ResetParentx()
		return nil
	case asmenu.EdgeChildrens:
		m.ResetChildrens()
		return nil
	case asmenu.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown AsMenu edge %s", name)
}

// AsPersonMutation represents an operation that mutates the AsPerson nodes in the graph.
type AsPersonMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	tenant_code    *string
	real_name      *string
	id_card        *string
	gender         *int64
	addgender      *int64
	user_birthday  *date.DateTime
	user_email     *string
	user_photo     *string
	phone_number   *string
	province       *string
	city           *string
	street_address *string
	user_code      *string
	is_master      *int64
	addis_master   *int64
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	userx          *int64
	cleareduserx   bool
	agencys        map[int64]struct{}
	removedagencys map[int64]struct{}
	clearedagencys bool
	jobs           map[int64]struct{}
	removedjobs    map[int64]struct{}
	clearedjobs    bool
	done           bool
	oldValue       func(context.Context) (*AsPerson, error)
	predicates     []predicate.AsPerson
}

var _ ent.Mutation = (*AsPersonMutation)(nil)

// aspersonOption allows management of the mutation configuration using functional options.
type aspersonOption func(*AsPersonMutation)

// newAsPersonMutation creates new mutation for the AsPerson entity.
func newAsPersonMutation(c config, op Op, opts ...aspersonOption) *AsPersonMutation {
	m := &AsPersonMutation{
		config:        c,
		op:            op,
		typ:           TypeAsPerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsPersonID sets the ID field of the mutation.
func withAsPersonID(id int64) aspersonOption {
	return func(m *AsPersonMutation) {
		var (
			err   error
			once  sync.Once
			value *AsPerson
		)
		m.oldValue = func(ctx context.Context) (*AsPerson, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsPerson.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsPerson sets the old AsPerson of the mutation.
func withAsPerson(node *AsPerson) aspersonOption {
	return func(m *AsPersonMutation) {
		m.oldValue = func(context.Context) (*AsPerson, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsPersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsPersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsPerson entities.
func (m *AsPersonMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsPersonMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsPersonMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsPerson.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantCode sets the "tenant_code" field.
func (m *AsPersonMutation) SetTenantCode(s string) {
	m.tenant_code = &s
}

// TenantCode returns the value of the "tenant_code" field in the mutation.
func (m *AsPersonMutation) TenantCode() (r string, exists bool) {
	v := m.tenant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantCode returns the old "tenant_code" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldTenantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantCode: %w", err)
	}
	return oldValue.TenantCode, nil
}

// ClearTenantCode clears the value of the "tenant_code" field.
func (m *AsPersonMutation) ClearTenantCode() {
	m.tenant_code = nil
	m.clearedFields[asperson.FieldTenantCode] = struct{}{}
}

// TenantCodeCleared returns if the "tenant_code" field was cleared in this mutation.
func (m *AsPersonMutation) TenantCodeCleared() bool {
	_, ok := m.clearedFields[asperson.FieldTenantCode]
	return ok
}

// ResetTenantCode resets all changes to the "tenant_code" field.
func (m *AsPersonMutation) ResetTenantCode() {
	m.tenant_code = nil
	delete(m.clearedFields, asperson.FieldTenantCode)
}

// SetRealName sets the "real_name" field.
func (m *AsPersonMutation) SetRealName(s string) {
	m.real_name = &s
}

// RealName returns the value of the "real_name" field in the mutation.
func (m *AsPersonMutation) RealName() (r string, exists bool) {
	v := m.real_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRealName returns the old "real_name" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldRealName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealName: %w", err)
	}
	return oldValue.RealName, nil
}

// ResetRealName resets all changes to the "real_name" field.
func (m *AsPersonMutation) ResetRealName() {
	m.real_name = nil
}

// SetIDCard sets the "id_card" field.
func (m *AsPersonMutation) SetIDCard(s string) {
	m.id_card = &s
}

// IDCard returns the value of the "id_card" field in the mutation.
func (m *AsPersonMutation) IDCard() (r string, exists bool) {
	v := m.id_card
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCard returns the old "id_card" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldIDCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCard: %w", err)
	}
	return oldValue.IDCard, nil
}

// ClearIDCard clears the value of the "id_card" field.
func (m *AsPersonMutation) ClearIDCard() {
	m.id_card = nil
	m.clearedFields[asperson.FieldIDCard] = struct{}{}
}

// IDCardCleared returns if the "id_card" field was cleared in this mutation.
func (m *AsPersonMutation) IDCardCleared() bool {
	_, ok := m.clearedFields[asperson.FieldIDCard]
	return ok
}

// ResetIDCard resets all changes to the "id_card" field.
func (m *AsPersonMutation) ResetIDCard() {
	m.id_card = nil
	delete(m.clearedFields, asperson.FieldIDCard)
}

// SetGender sets the "gender" field.
func (m *AsPersonMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *AsPersonMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *AsPersonMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *AsPersonMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *AsPersonMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[asperson.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *AsPersonMutation) GenderCleared() bool {
	_, ok := m.clearedFields[asperson.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *AsPersonMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, asperson.FieldGender)
}

// SetUserBirthday sets the "user_birthday" field.
func (m *AsPersonMutation) SetUserBirthday(dt date.DateTime) {
	m.user_birthday = &dt
}

// UserBirthday returns the value of the "user_birthday" field in the mutation.
func (m *AsPersonMutation) UserBirthday() (r date.DateTime, exists bool) {
	v := m.user_birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldUserBirthday returns the old "user_birthday" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldUserBirthday(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserBirthday: %w", err)
	}
	return oldValue.UserBirthday, nil
}

// ClearUserBirthday clears the value of the "user_birthday" field.
func (m *AsPersonMutation) ClearUserBirthday() {
	m.user_birthday = nil
	m.clearedFields[asperson.FieldUserBirthday] = struct{}{}
}

// UserBirthdayCleared returns if the "user_birthday" field was cleared in this mutation.
func (m *AsPersonMutation) UserBirthdayCleared() bool {
	_, ok := m.clearedFields[asperson.FieldUserBirthday]
	return ok
}

// ResetUserBirthday resets all changes to the "user_birthday" field.
func (m *AsPersonMutation) ResetUserBirthday() {
	m.user_birthday = nil
	delete(m.clearedFields, asperson.FieldUserBirthday)
}

// SetUserEmail sets the "user_email" field.
func (m *AsPersonMutation) SetUserEmail(s string) {
	m.user_email = &s
}

// UserEmail returns the value of the "user_email" field in the mutation.
func (m *AsPersonMutation) UserEmail() (r string, exists bool) {
	v := m.user_email
	if v == nil {
		return
	}
	return *v, true
}

// OldUserEmail returns the old "user_email" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldUserEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserEmail: %w", err)
	}
	return oldValue.UserEmail, nil
}

// ClearUserEmail clears the value of the "user_email" field.
func (m *AsPersonMutation) ClearUserEmail() {
	m.user_email = nil
	m.clearedFields[asperson.FieldUserEmail] = struct{}{}
}

// UserEmailCleared returns if the "user_email" field was cleared in this mutation.
func (m *AsPersonMutation) UserEmailCleared() bool {
	_, ok := m.clearedFields[asperson.FieldUserEmail]
	return ok
}

// ResetUserEmail resets all changes to the "user_email" field.
func (m *AsPersonMutation) ResetUserEmail() {
	m.user_email = nil
	delete(m.clearedFields, asperson.FieldUserEmail)
}

// SetUserPhoto sets the "user_photo" field.
func (m *AsPersonMutation) SetUserPhoto(s string) {
	m.user_photo = &s
}

// UserPhoto returns the value of the "user_photo" field in the mutation.
func (m *AsPersonMutation) UserPhoto() (r string, exists bool) {
	v := m.user_photo
	if v == nil {
		return
	}
	return *v, true
}

// OldUserPhoto returns the old "user_photo" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldUserPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserPhoto: %w", err)
	}
	return oldValue.UserPhoto, nil
}

// ClearUserPhoto clears the value of the "user_photo" field.
func (m *AsPersonMutation) ClearUserPhoto() {
	m.user_photo = nil
	m.clearedFields[asperson.FieldUserPhoto] = struct{}{}
}

// UserPhotoCleared returns if the "user_photo" field was cleared in this mutation.
func (m *AsPersonMutation) UserPhotoCleared() bool {
	_, ok := m.clearedFields[asperson.FieldUserPhoto]
	return ok
}

// ResetUserPhoto resets all changes to the "user_photo" field.
func (m *AsPersonMutation) ResetUserPhoto() {
	m.user_photo = nil
	delete(m.clearedFields, asperson.FieldUserPhoto)
}

// SetUserID sets the "user_id" field.
func (m *AsPersonMutation) SetUserID(i int64) {
	m.userx = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AsPersonMutation) UserID() (r int64, exists bool) {
	v := m.userx
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AsPersonMutation) ResetUserID() {
	m.userx = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *AsPersonMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *AsPersonMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *AsPersonMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetProvince sets the "province" field.
func (m *AsPersonMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *AsPersonMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *AsPersonMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[asperson.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *AsPersonMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[asperson.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *AsPersonMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, asperson.FieldProvince)
}

// SetCity sets the "city" field.
func (m *AsPersonMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AsPersonMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *AsPersonMutation) ClearCity() {
	m.city = nil
	m.clearedFields[asperson.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *AsPersonMutation) CityCleared() bool {
	_, ok := m.clearedFields[asperson.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *AsPersonMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, asperson.FieldCity)
}

// SetStreetAddress sets the "street_address" field.
func (m *AsPersonMutation) SetStreetAddress(s string) {
	m.street_address = &s
}

// StreetAddress returns the value of the "street_address" field in the mutation.
func (m *AsPersonMutation) StreetAddress() (r string, exists bool) {
	v := m.street_address
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetAddress returns the old "street_address" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldStreetAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetAddress: %w", err)
	}
	return oldValue.StreetAddress, nil
}

// ClearStreetAddress clears the value of the "street_address" field.
func (m *AsPersonMutation) ClearStreetAddress() {
	m.street_address = nil
	m.clearedFields[asperson.FieldStreetAddress] = struct{}{}
}

// StreetAddressCleared returns if the "street_address" field was cleared in this mutation.
func (m *AsPersonMutation) StreetAddressCleared() bool {
	_, ok := m.clearedFields[asperson.FieldStreetAddress]
	return ok
}

// ResetStreetAddress resets all changes to the "street_address" field.
func (m *AsPersonMutation) ResetStreetAddress() {
	m.street_address = nil
	delete(m.clearedFields, asperson.FieldStreetAddress)
}

// SetUserCode sets the "user_code" field.
func (m *AsPersonMutation) SetUserCode(s string) {
	m.user_code = &s
}

// UserCode returns the value of the "user_code" field in the mutation.
func (m *AsPersonMutation) UserCode() (r string, exists bool) {
	v := m.user_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCode returns the old "user_code" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldUserCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCode: %w", err)
	}
	return oldValue.UserCode, nil
}

// ClearUserCode clears the value of the "user_code" field.
func (m *AsPersonMutation) ClearUserCode() {
	m.user_code = nil
	m.clearedFields[asperson.FieldUserCode] = struct{}{}
}

// UserCodeCleared returns if the "user_code" field was cleared in this mutation.
func (m *AsPersonMutation) UserCodeCleared() bool {
	_, ok := m.clearedFields[asperson.FieldUserCode]
	return ok
}

// ResetUserCode resets all changes to the "user_code" field.
func (m *AsPersonMutation) ResetUserCode() {
	m.user_code = nil
	delete(m.clearedFields, asperson.FieldUserCode)
}

// SetIsMaster sets the "is_master" field.
func (m *AsPersonMutation) SetIsMaster(i int64) {
	m.is_master = &i
	m.addis_master = nil
}

// IsMaster returns the value of the "is_master" field in the mutation.
func (m *AsPersonMutation) IsMaster() (r int64, exists bool) {
	v := m.is_master
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMaster returns the old "is_master" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldIsMaster(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsMaster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsMaster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMaster: %w", err)
	}
	return oldValue.IsMaster, nil
}

// AddIsMaster adds i to the "is_master" field.
func (m *AsPersonMutation) AddIsMaster(i int64) {
	if m.addis_master != nil {
		*m.addis_master += i
	} else {
		m.addis_master = &i
	}
}

// AddedIsMaster returns the value that was added to the "is_master" field in this mutation.
func (m *AsPersonMutation) AddedIsMaster() (r int64, exists bool) {
	v := m.addis_master
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsMaster clears the value of the "is_master" field.
func (m *AsPersonMutation) ClearIsMaster() {
	m.is_master = nil
	m.addis_master = nil
	m.clearedFields[asperson.FieldIsMaster] = struct{}{}
}

// IsMasterCleared returns if the "is_master" field was cleared in this mutation.
func (m *AsPersonMutation) IsMasterCleared() bool {
	_, ok := m.clearedFields[asperson.FieldIsMaster]
	return ok
}

// ResetIsMaster resets all changes to the "is_master" field.
func (m *AsPersonMutation) ResetIsMaster() {
	m.is_master = nil
	m.addis_master = nil
	delete(m.clearedFields, asperson.FieldIsMaster)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsPersonMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsPersonMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsPersonMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsPersonMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsPersonMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsPersonMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsPersonMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsPersonMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsPersonMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsPersonMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asperson.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsPersonMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asperson.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsPersonMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asperson.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsPersonMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsPersonMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsPersonMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsPersonMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsPersonMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asperson.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsPersonMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asperson.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsPersonMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asperson.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsPersonMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsPersonMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsPersonMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsPersonMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsPersonMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asperson.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsPersonMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asperson.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsPersonMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asperson.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsPersonMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsPersonMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsPersonMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asperson.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsPersonMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asperson.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsPersonMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asperson.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsPersonMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsPersonMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsPerson entity.
// If the AsPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsPersonMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asperson.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsPersonMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asperson.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsPersonMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asperson.FieldUpdateTime)
}

// SetUserxID sets the "userx" edge to the AsUser entity by id.
func (m *AsPersonMutation) SetUserxID(id int64) {
	m.userx = &id
}

// ClearUserx clears the "userx" edge to the AsUser entity.
func (m *AsPersonMutation) ClearUserx() {
	m.cleareduserx = true
}

// UserxCleared reports if the "userx" edge to the AsUser entity was cleared.
func (m *AsPersonMutation) UserxCleared() bool {
	return m.cleareduserx
}

// UserxID returns the "userx" edge ID in the mutation.
func (m *AsPersonMutation) UserxID() (id int64, exists bool) {
	if m.userx != nil {
		return *m.userx, true
	}
	return
}

// UserxIDs returns the "userx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserxID instead. It exists only for internal usage by the builders.
func (m *AsPersonMutation) UserxIDs() (ids []int64) {
	if id := m.userx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserx resets all changes to the "userx" edge.
func (m *AsPersonMutation) ResetUserx() {
	m.userx = nil
	m.cleareduserx = false
}

// AddAgencyIDs adds the "agencys" edge to the AsInnerAgency entity by ids.
func (m *AsPersonMutation) AddAgencyIDs(ids ...int64) {
	if m.agencys == nil {
		m.agencys = make(map[int64]struct{})
	}
	for i := range ids {
		m.agencys[ids[i]] = struct{}{}
	}
}

// ClearAgencys clears the "agencys" edge to the AsInnerAgency entity.
func (m *AsPersonMutation) ClearAgencys() {
	m.clearedagencys = true
}

// AgencysCleared reports if the "agencys" edge to the AsInnerAgency entity was cleared.
func (m *AsPersonMutation) AgencysCleared() bool {
	return m.clearedagencys
}

// RemoveAgencyIDs removes the "agencys" edge to the AsInnerAgency entity by IDs.
func (m *AsPersonMutation) RemoveAgencyIDs(ids ...int64) {
	if m.removedagencys == nil {
		m.removedagencys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.agencys, ids[i])
		m.removedagencys[ids[i]] = struct{}{}
	}
}

// RemovedAgencys returns the removed IDs of the "agencys" edge to the AsInnerAgency entity.
func (m *AsPersonMutation) RemovedAgencysIDs() (ids []int64) {
	for id := range m.removedagencys {
		ids = append(ids, id)
	}
	return
}

// AgencysIDs returns the "agencys" edge IDs in the mutation.
func (m *AsPersonMutation) AgencysIDs() (ids []int64) {
	for id := range m.agencys {
		ids = append(ids, id)
	}
	return
}

// ResetAgencys resets all changes to the "agencys" edge.
func (m *AsPersonMutation) ResetAgencys() {
	m.agencys = nil
	m.clearedagencys = false
	m.removedagencys = nil
}

// AddJobIDs adds the "jobs" edge to the AsJob entity by ids.
func (m *AsPersonMutation) AddJobIDs(ids ...int64) {
	if m.jobs == nil {
		m.jobs = make(map[int64]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the AsJob entity.
func (m *AsPersonMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the AsJob entity was cleared.
func (m *AsPersonMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the AsJob entity by IDs.
func (m *AsPersonMutation) RemoveJobIDs(ids ...int64) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the AsJob entity.
func (m *AsPersonMutation) RemovedJobsIDs() (ids []int64) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *AsPersonMutation) JobsIDs() (ids []int64) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *AsPersonMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// Where appends a list predicates to the AsPersonMutation builder.
func (m *AsPersonMutation) Where(ps ...predicate.AsPerson) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsPersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsPerson).
func (m *AsPersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsPersonMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.tenant_code != nil {
		fields = append(fields, asperson.FieldTenantCode)
	}
	if m.real_name != nil {
		fields = append(fields, asperson.FieldRealName)
	}
	if m.id_card != nil {
		fields = append(fields, asperson.FieldIDCard)
	}
	if m.gender != nil {
		fields = append(fields, asperson.FieldGender)
	}
	if m.user_birthday != nil {
		fields = append(fields, asperson.FieldUserBirthday)
	}
	if m.user_email != nil {
		fields = append(fields, asperson.FieldUserEmail)
	}
	if m.user_photo != nil {
		fields = append(fields, asperson.FieldUserPhoto)
	}
	if m.userx != nil {
		fields = append(fields, asperson.FieldUserID)
	}
	if m.phone_number != nil {
		fields = append(fields, asperson.FieldPhoneNumber)
	}
	if m.province != nil {
		fields = append(fields, asperson.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, asperson.FieldCity)
	}
	if m.street_address != nil {
		fields = append(fields, asperson.FieldStreetAddress)
	}
	if m.user_code != nil {
		fields = append(fields, asperson.FieldUserCode)
	}
	if m.is_master != nil {
		fields = append(fields, asperson.FieldIsMaster)
	}
	if m.is_deleted != nil {
		fields = append(fields, asperson.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asperson.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asperson.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asperson.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asperson.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asperson.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsPersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asperson.FieldTenantCode:
		return m.TenantCode()
	case asperson.FieldRealName:
		return m.RealName()
	case asperson.FieldIDCard:
		return m.IDCard()
	case asperson.FieldGender:
		return m.Gender()
	case asperson.FieldUserBirthday:
		return m.UserBirthday()
	case asperson.FieldUserEmail:
		return m.UserEmail()
	case asperson.FieldUserPhoto:
		return m.UserPhoto()
	case asperson.FieldUserID:
		return m.UserID()
	case asperson.FieldPhoneNumber:
		return m.PhoneNumber()
	case asperson.FieldProvince:
		return m.Province()
	case asperson.FieldCity:
		return m.City()
	case asperson.FieldStreetAddress:
		return m.StreetAddress()
	case asperson.FieldUserCode:
		return m.UserCode()
	case asperson.FieldIsMaster:
		return m.IsMaster()
	case asperson.FieldIsDeleted:
		return m.IsDeleted()
	case asperson.FieldStatus:
		return m.Status()
	case asperson.FieldCreateUser:
		return m.CreateUser()
	case asperson.FieldUpdateUser:
		return m.UpdateUser()
	case asperson.FieldCreateTime:
		return m.CreateTime()
	case asperson.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsPersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asperson.FieldTenantCode:
		return m.OldTenantCode(ctx)
	case asperson.FieldRealName:
		return m.OldRealName(ctx)
	case asperson.FieldIDCard:
		return m.OldIDCard(ctx)
	case asperson.FieldGender:
		return m.OldGender(ctx)
	case asperson.FieldUserBirthday:
		return m.OldUserBirthday(ctx)
	case asperson.FieldUserEmail:
		return m.OldUserEmail(ctx)
	case asperson.FieldUserPhoto:
		return m.OldUserPhoto(ctx)
	case asperson.FieldUserID:
		return m.OldUserID(ctx)
	case asperson.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case asperson.FieldProvince:
		return m.OldProvince(ctx)
	case asperson.FieldCity:
		return m.OldCity(ctx)
	case asperson.FieldStreetAddress:
		return m.OldStreetAddress(ctx)
	case asperson.FieldUserCode:
		return m.OldUserCode(ctx)
	case asperson.FieldIsMaster:
		return m.OldIsMaster(ctx)
	case asperson.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asperson.FieldStatus:
		return m.OldStatus(ctx)
	case asperson.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asperson.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asperson.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asperson.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsPerson field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsPersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asperson.FieldTenantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantCode(v)
		return nil
	case asperson.FieldRealName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealName(v)
		return nil
	case asperson.FieldIDCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCard(v)
		return nil
	case asperson.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case asperson.FieldUserBirthday:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserBirthday(v)
		return nil
	case asperson.FieldUserEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserEmail(v)
		return nil
	case asperson.FieldUserPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserPhoto(v)
		return nil
	case asperson.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case asperson.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case asperson.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case asperson.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case asperson.FieldStreetAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetAddress(v)
		return nil
	case asperson.FieldUserCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCode(v)
		return nil
	case asperson.FieldIsMaster:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMaster(v)
		return nil
	case asperson.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asperson.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asperson.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asperson.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asperson.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asperson.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsPerson field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsPersonMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, asperson.FieldGender)
	}
	if m.addis_master != nil {
		fields = append(fields, asperson.FieldIsMaster)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asperson.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asperson.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asperson.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asperson.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsPersonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asperson.FieldGender:
		return m.AddedGender()
	case asperson.FieldIsMaster:
		return m.AddedIsMaster()
	case asperson.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asperson.FieldStatus:
		return m.AddedStatus()
	case asperson.FieldCreateUser:
		return m.AddedCreateUser()
	case asperson.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsPersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asperson.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case asperson.FieldIsMaster:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsMaster(v)
		return nil
	case asperson.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asperson.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asperson.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asperson.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsPerson numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsPersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asperson.FieldTenantCode) {
		fields = append(fields, asperson.FieldTenantCode)
	}
	if m.FieldCleared(asperson.FieldIDCard) {
		fields = append(fields, asperson.FieldIDCard)
	}
	if m.FieldCleared(asperson.FieldGender) {
		fields = append(fields, asperson.FieldGender)
	}
	if m.FieldCleared(asperson.FieldUserBirthday) {
		fields = append(fields, asperson.FieldUserBirthday)
	}
	if m.FieldCleared(asperson.FieldUserEmail) {
		fields = append(fields, asperson.FieldUserEmail)
	}
	if m.FieldCleared(asperson.FieldUserPhoto) {
		fields = append(fields, asperson.FieldUserPhoto)
	}
	if m.FieldCleared(asperson.FieldProvince) {
		fields = append(fields, asperson.FieldProvince)
	}
	if m.FieldCleared(asperson.FieldCity) {
		fields = append(fields, asperson.FieldCity)
	}
	if m.FieldCleared(asperson.FieldStreetAddress) {
		fields = append(fields, asperson.FieldStreetAddress)
	}
	if m.FieldCleared(asperson.FieldUserCode) {
		fields = append(fields, asperson.FieldUserCode)
	}
	if m.FieldCleared(asperson.FieldIsMaster) {
		fields = append(fields, asperson.FieldIsMaster)
	}
	if m.FieldCleared(asperson.FieldStatus) {
		fields = append(fields, asperson.FieldStatus)
	}
	if m.FieldCleared(asperson.FieldCreateUser) {
		fields = append(fields, asperson.FieldCreateUser)
	}
	if m.FieldCleared(asperson.FieldUpdateUser) {
		fields = append(fields, asperson.FieldUpdateUser)
	}
	if m.FieldCleared(asperson.FieldCreateTime) {
		fields = append(fields, asperson.FieldCreateTime)
	}
	if m.FieldCleared(asperson.FieldUpdateTime) {
		fields = append(fields, asperson.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsPersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsPersonMutation) ClearField(name string) error {
	switch name {
	case asperson.FieldTenantCode:
		m.ClearTenantCode()
		return nil
	case asperson.FieldIDCard:
		m.ClearIDCard()
		return nil
	case asperson.FieldGender:
		m.ClearGender()
		return nil
	case asperson.FieldUserBirthday:
		m.ClearUserBirthday()
		return nil
	case asperson.FieldUserEmail:
		m.ClearUserEmail()
		return nil
	case asperson.FieldUserPhoto:
		m.ClearUserPhoto()
		return nil
	case asperson.FieldProvince:
		m.ClearProvince()
		return nil
	case asperson.FieldCity:
		m.ClearCity()
		return nil
	case asperson.FieldStreetAddress:
		m.ClearStreetAddress()
		return nil
	case asperson.FieldUserCode:
		m.ClearUserCode()
		return nil
	case asperson.FieldIsMaster:
		m.ClearIsMaster()
		return nil
	case asperson.FieldStatus:
		m.ClearStatus()
		return nil
	case asperson.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asperson.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asperson.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asperson.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsPerson nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsPersonMutation) ResetField(name string) error {
	switch name {
	case asperson.FieldTenantCode:
		m.ResetTenantCode()
		return nil
	case asperson.FieldRealName:
		m.ResetRealName()
		return nil
	case asperson.FieldIDCard:
		m.ResetIDCard()
		return nil
	case asperson.FieldGender:
		m.ResetGender()
		return nil
	case asperson.FieldUserBirthday:
		m.ResetUserBirthday()
		return nil
	case asperson.FieldUserEmail:
		m.ResetUserEmail()
		return nil
	case asperson.FieldUserPhoto:
		m.ResetUserPhoto()
		return nil
	case asperson.FieldUserID:
		m.ResetUserID()
		return nil
	case asperson.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case asperson.FieldProvince:
		m.ResetProvince()
		return nil
	case asperson.FieldCity:
		m.ResetCity()
		return nil
	case asperson.FieldStreetAddress:
		m.ResetStreetAddress()
		return nil
	case asperson.FieldUserCode:
		m.ResetUserCode()
		return nil
	case asperson.FieldIsMaster:
		m.ResetIsMaster()
		return nil
	case asperson.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asperson.FieldStatus:
		m.ResetStatus()
		return nil
	case asperson.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asperson.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asperson.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asperson.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsPerson field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsPersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.userx != nil {
		edges = append(edges, asperson.EdgeUserx)
	}
	if m.agencys != nil {
		edges = append(edges, asperson.EdgeAgencys)
	}
	if m.jobs != nil {
		edges = append(edges, asperson.EdgeJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsPersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asperson.EdgeUserx:
		if id := m.userx; id != nil {
			return []ent.Value{*id}
		}
	case asperson.EdgeAgencys:
		ids := make([]ent.Value, 0, len(m.agencys))
		for id := range m.agencys {
			ids = append(ids, id)
		}
		return ids
	case asperson.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsPersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedagencys != nil {
		edges = append(edges, asperson.EdgeAgencys)
	}
	if m.removedjobs != nil {
		edges = append(edges, asperson.EdgeJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsPersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asperson.EdgeAgencys:
		ids := make([]ent.Value, 0, len(m.removedagencys))
		for id := range m.removedagencys {
			ids = append(ids, id)
		}
		return ids
	case asperson.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsPersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduserx {
		edges = append(edges, asperson.EdgeUserx)
	}
	if m.clearedagencys {
		edges = append(edges, asperson.EdgeAgencys)
	}
	if m.clearedjobs {
		edges = append(edges, asperson.EdgeJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsPersonMutation) EdgeCleared(name string) bool {
	switch name {
	case asperson.EdgeUserx:
		return m.cleareduserx
	case asperson.EdgeAgencys:
		return m.clearedagencys
	case asperson.EdgeJobs:
		return m.clearedjobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsPersonMutation) ClearEdge(name string) error {
	switch name {
	case asperson.EdgeUserx:
		m.ClearUserx()
		return nil
	}
	return fmt.Errorf("unknown AsPerson unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsPersonMutation) ResetEdge(name string) error {
	switch name {
	case asperson.EdgeUserx:
		m.ResetUserx()
		return nil
	case asperson.EdgeAgencys:
		m.ResetAgencys()
		return nil
	case asperson.EdgeJobs:
		m.ResetJobs()
		return nil
	}
	return fmt.Errorf("unknown AsPerson edge %s", name)
}

// AsPersonSingleMutation represents an operation that mutates the AsPersonSingle nodes in the graph.
type AsPersonSingleMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	real_name      *string
	id_card        *string
	gender         *int64
	addgender      *int64
	user_birthday  *date.DateTime
	user_email     *string
	user_photo     *string
	phone_number   *string
	province       *string
	city           *string
	street_address *string
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AsPersonSingle, error)
	predicates     []predicate.AsPersonSingle
}

var _ ent.Mutation = (*AsPersonSingleMutation)(nil)

// aspersonsingleOption allows management of the mutation configuration using functional options.
type aspersonsingleOption func(*AsPersonSingleMutation)

// newAsPersonSingleMutation creates new mutation for the AsPersonSingle entity.
func newAsPersonSingleMutation(c config, op Op, opts ...aspersonsingleOption) *AsPersonSingleMutation {
	m := &AsPersonSingleMutation{
		config:        c,
		op:            op,
		typ:           TypeAsPersonSingle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsPersonSingleID sets the ID field of the mutation.
func withAsPersonSingleID(id int64) aspersonsingleOption {
	return func(m *AsPersonSingleMutation) {
		var (
			err   error
			once  sync.Once
			value *AsPersonSingle
		)
		m.oldValue = func(ctx context.Context) (*AsPersonSingle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsPersonSingle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsPersonSingle sets the old AsPersonSingle of the mutation.
func withAsPersonSingle(node *AsPersonSingle) aspersonsingleOption {
	return func(m *AsPersonSingleMutation) {
		m.oldValue = func(context.Context) (*AsPersonSingle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsPersonSingleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsPersonSingleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsPersonSingle entities.
func (m *AsPersonSingleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsPersonSingleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsPersonSingleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsPersonSingle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRealName sets the "real_name" field.
func (m *AsPersonSingleMutation) SetRealName(s string) {
	m.real_name = &s
}

// RealName returns the value of the "real_name" field in the mutation.
func (m *AsPersonSingleMutation) RealName() (r string, exists bool) {
	v := m.real_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRealName returns the old "real_name" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldRealName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealName: %w", err)
	}
	return oldValue.RealName, nil
}

// ResetRealName resets all changes to the "real_name" field.
func (m *AsPersonSingleMutation) ResetRealName() {
	m.real_name = nil
}

// SetIDCard sets the "id_card" field.
func (m *AsPersonSingleMutation) SetIDCard(s string) {
	m.id_card = &s
}

// IDCard returns the value of the "id_card" field in the mutation.
func (m *AsPersonSingleMutation) IDCard() (r string, exists bool) {
	v := m.id_card
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCard returns the old "id_card" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldIDCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCard: %w", err)
	}
	return oldValue.IDCard, nil
}

// ClearIDCard clears the value of the "id_card" field.
func (m *AsPersonSingleMutation) ClearIDCard() {
	m.id_card = nil
	m.clearedFields[aspersonsingle.FieldIDCard] = struct{}{}
}

// IDCardCleared returns if the "id_card" field was cleared in this mutation.
func (m *AsPersonSingleMutation) IDCardCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldIDCard]
	return ok
}

// ResetIDCard resets all changes to the "id_card" field.
func (m *AsPersonSingleMutation) ResetIDCard() {
	m.id_card = nil
	delete(m.clearedFields, aspersonsingle.FieldIDCard)
}

// SetGender sets the "gender" field.
func (m *AsPersonSingleMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *AsPersonSingleMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *AsPersonSingleMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *AsPersonSingleMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *AsPersonSingleMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[aspersonsingle.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *AsPersonSingleMutation) GenderCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *AsPersonSingleMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, aspersonsingle.FieldGender)
}

// SetUserBirthday sets the "user_birthday" field.
func (m *AsPersonSingleMutation) SetUserBirthday(dt date.DateTime) {
	m.user_birthday = &dt
}

// UserBirthday returns the value of the "user_birthday" field in the mutation.
func (m *AsPersonSingleMutation) UserBirthday() (r date.DateTime, exists bool) {
	v := m.user_birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldUserBirthday returns the old "user_birthday" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldUserBirthday(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserBirthday: %w", err)
	}
	return oldValue.UserBirthday, nil
}

// ClearUserBirthday clears the value of the "user_birthday" field.
func (m *AsPersonSingleMutation) ClearUserBirthday() {
	m.user_birthday = nil
	m.clearedFields[aspersonsingle.FieldUserBirthday] = struct{}{}
}

// UserBirthdayCleared returns if the "user_birthday" field was cleared in this mutation.
func (m *AsPersonSingleMutation) UserBirthdayCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldUserBirthday]
	return ok
}

// ResetUserBirthday resets all changes to the "user_birthday" field.
func (m *AsPersonSingleMutation) ResetUserBirthday() {
	m.user_birthday = nil
	delete(m.clearedFields, aspersonsingle.FieldUserBirthday)
}

// SetUserEmail sets the "user_email" field.
func (m *AsPersonSingleMutation) SetUserEmail(s string) {
	m.user_email = &s
}

// UserEmail returns the value of the "user_email" field in the mutation.
func (m *AsPersonSingleMutation) UserEmail() (r string, exists bool) {
	v := m.user_email
	if v == nil {
		return
	}
	return *v, true
}

// OldUserEmail returns the old "user_email" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldUserEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserEmail: %w", err)
	}
	return oldValue.UserEmail, nil
}

// ClearUserEmail clears the value of the "user_email" field.
func (m *AsPersonSingleMutation) ClearUserEmail() {
	m.user_email = nil
	m.clearedFields[aspersonsingle.FieldUserEmail] = struct{}{}
}

// UserEmailCleared returns if the "user_email" field was cleared in this mutation.
func (m *AsPersonSingleMutation) UserEmailCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldUserEmail]
	return ok
}

// ResetUserEmail resets all changes to the "user_email" field.
func (m *AsPersonSingleMutation) ResetUserEmail() {
	m.user_email = nil
	delete(m.clearedFields, aspersonsingle.FieldUserEmail)
}

// SetUserPhoto sets the "user_photo" field.
func (m *AsPersonSingleMutation) SetUserPhoto(s string) {
	m.user_photo = &s
}

// UserPhoto returns the value of the "user_photo" field in the mutation.
func (m *AsPersonSingleMutation) UserPhoto() (r string, exists bool) {
	v := m.user_photo
	if v == nil {
		return
	}
	return *v, true
}

// OldUserPhoto returns the old "user_photo" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldUserPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserPhoto: %w", err)
	}
	return oldValue.UserPhoto, nil
}

// ClearUserPhoto clears the value of the "user_photo" field.
func (m *AsPersonSingleMutation) ClearUserPhoto() {
	m.user_photo = nil
	m.clearedFields[aspersonsingle.FieldUserPhoto] = struct{}{}
}

// UserPhotoCleared returns if the "user_photo" field was cleared in this mutation.
func (m *AsPersonSingleMutation) UserPhotoCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldUserPhoto]
	return ok
}

// ResetUserPhoto resets all changes to the "user_photo" field.
func (m *AsPersonSingleMutation) ResetUserPhoto() {
	m.user_photo = nil
	delete(m.clearedFields, aspersonsingle.FieldUserPhoto)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *AsPersonSingleMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *AsPersonSingleMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *AsPersonSingleMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetProvince sets the "province" field.
func (m *AsPersonSingleMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *AsPersonSingleMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *AsPersonSingleMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[aspersonsingle.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *AsPersonSingleMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *AsPersonSingleMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, aspersonsingle.FieldProvince)
}

// SetCity sets the "city" field.
func (m *AsPersonSingleMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AsPersonSingleMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *AsPersonSingleMutation) ClearCity() {
	m.city = nil
	m.clearedFields[aspersonsingle.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *AsPersonSingleMutation) CityCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *AsPersonSingleMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, aspersonsingle.FieldCity)
}

// SetStreetAddress sets the "street_address" field.
func (m *AsPersonSingleMutation) SetStreetAddress(s string) {
	m.street_address = &s
}

// StreetAddress returns the value of the "street_address" field in the mutation.
func (m *AsPersonSingleMutation) StreetAddress() (r string, exists bool) {
	v := m.street_address
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetAddress returns the old "street_address" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldStreetAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetAddress: %w", err)
	}
	return oldValue.StreetAddress, nil
}

// ClearStreetAddress clears the value of the "street_address" field.
func (m *AsPersonSingleMutation) ClearStreetAddress() {
	m.street_address = nil
	m.clearedFields[aspersonsingle.FieldStreetAddress] = struct{}{}
}

// StreetAddressCleared returns if the "street_address" field was cleared in this mutation.
func (m *AsPersonSingleMutation) StreetAddressCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldStreetAddress]
	return ok
}

// ResetStreetAddress resets all changes to the "street_address" field.
func (m *AsPersonSingleMutation) ResetStreetAddress() {
	m.street_address = nil
	delete(m.clearedFields, aspersonsingle.FieldStreetAddress)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsPersonSingleMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsPersonSingleMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsPersonSingleMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsPersonSingleMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsPersonSingleMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsPersonSingleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsPersonSingleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsPersonSingleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsPersonSingleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsPersonSingleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[aspersonsingle.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsPersonSingleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsPersonSingleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, aspersonsingle.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsPersonSingleMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsPersonSingleMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsPersonSingleMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsPersonSingleMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsPersonSingleMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[aspersonsingle.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsPersonSingleMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsPersonSingleMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, aspersonsingle.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsPersonSingleMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsPersonSingleMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsPersonSingleMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsPersonSingleMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsPersonSingleMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[aspersonsingle.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsPersonSingleMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsPersonSingleMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, aspersonsingle.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsPersonSingleMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsPersonSingleMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsPersonSingleMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[aspersonsingle.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsPersonSingleMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsPersonSingleMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, aspersonsingle.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsPersonSingleMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsPersonSingleMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsPersonSingle entity.
// If the AsPersonSingle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPersonSingleMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsPersonSingleMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[aspersonsingle.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsPersonSingleMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[aspersonsingle.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsPersonSingleMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, aspersonsingle.FieldUpdateTime)
}

// Where appends a list predicates to the AsPersonSingleMutation builder.
func (m *AsPersonSingleMutation) Where(ps ...predicate.AsPersonSingle) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsPersonSingleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsPersonSingle).
func (m *AsPersonSingleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsPersonSingleMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.real_name != nil {
		fields = append(fields, aspersonsingle.FieldRealName)
	}
	if m.id_card != nil {
		fields = append(fields, aspersonsingle.FieldIDCard)
	}
	if m.gender != nil {
		fields = append(fields, aspersonsingle.FieldGender)
	}
	if m.user_birthday != nil {
		fields = append(fields, aspersonsingle.FieldUserBirthday)
	}
	if m.user_email != nil {
		fields = append(fields, aspersonsingle.FieldUserEmail)
	}
	if m.user_photo != nil {
		fields = append(fields, aspersonsingle.FieldUserPhoto)
	}
	if m.phone_number != nil {
		fields = append(fields, aspersonsingle.FieldPhoneNumber)
	}
	if m.province != nil {
		fields = append(fields, aspersonsingle.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, aspersonsingle.FieldCity)
	}
	if m.street_address != nil {
		fields = append(fields, aspersonsingle.FieldStreetAddress)
	}
	if m.is_deleted != nil {
		fields = append(fields, aspersonsingle.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, aspersonsingle.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, aspersonsingle.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, aspersonsingle.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, aspersonsingle.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, aspersonsingle.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsPersonSingleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case aspersonsingle.FieldRealName:
		return m.RealName()
	case aspersonsingle.FieldIDCard:
		return m.IDCard()
	case aspersonsingle.FieldGender:
		return m.Gender()
	case aspersonsingle.FieldUserBirthday:
		return m.UserBirthday()
	case aspersonsingle.FieldUserEmail:
		return m.UserEmail()
	case aspersonsingle.FieldUserPhoto:
		return m.UserPhoto()
	case aspersonsingle.FieldPhoneNumber:
		return m.PhoneNumber()
	case aspersonsingle.FieldProvince:
		return m.Province()
	case aspersonsingle.FieldCity:
		return m.City()
	case aspersonsingle.FieldStreetAddress:
		return m.StreetAddress()
	case aspersonsingle.FieldIsDeleted:
		return m.IsDeleted()
	case aspersonsingle.FieldStatus:
		return m.Status()
	case aspersonsingle.FieldCreateUser:
		return m.CreateUser()
	case aspersonsingle.FieldUpdateUser:
		return m.UpdateUser()
	case aspersonsingle.FieldCreateTime:
		return m.CreateTime()
	case aspersonsingle.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsPersonSingleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case aspersonsingle.FieldRealName:
		return m.OldRealName(ctx)
	case aspersonsingle.FieldIDCard:
		return m.OldIDCard(ctx)
	case aspersonsingle.FieldGender:
		return m.OldGender(ctx)
	case aspersonsingle.FieldUserBirthday:
		return m.OldUserBirthday(ctx)
	case aspersonsingle.FieldUserEmail:
		return m.OldUserEmail(ctx)
	case aspersonsingle.FieldUserPhoto:
		return m.OldUserPhoto(ctx)
	case aspersonsingle.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case aspersonsingle.FieldProvince:
		return m.OldProvince(ctx)
	case aspersonsingle.FieldCity:
		return m.OldCity(ctx)
	case aspersonsingle.FieldStreetAddress:
		return m.OldStreetAddress(ctx)
	case aspersonsingle.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case aspersonsingle.FieldStatus:
		return m.OldStatus(ctx)
	case aspersonsingle.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case aspersonsingle.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case aspersonsingle.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case aspersonsingle.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsPersonSingle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsPersonSingleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case aspersonsingle.FieldRealName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealName(v)
		return nil
	case aspersonsingle.FieldIDCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCard(v)
		return nil
	case aspersonsingle.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case aspersonsingle.FieldUserBirthday:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserBirthday(v)
		return nil
	case aspersonsingle.FieldUserEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserEmail(v)
		return nil
	case aspersonsingle.FieldUserPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserPhoto(v)
		return nil
	case aspersonsingle.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case aspersonsingle.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case aspersonsingle.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case aspersonsingle.FieldStreetAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetAddress(v)
		return nil
	case aspersonsingle.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case aspersonsingle.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case aspersonsingle.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case aspersonsingle.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case aspersonsingle.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case aspersonsingle.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsPersonSingle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsPersonSingleMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, aspersonsingle.FieldGender)
	}
	if m.addis_deleted != nil {
		fields = append(fields, aspersonsingle.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, aspersonsingle.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, aspersonsingle.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, aspersonsingle.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsPersonSingleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case aspersonsingle.FieldGender:
		return m.AddedGender()
	case aspersonsingle.FieldIsDeleted:
		return m.AddedIsDeleted()
	case aspersonsingle.FieldStatus:
		return m.AddedStatus()
	case aspersonsingle.FieldCreateUser:
		return m.AddedCreateUser()
	case aspersonsingle.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsPersonSingleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case aspersonsingle.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case aspersonsingle.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case aspersonsingle.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case aspersonsingle.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case aspersonsingle.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsPersonSingle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsPersonSingleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(aspersonsingle.FieldIDCard) {
		fields = append(fields, aspersonsingle.FieldIDCard)
	}
	if m.FieldCleared(aspersonsingle.FieldGender) {
		fields = append(fields, aspersonsingle.FieldGender)
	}
	if m.FieldCleared(aspersonsingle.FieldUserBirthday) {
		fields = append(fields, aspersonsingle.FieldUserBirthday)
	}
	if m.FieldCleared(aspersonsingle.FieldUserEmail) {
		fields = append(fields, aspersonsingle.FieldUserEmail)
	}
	if m.FieldCleared(aspersonsingle.FieldUserPhoto) {
		fields = append(fields, aspersonsingle.FieldUserPhoto)
	}
	if m.FieldCleared(aspersonsingle.FieldProvince) {
		fields = append(fields, aspersonsingle.FieldProvince)
	}
	if m.FieldCleared(aspersonsingle.FieldCity) {
		fields = append(fields, aspersonsingle.FieldCity)
	}
	if m.FieldCleared(aspersonsingle.FieldStreetAddress) {
		fields = append(fields, aspersonsingle.FieldStreetAddress)
	}
	if m.FieldCleared(aspersonsingle.FieldStatus) {
		fields = append(fields, aspersonsingle.FieldStatus)
	}
	if m.FieldCleared(aspersonsingle.FieldCreateUser) {
		fields = append(fields, aspersonsingle.FieldCreateUser)
	}
	if m.FieldCleared(aspersonsingle.FieldUpdateUser) {
		fields = append(fields, aspersonsingle.FieldUpdateUser)
	}
	if m.FieldCleared(aspersonsingle.FieldCreateTime) {
		fields = append(fields, aspersonsingle.FieldCreateTime)
	}
	if m.FieldCleared(aspersonsingle.FieldUpdateTime) {
		fields = append(fields, aspersonsingle.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsPersonSingleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsPersonSingleMutation) ClearField(name string) error {
	switch name {
	case aspersonsingle.FieldIDCard:
		m.ClearIDCard()
		return nil
	case aspersonsingle.FieldGender:
		m.ClearGender()
		return nil
	case aspersonsingle.FieldUserBirthday:
		m.ClearUserBirthday()
		return nil
	case aspersonsingle.FieldUserEmail:
		m.ClearUserEmail()
		return nil
	case aspersonsingle.FieldUserPhoto:
		m.ClearUserPhoto()
		return nil
	case aspersonsingle.FieldProvince:
		m.ClearProvince()
		return nil
	case aspersonsingle.FieldCity:
		m.ClearCity()
		return nil
	case aspersonsingle.FieldStreetAddress:
		m.ClearStreetAddress()
		return nil
	case aspersonsingle.FieldStatus:
		m.ClearStatus()
		return nil
	case aspersonsingle.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case aspersonsingle.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case aspersonsingle.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case aspersonsingle.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsPersonSingle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsPersonSingleMutation) ResetField(name string) error {
	switch name {
	case aspersonsingle.FieldRealName:
		m.ResetRealName()
		return nil
	case aspersonsingle.FieldIDCard:
		m.ResetIDCard()
		return nil
	case aspersonsingle.FieldGender:
		m.ResetGender()
		return nil
	case aspersonsingle.FieldUserBirthday:
		m.ResetUserBirthday()
		return nil
	case aspersonsingle.FieldUserEmail:
		m.ResetUserEmail()
		return nil
	case aspersonsingle.FieldUserPhoto:
		m.ResetUserPhoto()
		return nil
	case aspersonsingle.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case aspersonsingle.FieldProvince:
		m.ResetProvince()
		return nil
	case aspersonsingle.FieldCity:
		m.ResetCity()
		return nil
	case aspersonsingle.FieldStreetAddress:
		m.ResetStreetAddress()
		return nil
	case aspersonsingle.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case aspersonsingle.FieldStatus:
		m.ResetStatus()
		return nil
	case aspersonsingle.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case aspersonsingle.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case aspersonsingle.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case aspersonsingle.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsPersonSingle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsPersonSingleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsPersonSingleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsPersonSingleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsPersonSingleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsPersonSingleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsPersonSingleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsPersonSingleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AsPersonSingle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsPersonSingleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AsPersonSingle edge %s", name)
}

// AsPropertiesMutation represents an operation that mutates the AsProperties nodes in the graph.
type AsPropertiesMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	properties_name   *string
	group_id          *int64
	addgroup_id       *int64
	is_deleted        *int64
	addis_deleted     *int64
	status            *int64
	addstatus         *int64
	create_user       *int64
	addcreate_user    *int64
	update_user       *int64
	addupdate_user    *int64
	create_time       *date.DateTime
	update_time       *date.DateTime
	clearedFields     map[string]struct{}
	allTenants        map[int64]struct{}
	removedallTenants map[int64]struct{}
	clearedallTenants bool
	done              bool
	oldValue          func(context.Context) (*AsProperties, error)
	predicates        []predicate.AsProperties
}

var _ ent.Mutation = (*AsPropertiesMutation)(nil)

// aspropertiesOption allows management of the mutation configuration using functional options.
type aspropertiesOption func(*AsPropertiesMutation)

// newAsPropertiesMutation creates new mutation for the AsProperties entity.
func newAsPropertiesMutation(c config, op Op, opts ...aspropertiesOption) *AsPropertiesMutation {
	m := &AsPropertiesMutation{
		config:        c,
		op:            op,
		typ:           TypeAsProperties,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsPropertiesID sets the ID field of the mutation.
func withAsPropertiesID(id int64) aspropertiesOption {
	return func(m *AsPropertiesMutation) {
		var (
			err   error
			once  sync.Once
			value *AsProperties
		)
		m.oldValue = func(ctx context.Context) (*AsProperties, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsProperties.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsProperties sets the old AsProperties of the mutation.
func withAsProperties(node *AsProperties) aspropertiesOption {
	return func(m *AsPropertiesMutation) {
		m.oldValue = func(context.Context) (*AsProperties, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsPropertiesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsPropertiesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsProperties entities.
func (m *AsPropertiesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsPropertiesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsPropertiesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsProperties.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPropertiesName sets the "properties_name" field.
func (m *AsPropertiesMutation) SetPropertiesName(s string) {
	m.properties_name = &s
}

// PropertiesName returns the value of the "properties_name" field in the mutation.
func (m *AsPropertiesMutation) PropertiesName() (r string, exists bool) {
	v := m.properties_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertiesName returns the old "properties_name" field's value of the AsProperties entity.
// If the AsProperties object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesMutation) OldPropertiesName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertiesName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertiesName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertiesName: %w", err)
	}
	return oldValue.PropertiesName, nil
}

// ResetPropertiesName resets all changes to the "properties_name" field.
func (m *AsPropertiesMutation) ResetPropertiesName() {
	m.properties_name = nil
}

// SetGroupID sets the "group_id" field.
func (m *AsPropertiesMutation) SetGroupID(i int64) {
	m.group_id = &i
	m.addgroup_id = nil
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *AsPropertiesMutation) GroupID() (r int64, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the AsProperties entity.
// If the AsProperties object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// AddGroupID adds i to the "group_id" field.
func (m *AsPropertiesMutation) AddGroupID(i int64) {
	if m.addgroup_id != nil {
		*m.addgroup_id += i
	} else {
		m.addgroup_id = &i
	}
}

// AddedGroupID returns the value that was added to the "group_id" field in this mutation.
func (m *AsPropertiesMutation) AddedGroupID() (r int64, exists bool) {
	v := m.addgroup_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *AsPropertiesMutation) ResetGroupID() {
	m.group_id = nil
	m.addgroup_id = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsPropertiesMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsPropertiesMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsProperties entity.
// If the AsProperties object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsPropertiesMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsPropertiesMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsPropertiesMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsPropertiesMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsPropertiesMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsProperties entity.
// If the AsProperties object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsPropertiesMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsPropertiesMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsPropertiesMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asproperties.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsPropertiesMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asproperties.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsPropertiesMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asproperties.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsPropertiesMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsPropertiesMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsProperties entity.
// If the AsProperties object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsPropertiesMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsPropertiesMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsPropertiesMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asproperties.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsPropertiesMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asproperties.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsPropertiesMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asproperties.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsPropertiesMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsPropertiesMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsProperties entity.
// If the AsProperties object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsPropertiesMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsPropertiesMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsPropertiesMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asproperties.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsPropertiesMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asproperties.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsPropertiesMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asproperties.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsPropertiesMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsPropertiesMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsProperties entity.
// If the AsProperties object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsPropertiesMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asproperties.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsPropertiesMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asproperties.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsPropertiesMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asproperties.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsPropertiesMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsPropertiesMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsProperties entity.
// If the AsProperties object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsPropertiesMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asproperties.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsPropertiesMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asproperties.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsPropertiesMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asproperties.FieldUpdateTime)
}

// AddAllTenantIDs adds the "allTenants" edge to the AsPropertiesDistribution entity by ids.
func (m *AsPropertiesMutation) AddAllTenantIDs(ids ...int64) {
	if m.allTenants == nil {
		m.allTenants = make(map[int64]struct{})
	}
	for i := range ids {
		m.allTenants[ids[i]] = struct{}{}
	}
}

// ClearAllTenants clears the "allTenants" edge to the AsPropertiesDistribution entity.
func (m *AsPropertiesMutation) ClearAllTenants() {
	m.clearedallTenants = true
}

// AllTenantsCleared reports if the "allTenants" edge to the AsPropertiesDistribution entity was cleared.
func (m *AsPropertiesMutation) AllTenantsCleared() bool {
	return m.clearedallTenants
}

// RemoveAllTenantIDs removes the "allTenants" edge to the AsPropertiesDistribution entity by IDs.
func (m *AsPropertiesMutation) RemoveAllTenantIDs(ids ...int64) {
	if m.removedallTenants == nil {
		m.removedallTenants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allTenants, ids[i])
		m.removedallTenants[ids[i]] = struct{}{}
	}
}

// RemovedAllTenants returns the removed IDs of the "allTenants" edge to the AsPropertiesDistribution entity.
func (m *AsPropertiesMutation) RemovedAllTenantsIDs() (ids []int64) {
	for id := range m.removedallTenants {
		ids = append(ids, id)
	}
	return
}

// AllTenantsIDs returns the "allTenants" edge IDs in the mutation.
func (m *AsPropertiesMutation) AllTenantsIDs() (ids []int64) {
	for id := range m.allTenants {
		ids = append(ids, id)
	}
	return
}

// ResetAllTenants resets all changes to the "allTenants" edge.
func (m *AsPropertiesMutation) ResetAllTenants() {
	m.allTenants = nil
	m.clearedallTenants = false
	m.removedallTenants = nil
}

// Where appends a list predicates to the AsPropertiesMutation builder.
func (m *AsPropertiesMutation) Where(ps ...predicate.AsProperties) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsPropertiesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsProperties).
func (m *AsPropertiesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsPropertiesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.properties_name != nil {
		fields = append(fields, asproperties.FieldPropertiesName)
	}
	if m.group_id != nil {
		fields = append(fields, asproperties.FieldGroupID)
	}
	if m.is_deleted != nil {
		fields = append(fields, asproperties.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asproperties.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asproperties.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asproperties.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asproperties.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asproperties.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsPropertiesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asproperties.FieldPropertiesName:
		return m.PropertiesName()
	case asproperties.FieldGroupID:
		return m.GroupID()
	case asproperties.FieldIsDeleted:
		return m.IsDeleted()
	case asproperties.FieldStatus:
		return m.Status()
	case asproperties.FieldCreateUser:
		return m.CreateUser()
	case asproperties.FieldUpdateUser:
		return m.UpdateUser()
	case asproperties.FieldCreateTime:
		return m.CreateTime()
	case asproperties.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsPropertiesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asproperties.FieldPropertiesName:
		return m.OldPropertiesName(ctx)
	case asproperties.FieldGroupID:
		return m.OldGroupID(ctx)
	case asproperties.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asproperties.FieldStatus:
		return m.OldStatus(ctx)
	case asproperties.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asproperties.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asproperties.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asproperties.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsProperties field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsPropertiesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asproperties.FieldPropertiesName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertiesName(v)
		return nil
	case asproperties.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case asproperties.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asproperties.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asproperties.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asproperties.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asproperties.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asproperties.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsProperties field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsPropertiesMutation) AddedFields() []string {
	var fields []string
	if m.addgroup_id != nil {
		fields = append(fields, asproperties.FieldGroupID)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asproperties.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asproperties.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asproperties.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asproperties.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsPropertiesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asproperties.FieldGroupID:
		return m.AddedGroupID()
	case asproperties.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asproperties.FieldStatus:
		return m.AddedStatus()
	case asproperties.FieldCreateUser:
		return m.AddedCreateUser()
	case asproperties.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsPropertiesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asproperties.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupID(v)
		return nil
	case asproperties.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asproperties.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asproperties.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asproperties.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsProperties numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsPropertiesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asproperties.FieldStatus) {
		fields = append(fields, asproperties.FieldStatus)
	}
	if m.FieldCleared(asproperties.FieldCreateUser) {
		fields = append(fields, asproperties.FieldCreateUser)
	}
	if m.FieldCleared(asproperties.FieldUpdateUser) {
		fields = append(fields, asproperties.FieldUpdateUser)
	}
	if m.FieldCleared(asproperties.FieldCreateTime) {
		fields = append(fields, asproperties.FieldCreateTime)
	}
	if m.FieldCleared(asproperties.FieldUpdateTime) {
		fields = append(fields, asproperties.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsPropertiesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsPropertiesMutation) ClearField(name string) error {
	switch name {
	case asproperties.FieldStatus:
		m.ClearStatus()
		return nil
	case asproperties.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asproperties.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asproperties.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asproperties.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsProperties nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsPropertiesMutation) ResetField(name string) error {
	switch name {
	case asproperties.FieldPropertiesName:
		m.ResetPropertiesName()
		return nil
	case asproperties.FieldGroupID:
		m.ResetGroupID()
		return nil
	case asproperties.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asproperties.FieldStatus:
		m.ResetStatus()
		return nil
	case asproperties.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asproperties.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asproperties.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asproperties.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsProperties field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsPropertiesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.allTenants != nil {
		edges = append(edges, asproperties.EdgeAllTenants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsPropertiesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asproperties.EdgeAllTenants:
		ids := make([]ent.Value, 0, len(m.allTenants))
		for id := range m.allTenants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsPropertiesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedallTenants != nil {
		edges = append(edges, asproperties.EdgeAllTenants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsPropertiesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asproperties.EdgeAllTenants:
		ids := make([]ent.Value, 0, len(m.removedallTenants))
		for id := range m.removedallTenants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsPropertiesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedallTenants {
		edges = append(edges, asproperties.EdgeAllTenants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsPropertiesMutation) EdgeCleared(name string) bool {
	switch name {
	case asproperties.EdgeAllTenants:
		return m.clearedallTenants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsPropertiesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AsProperties unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsPropertiesMutation) ResetEdge(name string) error {
	switch name {
	case asproperties.EdgeAllTenants:
		m.ResetAllTenants()
		return nil
	}
	return fmt.Errorf("unknown AsProperties edge %s", name)
}

// AsPropertiesDistributionMutation represents an operation that mutates the AsPropertiesDistribution nodes in the graph.
type AsPropertiesDistributionMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	is_deleted        *int64
	addis_deleted     *int64
	status            *int64
	addstatus         *int64
	create_user       *int64
	addcreate_user    *int64
	update_user       *int64
	addupdate_user    *int64
	create_time       *date.DateTime
	update_time       *date.DateTime
	clearedFields     map[string]struct{}
	properties        *int64
	clearedproperties bool
	tenant            *int64
	clearedtenant     bool
	done              bool
	oldValue          func(context.Context) (*AsPropertiesDistribution, error)
	predicates        []predicate.AsPropertiesDistribution
}

var _ ent.Mutation = (*AsPropertiesDistributionMutation)(nil)

// aspropertiesdistributionOption allows management of the mutation configuration using functional options.
type aspropertiesdistributionOption func(*AsPropertiesDistributionMutation)

// newAsPropertiesDistributionMutation creates new mutation for the AsPropertiesDistribution entity.
func newAsPropertiesDistributionMutation(c config, op Op, opts ...aspropertiesdistributionOption) *AsPropertiesDistributionMutation {
	m := &AsPropertiesDistributionMutation{
		config:        c,
		op:            op,
		typ:           TypeAsPropertiesDistribution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsPropertiesDistributionID sets the ID field of the mutation.
func withAsPropertiesDistributionID(id int64) aspropertiesdistributionOption {
	return func(m *AsPropertiesDistributionMutation) {
		var (
			err   error
			once  sync.Once
			value *AsPropertiesDistribution
		)
		m.oldValue = func(ctx context.Context) (*AsPropertiesDistribution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsPropertiesDistribution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsPropertiesDistribution sets the old AsPropertiesDistribution of the mutation.
func withAsPropertiesDistribution(node *AsPropertiesDistribution) aspropertiesdistributionOption {
	return func(m *AsPropertiesDistributionMutation) {
		m.oldValue = func(context.Context) (*AsPropertiesDistribution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsPropertiesDistributionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsPropertiesDistributionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsPropertiesDistribution entities.
func (m *AsPropertiesDistributionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsPropertiesDistributionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsPropertiesDistributionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsPropertiesDistribution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPropertiesID sets the "properties_id" field.
func (m *AsPropertiesDistributionMutation) SetPropertiesID(i int64) {
	m.properties = &i
}

// PropertiesID returns the value of the "properties_id" field in the mutation.
func (m *AsPropertiesDistributionMutation) PropertiesID() (r int64, exists bool) {
	v := m.properties
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertiesID returns the old "properties_id" field's value of the AsPropertiesDistribution entity.
// If the AsPropertiesDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesDistributionMutation) OldPropertiesID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertiesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertiesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertiesID: %w", err)
	}
	return oldValue.PropertiesID, nil
}

// ClearPropertiesID clears the value of the "properties_id" field.
func (m *AsPropertiesDistributionMutation) ClearPropertiesID() {
	m.properties = nil
	m.clearedFields[aspropertiesdistribution.FieldPropertiesID] = struct{}{}
}

// PropertiesIDCleared returns if the "properties_id" field was cleared in this mutation.
func (m *AsPropertiesDistributionMutation) PropertiesIDCleared() bool {
	_, ok := m.clearedFields[aspropertiesdistribution.FieldPropertiesID]
	return ok
}

// ResetPropertiesID resets all changes to the "properties_id" field.
func (m *AsPropertiesDistributionMutation) ResetPropertiesID() {
	m.properties = nil
	delete(m.clearedFields, aspropertiesdistribution.FieldPropertiesID)
}

// SetTenantID sets the "tenant_id" field.
func (m *AsPropertiesDistributionMutation) SetTenantID(i int64) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AsPropertiesDistributionMutation) TenantID() (r int64, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AsPropertiesDistribution entity.
// If the AsPropertiesDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesDistributionMutation) OldTenantID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AsPropertiesDistributionMutation) ClearTenantID() {
	m.tenant = nil
	m.clearedFields[aspropertiesdistribution.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AsPropertiesDistributionMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[aspropertiesdistribution.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AsPropertiesDistributionMutation) ResetTenantID() {
	m.tenant = nil
	delete(m.clearedFields, aspropertiesdistribution.FieldTenantID)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsPropertiesDistributionMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsPropertiesDistributionMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsPropertiesDistribution entity.
// If the AsPropertiesDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesDistributionMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsPropertiesDistributionMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsPropertiesDistributionMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsPropertiesDistributionMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsPropertiesDistributionMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsPropertiesDistributionMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsPropertiesDistribution entity.
// If the AsPropertiesDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesDistributionMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsPropertiesDistributionMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsPropertiesDistributionMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsPropertiesDistributionMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[aspropertiesdistribution.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsPropertiesDistributionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[aspropertiesdistribution.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsPropertiesDistributionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, aspropertiesdistribution.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsPropertiesDistributionMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsPropertiesDistributionMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsPropertiesDistribution entity.
// If the AsPropertiesDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesDistributionMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsPropertiesDistributionMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsPropertiesDistributionMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsPropertiesDistributionMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[aspropertiesdistribution.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsPropertiesDistributionMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[aspropertiesdistribution.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsPropertiesDistributionMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, aspropertiesdistribution.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsPropertiesDistributionMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsPropertiesDistributionMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsPropertiesDistribution entity.
// If the AsPropertiesDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesDistributionMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsPropertiesDistributionMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsPropertiesDistributionMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsPropertiesDistributionMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[aspropertiesdistribution.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsPropertiesDistributionMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[aspropertiesdistribution.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsPropertiesDistributionMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, aspropertiesdistribution.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsPropertiesDistributionMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsPropertiesDistributionMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsPropertiesDistribution entity.
// If the AsPropertiesDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesDistributionMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsPropertiesDistributionMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[aspropertiesdistribution.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsPropertiesDistributionMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[aspropertiesdistribution.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsPropertiesDistributionMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, aspropertiesdistribution.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsPropertiesDistributionMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsPropertiesDistributionMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsPropertiesDistribution entity.
// If the AsPropertiesDistribution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsPropertiesDistributionMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsPropertiesDistributionMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[aspropertiesdistribution.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsPropertiesDistributionMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[aspropertiesdistribution.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsPropertiesDistributionMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, aspropertiesdistribution.FieldUpdateTime)
}

// ClearProperties clears the "properties" edge to the AsProperties entity.
func (m *AsPropertiesDistributionMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the AsProperties entity was cleared.
func (m *AsPropertiesDistributionMutation) PropertiesCleared() bool {
	return m.PropertiesIDCleared() || m.clearedproperties
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertiesID instead. It exists only for internal usage by the builders.
func (m *AsPropertiesDistributionMutation) PropertiesIDs() (ids []int64) {
	if id := m.properties; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *AsPropertiesDistributionMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
}

// ClearTenant clears the "tenant" edge to the AsTenant entity.
func (m *AsPropertiesDistributionMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the AsTenant entity was cleared.
func (m *AsPropertiesDistributionMutation) TenantCleared() bool {
	return m.TenantIDCleared() || m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AsPropertiesDistributionMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AsPropertiesDistributionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the AsPropertiesDistributionMutation builder.
func (m *AsPropertiesDistributionMutation) Where(ps ...predicate.AsPropertiesDistribution) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsPropertiesDistributionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsPropertiesDistribution).
func (m *AsPropertiesDistributionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsPropertiesDistributionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.properties != nil {
		fields = append(fields, aspropertiesdistribution.FieldPropertiesID)
	}
	if m.tenant != nil {
		fields = append(fields, aspropertiesdistribution.FieldTenantID)
	}
	if m.is_deleted != nil {
		fields = append(fields, aspropertiesdistribution.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, aspropertiesdistribution.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, aspropertiesdistribution.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, aspropertiesdistribution.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, aspropertiesdistribution.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, aspropertiesdistribution.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsPropertiesDistributionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case aspropertiesdistribution.FieldPropertiesID:
		return m.PropertiesID()
	case aspropertiesdistribution.FieldTenantID:
		return m.TenantID()
	case aspropertiesdistribution.FieldIsDeleted:
		return m.IsDeleted()
	case aspropertiesdistribution.FieldStatus:
		return m.Status()
	case aspropertiesdistribution.FieldCreateUser:
		return m.CreateUser()
	case aspropertiesdistribution.FieldUpdateUser:
		return m.UpdateUser()
	case aspropertiesdistribution.FieldCreateTime:
		return m.CreateTime()
	case aspropertiesdistribution.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsPropertiesDistributionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case aspropertiesdistribution.FieldPropertiesID:
		return m.OldPropertiesID(ctx)
	case aspropertiesdistribution.FieldTenantID:
		return m.OldTenantID(ctx)
	case aspropertiesdistribution.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case aspropertiesdistribution.FieldStatus:
		return m.OldStatus(ctx)
	case aspropertiesdistribution.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case aspropertiesdistribution.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case aspropertiesdistribution.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case aspropertiesdistribution.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsPropertiesDistribution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsPropertiesDistributionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case aspropertiesdistribution.FieldPropertiesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertiesID(v)
		return nil
	case aspropertiesdistribution.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case aspropertiesdistribution.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case aspropertiesdistribution.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case aspropertiesdistribution.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case aspropertiesdistribution.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case aspropertiesdistribution.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case aspropertiesdistribution.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsPropertiesDistribution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsPropertiesDistributionMutation) AddedFields() []string {
	var fields []string
	if m.addis_deleted != nil {
		fields = append(fields, aspropertiesdistribution.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, aspropertiesdistribution.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, aspropertiesdistribution.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, aspropertiesdistribution.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsPropertiesDistributionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case aspropertiesdistribution.FieldIsDeleted:
		return m.AddedIsDeleted()
	case aspropertiesdistribution.FieldStatus:
		return m.AddedStatus()
	case aspropertiesdistribution.FieldCreateUser:
		return m.AddedCreateUser()
	case aspropertiesdistribution.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsPropertiesDistributionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case aspropertiesdistribution.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case aspropertiesdistribution.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case aspropertiesdistribution.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case aspropertiesdistribution.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsPropertiesDistribution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsPropertiesDistributionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(aspropertiesdistribution.FieldPropertiesID) {
		fields = append(fields, aspropertiesdistribution.FieldPropertiesID)
	}
	if m.FieldCleared(aspropertiesdistribution.FieldTenantID) {
		fields = append(fields, aspropertiesdistribution.FieldTenantID)
	}
	if m.FieldCleared(aspropertiesdistribution.FieldStatus) {
		fields = append(fields, aspropertiesdistribution.FieldStatus)
	}
	if m.FieldCleared(aspropertiesdistribution.FieldCreateUser) {
		fields = append(fields, aspropertiesdistribution.FieldCreateUser)
	}
	if m.FieldCleared(aspropertiesdistribution.FieldUpdateUser) {
		fields = append(fields, aspropertiesdistribution.FieldUpdateUser)
	}
	if m.FieldCleared(aspropertiesdistribution.FieldCreateTime) {
		fields = append(fields, aspropertiesdistribution.FieldCreateTime)
	}
	if m.FieldCleared(aspropertiesdistribution.FieldUpdateTime) {
		fields = append(fields, aspropertiesdistribution.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsPropertiesDistributionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsPropertiesDistributionMutation) ClearField(name string) error {
	switch name {
	case aspropertiesdistribution.FieldPropertiesID:
		m.ClearPropertiesID()
		return nil
	case aspropertiesdistribution.FieldTenantID:
		m.ClearTenantID()
		return nil
	case aspropertiesdistribution.FieldStatus:
		m.ClearStatus()
		return nil
	case aspropertiesdistribution.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case aspropertiesdistribution.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case aspropertiesdistribution.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case aspropertiesdistribution.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsPropertiesDistribution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsPropertiesDistributionMutation) ResetField(name string) error {
	switch name {
	case aspropertiesdistribution.FieldPropertiesID:
		m.ResetPropertiesID()
		return nil
	case aspropertiesdistribution.FieldTenantID:
		m.ResetTenantID()
		return nil
	case aspropertiesdistribution.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case aspropertiesdistribution.FieldStatus:
		m.ResetStatus()
		return nil
	case aspropertiesdistribution.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case aspropertiesdistribution.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case aspropertiesdistribution.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case aspropertiesdistribution.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsPropertiesDistribution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsPropertiesDistributionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.properties != nil {
		edges = append(edges, aspropertiesdistribution.EdgeProperties)
	}
	if m.tenant != nil {
		edges = append(edges, aspropertiesdistribution.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsPropertiesDistributionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case aspropertiesdistribution.EdgeProperties:
		if id := m.properties; id != nil {
			return []ent.Value{*id}
		}
	case aspropertiesdistribution.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsPropertiesDistributionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsPropertiesDistributionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsPropertiesDistributionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproperties {
		edges = append(edges, aspropertiesdistribution.EdgeProperties)
	}
	if m.clearedtenant {
		edges = append(edges, aspropertiesdistribution.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsPropertiesDistributionMutation) EdgeCleared(name string) bool {
	switch name {
	case aspropertiesdistribution.EdgeProperties:
		return m.clearedproperties
	case aspropertiesdistribution.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsPropertiesDistributionMutation) ClearEdge(name string) error {
	switch name {
	case aspropertiesdistribution.EdgeProperties:
		m.ClearProperties()
		return nil
	case aspropertiesdistribution.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown AsPropertiesDistribution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsPropertiesDistributionMutation) ResetEdge(name string) error {
	switch name {
	case aspropertiesdistribution.EdgeProperties:
		m.ResetProperties()
		return nil
	case aspropertiesdistribution.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown AsPropertiesDistribution edge %s", name)
}

// AsRedeployDataMutation represents an operation that mutates the AsRedeployData nodes in the graph.
type AsRedeployDataMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	application    *string
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	appx           *int64
	clearedappx    bool
	done           bool
	oldValue       func(context.Context) (*AsRedeployData, error)
	predicates     []predicate.AsRedeployData
}

var _ ent.Mutation = (*AsRedeployDataMutation)(nil)

// asredeploydataOption allows management of the mutation configuration using functional options.
type asredeploydataOption func(*AsRedeployDataMutation)

// newAsRedeployDataMutation creates new mutation for the AsRedeployData entity.
func newAsRedeployDataMutation(c config, op Op, opts ...asredeploydataOption) *AsRedeployDataMutation {
	m := &AsRedeployDataMutation{
		config:        c,
		op:            op,
		typ:           TypeAsRedeployData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsRedeployDataID sets the ID field of the mutation.
func withAsRedeployDataID(id int64) asredeploydataOption {
	return func(m *AsRedeployDataMutation) {
		var (
			err   error
			once  sync.Once
			value *AsRedeployData
		)
		m.oldValue = func(ctx context.Context) (*AsRedeployData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsRedeployData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsRedeployData sets the old AsRedeployData of the mutation.
func withAsRedeployData(node *AsRedeployData) asredeploydataOption {
	return func(m *AsRedeployDataMutation) {
		m.oldValue = func(context.Context) (*AsRedeployData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsRedeployDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsRedeployDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsRedeployData entities.
func (m *AsRedeployDataMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsRedeployDataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsRedeployDataMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsRedeployData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AsRedeployDataMutation) SetAppID(i int64) {
	m.appx = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsRedeployDataMutation) AppID() (r int64, exists bool) {
	v := m.appx
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsRedeployData entity.
// If the AsRedeployData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRedeployDataMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AsRedeployDataMutation) ClearAppID() {
	m.appx = nil
	m.clearedFields[asredeploydata.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AsRedeployDataMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[asredeploydata.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsRedeployDataMutation) ResetAppID() {
	m.appx = nil
	delete(m.clearedFields, asredeploydata.FieldAppID)
}

// SetApplication sets the "application" field.
func (m *AsRedeployDataMutation) SetApplication(s string) {
	m.application = &s
}

// Application returns the value of the "application" field in the mutation.
func (m *AsRedeployDataMutation) Application() (r string, exists bool) {
	v := m.application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplication returns the old "application" field's value of the AsRedeployData entity.
// If the AsRedeployData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRedeployDataMutation) OldApplication(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplication: %w", err)
	}
	return oldValue.Application, nil
}

// ClearApplication clears the value of the "application" field.
func (m *AsRedeployDataMutation) ClearApplication() {
	m.application = nil
	m.clearedFields[asredeploydata.FieldApplication] = struct{}{}
}

// ApplicationCleared returns if the "application" field was cleared in this mutation.
func (m *AsRedeployDataMutation) ApplicationCleared() bool {
	_, ok := m.clearedFields[asredeploydata.FieldApplication]
	return ok
}

// ResetApplication resets all changes to the "application" field.
func (m *AsRedeployDataMutation) ResetApplication() {
	m.application = nil
	delete(m.clearedFields, asredeploydata.FieldApplication)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsRedeployDataMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsRedeployDataMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsRedeployData entity.
// If the AsRedeployData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRedeployDataMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsRedeployDataMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsRedeployDataMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsRedeployDataMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsRedeployDataMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsRedeployDataMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsRedeployData entity.
// If the AsRedeployData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRedeployDataMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsRedeployDataMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsRedeployDataMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsRedeployDataMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asredeploydata.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsRedeployDataMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asredeploydata.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsRedeployDataMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asredeploydata.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsRedeployDataMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsRedeployDataMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsRedeployData entity.
// If the AsRedeployData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRedeployDataMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsRedeployDataMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsRedeployDataMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsRedeployDataMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asredeploydata.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsRedeployDataMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asredeploydata.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsRedeployDataMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asredeploydata.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsRedeployDataMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsRedeployDataMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsRedeployData entity.
// If the AsRedeployData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRedeployDataMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsRedeployDataMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsRedeployDataMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsRedeployDataMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asredeploydata.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsRedeployDataMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asredeploydata.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsRedeployDataMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asredeploydata.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsRedeployDataMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsRedeployDataMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsRedeployData entity.
// If the AsRedeployData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRedeployDataMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsRedeployDataMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asredeploydata.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsRedeployDataMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asredeploydata.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsRedeployDataMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asredeploydata.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsRedeployDataMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsRedeployDataMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsRedeployData entity.
// If the AsRedeployData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRedeployDataMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsRedeployDataMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asredeploydata.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsRedeployDataMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asredeploydata.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsRedeployDataMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asredeploydata.FieldUpdateTime)
}

// SetAppxID sets the "appx" edge to the AsMarketApp entity by id.
func (m *AsRedeployDataMutation) SetAppxID(id int64) {
	m.appx = &id
}

// ClearAppx clears the "appx" edge to the AsMarketApp entity.
func (m *AsRedeployDataMutation) ClearAppx() {
	m.clearedappx = true
}

// AppxCleared reports if the "appx" edge to the AsMarketApp entity was cleared.
func (m *AsRedeployDataMutation) AppxCleared() bool {
	return m.AppIDCleared() || m.clearedappx
}

// AppxID returns the "appx" edge ID in the mutation.
func (m *AsRedeployDataMutation) AppxID() (id int64, exists bool) {
	if m.appx != nil {
		return *m.appx, true
	}
	return
}

// AppxIDs returns the "appx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppxID instead. It exists only for internal usage by the builders.
func (m *AsRedeployDataMutation) AppxIDs() (ids []int64) {
	if id := m.appx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppx resets all changes to the "appx" edge.
func (m *AsRedeployDataMutation) ResetAppx() {
	m.appx = nil
	m.clearedappx = false
}

// Where appends a list predicates to the AsRedeployDataMutation builder.
func (m *AsRedeployDataMutation) Where(ps ...predicate.AsRedeployData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsRedeployDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsRedeployData).
func (m *AsRedeployDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsRedeployDataMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.appx != nil {
		fields = append(fields, asredeploydata.FieldAppID)
	}
	if m.application != nil {
		fields = append(fields, asredeploydata.FieldApplication)
	}
	if m.is_deleted != nil {
		fields = append(fields, asredeploydata.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asredeploydata.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asredeploydata.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asredeploydata.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asredeploydata.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asredeploydata.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsRedeployDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asredeploydata.FieldAppID:
		return m.AppID()
	case asredeploydata.FieldApplication:
		return m.Application()
	case asredeploydata.FieldIsDeleted:
		return m.IsDeleted()
	case asredeploydata.FieldStatus:
		return m.Status()
	case asredeploydata.FieldCreateUser:
		return m.CreateUser()
	case asredeploydata.FieldUpdateUser:
		return m.UpdateUser()
	case asredeploydata.FieldCreateTime:
		return m.CreateTime()
	case asredeploydata.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsRedeployDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asredeploydata.FieldAppID:
		return m.OldAppID(ctx)
	case asredeploydata.FieldApplication:
		return m.OldApplication(ctx)
	case asredeploydata.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asredeploydata.FieldStatus:
		return m.OldStatus(ctx)
	case asredeploydata.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asredeploydata.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asredeploydata.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asredeploydata.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsRedeployData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsRedeployDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asredeploydata.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asredeploydata.FieldApplication:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplication(v)
		return nil
	case asredeploydata.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asredeploydata.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asredeploydata.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asredeploydata.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asredeploydata.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asredeploydata.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsRedeployData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsRedeployDataMutation) AddedFields() []string {
	var fields []string
	if m.addis_deleted != nil {
		fields = append(fields, asredeploydata.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asredeploydata.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asredeploydata.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asredeploydata.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsRedeployDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asredeploydata.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asredeploydata.FieldStatus:
		return m.AddedStatus()
	case asredeploydata.FieldCreateUser:
		return m.AddedCreateUser()
	case asredeploydata.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsRedeployDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asredeploydata.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asredeploydata.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asredeploydata.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asredeploydata.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsRedeployData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsRedeployDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asredeploydata.FieldAppID) {
		fields = append(fields, asredeploydata.FieldAppID)
	}
	if m.FieldCleared(asredeploydata.FieldApplication) {
		fields = append(fields, asredeploydata.FieldApplication)
	}
	if m.FieldCleared(asredeploydata.FieldStatus) {
		fields = append(fields, asredeploydata.FieldStatus)
	}
	if m.FieldCleared(asredeploydata.FieldCreateUser) {
		fields = append(fields, asredeploydata.FieldCreateUser)
	}
	if m.FieldCleared(asredeploydata.FieldUpdateUser) {
		fields = append(fields, asredeploydata.FieldUpdateUser)
	}
	if m.FieldCleared(asredeploydata.FieldCreateTime) {
		fields = append(fields, asredeploydata.FieldCreateTime)
	}
	if m.FieldCleared(asredeploydata.FieldUpdateTime) {
		fields = append(fields, asredeploydata.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsRedeployDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsRedeployDataMutation) ClearField(name string) error {
	switch name {
	case asredeploydata.FieldAppID:
		m.ClearAppID()
		return nil
	case asredeploydata.FieldApplication:
		m.ClearApplication()
		return nil
	case asredeploydata.FieldStatus:
		m.ClearStatus()
		return nil
	case asredeploydata.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asredeploydata.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asredeploydata.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asredeploydata.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsRedeployData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsRedeployDataMutation) ResetField(name string) error {
	switch name {
	case asredeploydata.FieldAppID:
		m.ResetAppID()
		return nil
	case asredeploydata.FieldApplication:
		m.ResetApplication()
		return nil
	case asredeploydata.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asredeploydata.FieldStatus:
		m.ResetStatus()
		return nil
	case asredeploydata.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asredeploydata.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asredeploydata.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asredeploydata.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsRedeployData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsRedeployDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.appx != nil {
		edges = append(edges, asredeploydata.EdgeAppx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsRedeployDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asredeploydata.EdgeAppx:
		if id := m.appx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsRedeployDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsRedeployDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsRedeployDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedappx {
		edges = append(edges, asredeploydata.EdgeAppx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsRedeployDataMutation) EdgeCleared(name string) bool {
	switch name {
	case asredeploydata.EdgeAppx:
		return m.clearedappx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsRedeployDataMutation) ClearEdge(name string) error {
	switch name {
	case asredeploydata.EdgeAppx:
		m.ClearAppx()
		return nil
	}
	return fmt.Errorf("unknown AsRedeployData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsRedeployDataMutation) ResetEdge(name string) error {
	switch name {
	case asredeploydata.EdgeAppx:
		m.ResetAppx()
		return nil
	}
	return fmt.Errorf("unknown AsRedeployData edge %s", name)
}

// AsRoleMutation represents an operation that mutates the AsRole nodes in the graph.
type AsRoleMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	sort             *int64
	addsort          *int64
	role_alias       *string
	role_name        *string
	role_description *string
	is_deleted       *int64
	addis_deleted    *int64
	status           *int64
	addstatus        *int64
	create_user      *int64
	addcreate_user   *int64
	update_user      *int64
	addupdate_user   *int64
	create_time      *date.DateTime
	update_time      *date.DateTime
	clearedFields    map[string]struct{}
	users            map[int64]struct{}
	removedusers     map[int64]struct{}
	clearedusers     bool
	jobs             map[int64]struct{}
	removedjobs      map[int64]struct{}
	clearedjobs      bool
	menus            map[int64]struct{}
	removedmenus     map[int64]struct{}
	clearedmenus     bool
	attrRoles        map[int64]struct{}
	removedattrRoles map[int64]struct{}
	clearedattrRoles bool
	done             bool
	oldValue         func(context.Context) (*AsRole, error)
	predicates       []predicate.AsRole
}

var _ ent.Mutation = (*AsRoleMutation)(nil)

// asroleOption allows management of the mutation configuration using functional options.
type asroleOption func(*AsRoleMutation)

// newAsRoleMutation creates new mutation for the AsRole entity.
func newAsRoleMutation(c config, op Op, opts ...asroleOption) *AsRoleMutation {
	m := &AsRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAsRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsRoleID sets the ID field of the mutation.
func withAsRoleID(id int64) asroleOption {
	return func(m *AsRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AsRole
		)
		m.oldValue = func(ctx context.Context) (*AsRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsRole sets the old AsRole of the mutation.
func withAsRole(node *AsRole) asroleOption {
	return func(m *AsRoleMutation) {
		m.oldValue = func(context.Context) (*AsRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsRole entities.
func (m *AsRoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsRoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsRoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSort sets the "sort" field.
func (m *AsRoleMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AsRoleMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the AsRole entity.
// If the AsRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRoleMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AsRoleMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AsRoleMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *AsRoleMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetRoleAlias sets the "role_alias" field.
func (m *AsRoleMutation) SetRoleAlias(s string) {
	m.role_alias = &s
}

// RoleAlias returns the value of the "role_alias" field in the mutation.
func (m *AsRoleMutation) RoleAlias() (r string, exists bool) {
	v := m.role_alias
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleAlias returns the old "role_alias" field's value of the AsRole entity.
// If the AsRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRoleMutation) OldRoleAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleAlias: %w", err)
	}
	return oldValue.RoleAlias, nil
}

// ClearRoleAlias clears the value of the "role_alias" field.
func (m *AsRoleMutation) ClearRoleAlias() {
	m.role_alias = nil
	m.clearedFields[asrole.FieldRoleAlias] = struct{}{}
}

// RoleAliasCleared returns if the "role_alias" field was cleared in this mutation.
func (m *AsRoleMutation) RoleAliasCleared() bool {
	_, ok := m.clearedFields[asrole.FieldRoleAlias]
	return ok
}

// ResetRoleAlias resets all changes to the "role_alias" field.
func (m *AsRoleMutation) ResetRoleAlias() {
	m.role_alias = nil
	delete(m.clearedFields, asrole.FieldRoleAlias)
}

// SetRoleName sets the "role_name" field.
func (m *AsRoleMutation) SetRoleName(s string) {
	m.role_name = &s
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *AsRoleMutation) RoleName() (r string, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the AsRole entity.
// If the AsRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRoleMutation) OldRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ClearRoleName clears the value of the "role_name" field.
func (m *AsRoleMutation) ClearRoleName() {
	m.role_name = nil
	m.clearedFields[asrole.FieldRoleName] = struct{}{}
}

// RoleNameCleared returns if the "role_name" field was cleared in this mutation.
func (m *AsRoleMutation) RoleNameCleared() bool {
	_, ok := m.clearedFields[asrole.FieldRoleName]
	return ok
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *AsRoleMutation) ResetRoleName() {
	m.role_name = nil
	delete(m.clearedFields, asrole.FieldRoleName)
}

// SetRoleDescription sets the "role_description" field.
func (m *AsRoleMutation) SetRoleDescription(s string) {
	m.role_description = &s
}

// RoleDescription returns the value of the "role_description" field in the mutation.
func (m *AsRoleMutation) RoleDescription() (r string, exists bool) {
	v := m.role_description
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleDescription returns the old "role_description" field's value of the AsRole entity.
// If the AsRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRoleMutation) OldRoleDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleDescription: %w", err)
	}
	return oldValue.RoleDescription, nil
}

// ClearRoleDescription clears the value of the "role_description" field.
func (m *AsRoleMutation) ClearRoleDescription() {
	m.role_description = nil
	m.clearedFields[asrole.FieldRoleDescription] = struct{}{}
}

// RoleDescriptionCleared returns if the "role_description" field was cleared in this mutation.
func (m *AsRoleMutation) RoleDescriptionCleared() bool {
	_, ok := m.clearedFields[asrole.FieldRoleDescription]
	return ok
}

// ResetRoleDescription resets all changes to the "role_description" field.
func (m *AsRoleMutation) ResetRoleDescription() {
	m.role_description = nil
	delete(m.clearedFields, asrole.FieldRoleDescription)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsRoleMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsRoleMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsRole entity.
// If the AsRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRoleMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsRoleMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsRoleMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsRoleMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsRoleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsRoleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsRole entity.
// If the AsRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRoleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsRoleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsRoleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsRoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asrole.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsRoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asrole.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsRoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asrole.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsRoleMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsRoleMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsRole entity.
// If the AsRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRoleMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsRoleMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsRoleMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsRoleMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asrole.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsRoleMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asrole.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsRoleMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asrole.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsRoleMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsRoleMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsRole entity.
// If the AsRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRoleMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsRoleMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsRoleMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsRoleMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asrole.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsRoleMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asrole.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsRoleMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asrole.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsRoleMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsRoleMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsRole entity.
// If the AsRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRoleMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsRoleMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asrole.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsRoleMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asrole.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsRoleMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asrole.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsRoleMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsRoleMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsRole entity.
// If the AsRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsRoleMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsRoleMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asrole.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsRoleMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asrole.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsRoleMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asrole.FieldUpdateTime)
}

// AddUserIDs adds the "users" edge to the AsUser entity by ids.
func (m *AsRoleMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the AsUser entity.
func (m *AsRoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the AsUser entity was cleared.
func (m *AsRoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the AsUser entity by IDs.
func (m *AsRoleMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the AsUser entity.
func (m *AsRoleMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *AsRoleMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AsRoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddJobIDs adds the "jobs" edge to the AsJob entity by ids.
func (m *AsRoleMutation) AddJobIDs(ids ...int64) {
	if m.jobs == nil {
		m.jobs = make(map[int64]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the AsJob entity.
func (m *AsRoleMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the AsJob entity was cleared.
func (m *AsRoleMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the AsJob entity by IDs.
func (m *AsRoleMutation) RemoveJobIDs(ids ...int64) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the AsJob entity.
func (m *AsRoleMutation) RemovedJobsIDs() (ids []int64) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *AsRoleMutation) JobsIDs() (ids []int64) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *AsRoleMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// AddMenuIDs adds the "menus" edge to the AsMenu entity by ids.
func (m *AsRoleMutation) AddMenuIDs(ids ...int64) {
	if m.menus == nil {
		m.menus = make(map[int64]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the AsMenu entity.
func (m *AsRoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the AsMenu entity was cleared.
func (m *AsRoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the AsMenu entity by IDs.
func (m *AsRoleMutation) RemoveMenuIDs(ids ...int64) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the AsMenu entity.
func (m *AsRoleMutation) RemovedMenusIDs() (ids []int64) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *AsRoleMutation) MenusIDs() (ids []int64) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *AsRoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddAttrRoleIDs adds the "attrRoles" edge to the AsTenantAttrRole entity by ids.
func (m *AsRoleMutation) AddAttrRoleIDs(ids ...int64) {
	if m.attrRoles == nil {
		m.attrRoles = make(map[int64]struct{})
	}
	for i := range ids {
		m.attrRoles[ids[i]] = struct{}{}
	}
}

// ClearAttrRoles clears the "attrRoles" edge to the AsTenantAttrRole entity.
func (m *AsRoleMutation) ClearAttrRoles() {
	m.clearedattrRoles = true
}

// AttrRolesCleared reports if the "attrRoles" edge to the AsTenantAttrRole entity was cleared.
func (m *AsRoleMutation) AttrRolesCleared() bool {
	return m.clearedattrRoles
}

// RemoveAttrRoleIDs removes the "attrRoles" edge to the AsTenantAttrRole entity by IDs.
func (m *AsRoleMutation) RemoveAttrRoleIDs(ids ...int64) {
	if m.removedattrRoles == nil {
		m.removedattrRoles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.attrRoles, ids[i])
		m.removedattrRoles[ids[i]] = struct{}{}
	}
}

// RemovedAttrRoles returns the removed IDs of the "attrRoles" edge to the AsTenantAttrRole entity.
func (m *AsRoleMutation) RemovedAttrRolesIDs() (ids []int64) {
	for id := range m.removedattrRoles {
		ids = append(ids, id)
	}
	return
}

// AttrRolesIDs returns the "attrRoles" edge IDs in the mutation.
func (m *AsRoleMutation) AttrRolesIDs() (ids []int64) {
	for id := range m.attrRoles {
		ids = append(ids, id)
	}
	return
}

// ResetAttrRoles resets all changes to the "attrRoles" edge.
func (m *AsRoleMutation) ResetAttrRoles() {
	m.attrRoles = nil
	m.clearedattrRoles = false
	m.removedattrRoles = nil
}

// Where appends a list predicates to the AsRoleMutation builder.
func (m *AsRoleMutation) Where(ps ...predicate.AsRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsRole).
func (m *AsRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsRoleMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.sort != nil {
		fields = append(fields, asrole.FieldSort)
	}
	if m.role_alias != nil {
		fields = append(fields, asrole.FieldRoleAlias)
	}
	if m.role_name != nil {
		fields = append(fields, asrole.FieldRoleName)
	}
	if m.role_description != nil {
		fields = append(fields, asrole.FieldRoleDescription)
	}
	if m.is_deleted != nil {
		fields = append(fields, asrole.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asrole.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asrole.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asrole.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asrole.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asrole.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asrole.FieldSort:
		return m.Sort()
	case asrole.FieldRoleAlias:
		return m.RoleAlias()
	case asrole.FieldRoleName:
		return m.RoleName()
	case asrole.FieldRoleDescription:
		return m.RoleDescription()
	case asrole.FieldIsDeleted:
		return m.IsDeleted()
	case asrole.FieldStatus:
		return m.Status()
	case asrole.FieldCreateUser:
		return m.CreateUser()
	case asrole.FieldUpdateUser:
		return m.UpdateUser()
	case asrole.FieldCreateTime:
		return m.CreateTime()
	case asrole.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asrole.FieldSort:
		return m.OldSort(ctx)
	case asrole.FieldRoleAlias:
		return m.OldRoleAlias(ctx)
	case asrole.FieldRoleName:
		return m.OldRoleName(ctx)
	case asrole.FieldRoleDescription:
		return m.OldRoleDescription(ctx)
	case asrole.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asrole.FieldStatus:
		return m.OldStatus(ctx)
	case asrole.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asrole.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asrole.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asrole.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asrole.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case asrole.FieldRoleAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleAlias(v)
		return nil
	case asrole.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case asrole.FieldRoleDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleDescription(v)
		return nil
	case asrole.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asrole.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asrole.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asrole.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asrole.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asrole.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsRoleMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, asrole.FieldSort)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asrole.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asrole.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asrole.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asrole.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asrole.FieldSort:
		return m.AddedSort()
	case asrole.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asrole.FieldStatus:
		return m.AddedStatus()
	case asrole.FieldCreateUser:
		return m.AddedCreateUser()
	case asrole.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asrole.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case asrole.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asrole.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asrole.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asrole.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asrole.FieldRoleAlias) {
		fields = append(fields, asrole.FieldRoleAlias)
	}
	if m.FieldCleared(asrole.FieldRoleName) {
		fields = append(fields, asrole.FieldRoleName)
	}
	if m.FieldCleared(asrole.FieldRoleDescription) {
		fields = append(fields, asrole.FieldRoleDescription)
	}
	if m.FieldCleared(asrole.FieldStatus) {
		fields = append(fields, asrole.FieldStatus)
	}
	if m.FieldCleared(asrole.FieldCreateUser) {
		fields = append(fields, asrole.FieldCreateUser)
	}
	if m.FieldCleared(asrole.FieldUpdateUser) {
		fields = append(fields, asrole.FieldUpdateUser)
	}
	if m.FieldCleared(asrole.FieldCreateTime) {
		fields = append(fields, asrole.FieldCreateTime)
	}
	if m.FieldCleared(asrole.FieldUpdateTime) {
		fields = append(fields, asrole.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsRoleMutation) ClearField(name string) error {
	switch name {
	case asrole.FieldRoleAlias:
		m.ClearRoleAlias()
		return nil
	case asrole.FieldRoleName:
		m.ClearRoleName()
		return nil
	case asrole.FieldRoleDescription:
		m.ClearRoleDescription()
		return nil
	case asrole.FieldStatus:
		m.ClearStatus()
		return nil
	case asrole.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asrole.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asrole.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asrole.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsRoleMutation) ResetField(name string) error {
	switch name {
	case asrole.FieldSort:
		m.ResetSort()
		return nil
	case asrole.FieldRoleAlias:
		m.ResetRoleAlias()
		return nil
	case asrole.FieldRoleName:
		m.ResetRoleName()
		return nil
	case asrole.FieldRoleDescription:
		m.ResetRoleDescription()
		return nil
	case asrole.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asrole.FieldStatus:
		m.ResetStatus()
		return nil
	case asrole.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asrole.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asrole.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asrole.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.users != nil {
		edges = append(edges, asrole.EdgeUsers)
	}
	if m.jobs != nil {
		edges = append(edges, asrole.EdgeJobs)
	}
	if m.menus != nil {
		edges = append(edges, asrole.EdgeMenus)
	}
	if m.attrRoles != nil {
		edges = append(edges, asrole.EdgeAttrRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asrole.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case asrole.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case asrole.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case asrole.EdgeAttrRoles:
		ids := make([]ent.Value, 0, len(m.attrRoles))
		for id := range m.attrRoles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedusers != nil {
		edges = append(edges, asrole.EdgeUsers)
	}
	if m.removedjobs != nil {
		edges = append(edges, asrole.EdgeJobs)
	}
	if m.removedmenus != nil {
		edges = append(edges, asrole.EdgeMenus)
	}
	if m.removedattrRoles != nil {
		edges = append(edges, asrole.EdgeAttrRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asrole.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case asrole.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	case asrole.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case asrole.EdgeAttrRoles:
		ids := make([]ent.Value, 0, len(m.removedattrRoles))
		for id := range m.removedattrRoles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedusers {
		edges = append(edges, asrole.EdgeUsers)
	}
	if m.clearedjobs {
		edges = append(edges, asrole.EdgeJobs)
	}
	if m.clearedmenus {
		edges = append(edges, asrole.EdgeMenus)
	}
	if m.clearedattrRoles {
		edges = append(edges, asrole.EdgeAttrRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case asrole.EdgeUsers:
		return m.clearedusers
	case asrole.EdgeJobs:
		return m.clearedjobs
	case asrole.EdgeMenus:
		return m.clearedmenus
	case asrole.EdgeAttrRoles:
		return m.clearedattrRoles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsRoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AsRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsRoleMutation) ResetEdge(name string) error {
	switch name {
	case asrole.EdgeUsers:
		m.ResetUsers()
		return nil
	case asrole.EdgeJobs:
		m.ResetJobs()
		return nil
	case asrole.EdgeMenus:
		m.ResetMenus()
		return nil
	case asrole.EdgeAttrRoles:
		m.ResetAttrRoles()
		return nil
	}
	return fmt.Errorf("unknown AsRole edge %s", name)
}

// AsTenantMutation represents an operation that mutates the AsTenant nodes in the graph.
type AsTenantMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	tenant_type          *int64
	addtenant_type       *int64
	tenant_name          *string
	tenant_code          *string
	theme                *string
	is_virtual           *int64
	addis_virtual        *int64
	is_deleted           *int64
	addis_deleted        *int64
	status               *int64
	addstatus            *int64
	create_user          *int64
	addcreate_user       *int64
	update_user          *int64
	addupdate_user       *int64
	create_time          *date.DateTime
	update_time          *date.DateTime
	clearedFields        map[string]struct{}
	unit                 *int64
	clearedunit          bool
	allGroups            map[int64]struct{}
	removedallGroups     map[int64]struct{}
	clearedallGroups     bool
	allproperties        map[int64]struct{}
	removedallproperties map[int64]struct{}
	clearedallproperties bool
	done                 bool
	oldValue             func(context.Context) (*AsTenant, error)
	predicates           []predicate.AsTenant
}

var _ ent.Mutation = (*AsTenantMutation)(nil)

// astenantOption allows management of the mutation configuration using functional options.
type astenantOption func(*AsTenantMutation)

// newAsTenantMutation creates new mutation for the AsTenant entity.
func newAsTenantMutation(c config, op Op, opts ...astenantOption) *AsTenantMutation {
	m := &AsTenantMutation{
		config:        c,
		op:            op,
		typ:           TypeAsTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsTenantID sets the ID field of the mutation.
func withAsTenantID(id int64) astenantOption {
	return func(m *AsTenantMutation) {
		var (
			err   error
			once  sync.Once
			value *AsTenant
		)
		m.oldValue = func(ctx context.Context) (*AsTenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsTenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsTenant sets the old AsTenant of the mutation.
func withAsTenant(node *AsTenant) astenantOption {
	return func(m *AsTenantMutation) {
		m.oldValue = func(context.Context) (*AsTenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsTenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsTenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsTenant entities.
func (m *AsTenantMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsTenantMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsTenantMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsTenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantType sets the "tenant_type" field.
func (m *AsTenantMutation) SetTenantType(i int64) {
	m.tenant_type = &i
	m.addtenant_type = nil
}

// TenantType returns the value of the "tenant_type" field in the mutation.
func (m *AsTenantMutation) TenantType() (r int64, exists bool) {
	v := m.tenant_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantType returns the old "tenant_type" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldTenantType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantType: %w", err)
	}
	return oldValue.TenantType, nil
}

// AddTenantType adds i to the "tenant_type" field.
func (m *AsTenantMutation) AddTenantType(i int64) {
	if m.addtenant_type != nil {
		*m.addtenant_type += i
	} else {
		m.addtenant_type = &i
	}
}

// AddedTenantType returns the value that was added to the "tenant_type" field in this mutation.
func (m *AsTenantMutation) AddedTenantType() (r int64, exists bool) {
	v := m.addtenant_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantType resets all changes to the "tenant_type" field.
func (m *AsTenantMutation) ResetTenantType() {
	m.tenant_type = nil
	m.addtenant_type = nil
}

// SetTenantName sets the "tenant_name" field.
func (m *AsTenantMutation) SetTenantName(s string) {
	m.tenant_name = &s
}

// TenantName returns the value of the "tenant_name" field in the mutation.
func (m *AsTenantMutation) TenantName() (r string, exists bool) {
	v := m.tenant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old "tenant_name" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName resets all changes to the "tenant_name" field.
func (m *AsTenantMutation) ResetTenantName() {
	m.tenant_name = nil
}

// SetTenantCode sets the "tenant_code" field.
func (m *AsTenantMutation) SetTenantCode(s string) {
	m.tenant_code = &s
}

// TenantCode returns the value of the "tenant_code" field in the mutation.
func (m *AsTenantMutation) TenantCode() (r string, exists bool) {
	v := m.tenant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantCode returns the old "tenant_code" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldTenantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantCode: %w", err)
	}
	return oldValue.TenantCode, nil
}

// ResetTenantCode resets all changes to the "tenant_code" field.
func (m *AsTenantMutation) ResetTenantCode() {
	m.tenant_code = nil
}

// SetTheme sets the "theme" field.
func (m *AsTenantMutation) SetTheme(s string) {
	m.theme = &s
}

// Theme returns the value of the "theme" field in the mutation.
func (m *AsTenantMutation) Theme() (r string, exists bool) {
	v := m.theme
	if v == nil {
		return
	}
	return *v, true
}

// OldTheme returns the old "theme" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldTheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTheme: %w", err)
	}
	return oldValue.Theme, nil
}

// ClearTheme clears the value of the "theme" field.
func (m *AsTenantMutation) ClearTheme() {
	m.theme = nil
	m.clearedFields[astenant.FieldTheme] = struct{}{}
}

// ThemeCleared returns if the "theme" field was cleared in this mutation.
func (m *AsTenantMutation) ThemeCleared() bool {
	_, ok := m.clearedFields[astenant.FieldTheme]
	return ok
}

// ResetTheme resets all changes to the "theme" field.
func (m *AsTenantMutation) ResetTheme() {
	m.theme = nil
	delete(m.clearedFields, astenant.FieldTheme)
}

// SetIsVirtual sets the "is_virtual" field.
func (m *AsTenantMutation) SetIsVirtual(i int64) {
	m.is_virtual = &i
	m.addis_virtual = nil
}

// IsVirtual returns the value of the "is_virtual" field in the mutation.
func (m *AsTenantMutation) IsVirtual() (r int64, exists bool) {
	v := m.is_virtual
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVirtual returns the old "is_virtual" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldIsVirtual(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVirtual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVirtual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVirtual: %w", err)
	}
	return oldValue.IsVirtual, nil
}

// AddIsVirtual adds i to the "is_virtual" field.
func (m *AsTenantMutation) AddIsVirtual(i int64) {
	if m.addis_virtual != nil {
		*m.addis_virtual += i
	} else {
		m.addis_virtual = &i
	}
}

// AddedIsVirtual returns the value that was added to the "is_virtual" field in this mutation.
func (m *AsTenantMutation) AddedIsVirtual() (r int64, exists bool) {
	v := m.addis_virtual
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsVirtual resets all changes to the "is_virtual" field.
func (m *AsTenantMutation) ResetIsVirtual() {
	m.is_virtual = nil
	m.addis_virtual = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsTenantMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsTenantMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsTenantMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsTenantMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsTenantMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsTenantMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsTenantMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsTenantMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsTenantMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsTenantMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[astenant.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsTenantMutation) StatusCleared() bool {
	_, ok := m.clearedFields[astenant.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsTenantMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, astenant.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsTenantMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsTenantMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsTenantMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsTenantMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsTenantMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[astenant.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsTenantMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[astenant.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsTenantMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, astenant.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsTenantMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsTenantMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsTenantMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsTenantMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsTenantMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[astenant.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsTenantMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[astenant.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsTenantMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, astenant.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsTenantMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsTenantMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsTenantMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[astenant.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsTenantMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[astenant.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsTenantMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, astenant.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsTenantMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsTenantMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsTenant entity.
// If the AsTenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsTenantMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[astenant.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsTenantMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[astenant.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsTenantMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, astenant.FieldUpdateTime)
}

// SetUnitID sets the "unit" edge to the AsUnit entity by id.
func (m *AsTenantMutation) SetUnitID(id int64) {
	m.unit = &id
}

// ClearUnit clears the "unit" edge to the AsUnit entity.
func (m *AsTenantMutation) ClearUnit() {
	m.clearedunit = true
}

// UnitCleared reports if the "unit" edge to the AsUnit entity was cleared.
func (m *AsTenantMutation) UnitCleared() bool {
	return m.clearedunit
}

// UnitID returns the "unit" edge ID in the mutation.
func (m *AsTenantMutation) UnitID() (id int64, exists bool) {
	if m.unit != nil {
		return *m.unit, true
	}
	return
}

// UnitIDs returns the "unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UnitID instead. It exists only for internal usage by the builders.
func (m *AsTenantMutation) UnitIDs() (ids []int64) {
	if id := m.unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnit resets all changes to the "unit" edge.
func (m *AsTenantMutation) ResetUnit() {
	m.unit = nil
	m.clearedunit = false
}

// AddAllGroupIDs adds the "allGroups" edge to the AsGroupTenantRelations entity by ids.
func (m *AsTenantMutation) AddAllGroupIDs(ids ...int64) {
	if m.allGroups == nil {
		m.allGroups = make(map[int64]struct{})
	}
	for i := range ids {
		m.allGroups[ids[i]] = struct{}{}
	}
}

// ClearAllGroups clears the "allGroups" edge to the AsGroupTenantRelations entity.
func (m *AsTenantMutation) ClearAllGroups() {
	m.clearedallGroups = true
}

// AllGroupsCleared reports if the "allGroups" edge to the AsGroupTenantRelations entity was cleared.
func (m *AsTenantMutation) AllGroupsCleared() bool {
	return m.clearedallGroups
}

// RemoveAllGroupIDs removes the "allGroups" edge to the AsGroupTenantRelations entity by IDs.
func (m *AsTenantMutation) RemoveAllGroupIDs(ids ...int64) {
	if m.removedallGroups == nil {
		m.removedallGroups = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allGroups, ids[i])
		m.removedallGroups[ids[i]] = struct{}{}
	}
}

// RemovedAllGroups returns the removed IDs of the "allGroups" edge to the AsGroupTenantRelations entity.
func (m *AsTenantMutation) RemovedAllGroupsIDs() (ids []int64) {
	for id := range m.removedallGroups {
		ids = append(ids, id)
	}
	return
}

// AllGroupsIDs returns the "allGroups" edge IDs in the mutation.
func (m *AsTenantMutation) AllGroupsIDs() (ids []int64) {
	for id := range m.allGroups {
		ids = append(ids, id)
	}
	return
}

// ResetAllGroups resets all changes to the "allGroups" edge.
func (m *AsTenantMutation) ResetAllGroups() {
	m.allGroups = nil
	m.clearedallGroups = false
	m.removedallGroups = nil
}

// AddAllpropertyIDs adds the "allproperties" edge to the AsPropertiesDistribution entity by ids.
func (m *AsTenantMutation) AddAllpropertyIDs(ids ...int64) {
	if m.allproperties == nil {
		m.allproperties = make(map[int64]struct{})
	}
	for i := range ids {
		m.allproperties[ids[i]] = struct{}{}
	}
}

// ClearAllproperties clears the "allproperties" edge to the AsPropertiesDistribution entity.
func (m *AsTenantMutation) ClearAllproperties() {
	m.clearedallproperties = true
}

// AllpropertiesCleared reports if the "allproperties" edge to the AsPropertiesDistribution entity was cleared.
func (m *AsTenantMutation) AllpropertiesCleared() bool {
	return m.clearedallproperties
}

// RemoveAllpropertyIDs removes the "allproperties" edge to the AsPropertiesDistribution entity by IDs.
func (m *AsTenantMutation) RemoveAllpropertyIDs(ids ...int64) {
	if m.removedallproperties == nil {
		m.removedallproperties = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allproperties, ids[i])
		m.removedallproperties[ids[i]] = struct{}{}
	}
}

// RemovedAllproperties returns the removed IDs of the "allproperties" edge to the AsPropertiesDistribution entity.
func (m *AsTenantMutation) RemovedAllpropertiesIDs() (ids []int64) {
	for id := range m.removedallproperties {
		ids = append(ids, id)
	}
	return
}

// AllpropertiesIDs returns the "allproperties" edge IDs in the mutation.
func (m *AsTenantMutation) AllpropertiesIDs() (ids []int64) {
	for id := range m.allproperties {
		ids = append(ids, id)
	}
	return
}

// ResetAllproperties resets all changes to the "allproperties" edge.
func (m *AsTenantMutation) ResetAllproperties() {
	m.allproperties = nil
	m.clearedallproperties = false
	m.removedallproperties = nil
}

// Where appends a list predicates to the AsTenantMutation builder.
func (m *AsTenantMutation) Where(ps ...predicate.AsTenant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsTenantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsTenant).
func (m *AsTenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsTenantMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.tenant_type != nil {
		fields = append(fields, astenant.FieldTenantType)
	}
	if m.tenant_name != nil {
		fields = append(fields, astenant.FieldTenantName)
	}
	if m.tenant_code != nil {
		fields = append(fields, astenant.FieldTenantCode)
	}
	if m.theme != nil {
		fields = append(fields, astenant.FieldTheme)
	}
	if m.is_virtual != nil {
		fields = append(fields, astenant.FieldIsVirtual)
	}
	if m.is_deleted != nil {
		fields = append(fields, astenant.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, astenant.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, astenant.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, astenant.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, astenant.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, astenant.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsTenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case astenant.FieldTenantType:
		return m.TenantType()
	case astenant.FieldTenantName:
		return m.TenantName()
	case astenant.FieldTenantCode:
		return m.TenantCode()
	case astenant.FieldTheme:
		return m.Theme()
	case astenant.FieldIsVirtual:
		return m.IsVirtual()
	case astenant.FieldIsDeleted:
		return m.IsDeleted()
	case astenant.FieldStatus:
		return m.Status()
	case astenant.FieldCreateUser:
		return m.CreateUser()
	case astenant.FieldUpdateUser:
		return m.UpdateUser()
	case astenant.FieldCreateTime:
		return m.CreateTime()
	case astenant.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsTenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case astenant.FieldTenantType:
		return m.OldTenantType(ctx)
	case astenant.FieldTenantName:
		return m.OldTenantName(ctx)
	case astenant.FieldTenantCode:
		return m.OldTenantCode(ctx)
	case astenant.FieldTheme:
		return m.OldTheme(ctx)
	case astenant.FieldIsVirtual:
		return m.OldIsVirtual(ctx)
	case astenant.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case astenant.FieldStatus:
		return m.OldStatus(ctx)
	case astenant.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case astenant.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case astenant.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case astenant.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsTenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsTenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case astenant.FieldTenantType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantType(v)
		return nil
	case astenant.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case astenant.FieldTenantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantCode(v)
		return nil
	case astenant.FieldTheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTheme(v)
		return nil
	case astenant.FieldIsVirtual:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVirtual(v)
		return nil
	case astenant.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case astenant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case astenant.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case astenant.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case astenant.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case astenant.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsTenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsTenantMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_type != nil {
		fields = append(fields, astenant.FieldTenantType)
	}
	if m.addis_virtual != nil {
		fields = append(fields, astenant.FieldIsVirtual)
	}
	if m.addis_deleted != nil {
		fields = append(fields, astenant.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, astenant.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, astenant.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, astenant.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsTenantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case astenant.FieldTenantType:
		return m.AddedTenantType()
	case astenant.FieldIsVirtual:
		return m.AddedIsVirtual()
	case astenant.FieldIsDeleted:
		return m.AddedIsDeleted()
	case astenant.FieldStatus:
		return m.AddedStatus()
	case astenant.FieldCreateUser:
		return m.AddedCreateUser()
	case astenant.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsTenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case astenant.FieldTenantType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantType(v)
		return nil
	case astenant.FieldIsVirtual:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsVirtual(v)
		return nil
	case astenant.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case astenant.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case astenant.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case astenant.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsTenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsTenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(astenant.FieldTheme) {
		fields = append(fields, astenant.FieldTheme)
	}
	if m.FieldCleared(astenant.FieldStatus) {
		fields = append(fields, astenant.FieldStatus)
	}
	if m.FieldCleared(astenant.FieldCreateUser) {
		fields = append(fields, astenant.FieldCreateUser)
	}
	if m.FieldCleared(astenant.FieldUpdateUser) {
		fields = append(fields, astenant.FieldUpdateUser)
	}
	if m.FieldCleared(astenant.FieldCreateTime) {
		fields = append(fields, astenant.FieldCreateTime)
	}
	if m.FieldCleared(astenant.FieldUpdateTime) {
		fields = append(fields, astenant.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsTenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsTenantMutation) ClearField(name string) error {
	switch name {
	case astenant.FieldTheme:
		m.ClearTheme()
		return nil
	case astenant.FieldStatus:
		m.ClearStatus()
		return nil
	case astenant.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case astenant.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case astenant.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case astenant.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsTenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsTenantMutation) ResetField(name string) error {
	switch name {
	case astenant.FieldTenantType:
		m.ResetTenantType()
		return nil
	case astenant.FieldTenantName:
		m.ResetTenantName()
		return nil
	case astenant.FieldTenantCode:
		m.ResetTenantCode()
		return nil
	case astenant.FieldTheme:
		m.ResetTheme()
		return nil
	case astenant.FieldIsVirtual:
		m.ResetIsVirtual()
		return nil
	case astenant.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case astenant.FieldStatus:
		m.ResetStatus()
		return nil
	case astenant.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case astenant.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case astenant.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case astenant.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsTenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsTenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.unit != nil {
		edges = append(edges, astenant.EdgeUnit)
	}
	if m.allGroups != nil {
		edges = append(edges, astenant.EdgeAllGroups)
	}
	if m.allproperties != nil {
		edges = append(edges, astenant.EdgeAllproperties)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsTenantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case astenant.EdgeUnit:
		if id := m.unit; id != nil {
			return []ent.Value{*id}
		}
	case astenant.EdgeAllGroups:
		ids := make([]ent.Value, 0, len(m.allGroups))
		for id := range m.allGroups {
			ids = append(ids, id)
		}
		return ids
	case astenant.EdgeAllproperties:
		ids := make([]ent.Value, 0, len(m.allproperties))
		for id := range m.allproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsTenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedallGroups != nil {
		edges = append(edges, astenant.EdgeAllGroups)
	}
	if m.removedallproperties != nil {
		edges = append(edges, astenant.EdgeAllproperties)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsTenantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case astenant.EdgeAllGroups:
		ids := make([]ent.Value, 0, len(m.removedallGroups))
		for id := range m.removedallGroups {
			ids = append(ids, id)
		}
		return ids
	case astenant.EdgeAllproperties:
		ids := make([]ent.Value, 0, len(m.removedallproperties))
		for id := range m.removedallproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsTenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedunit {
		edges = append(edges, astenant.EdgeUnit)
	}
	if m.clearedallGroups {
		edges = append(edges, astenant.EdgeAllGroups)
	}
	if m.clearedallproperties {
		edges = append(edges, astenant.EdgeAllproperties)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsTenantMutation) EdgeCleared(name string) bool {
	switch name {
	case astenant.EdgeUnit:
		return m.clearedunit
	case astenant.EdgeAllGroups:
		return m.clearedallGroups
	case astenant.EdgeAllproperties:
		return m.clearedallproperties
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsTenantMutation) ClearEdge(name string) error {
	switch name {
	case astenant.EdgeUnit:
		m.ClearUnit()
		return nil
	}
	return fmt.Errorf("unknown AsTenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsTenantMutation) ResetEdge(name string) error {
	switch name {
	case astenant.EdgeUnit:
		m.ResetUnit()
		return nil
	case astenant.EdgeAllGroups:
		m.ResetAllGroups()
		return nil
	case astenant.EdgeAllproperties:
		m.ResetAllproperties()
		return nil
	}
	return fmt.Errorf("unknown AsTenant edge %s", name)
}

// AsTenantAttrMutation represents an operation that mutates the AsTenantAttr nodes in the graph.
type AsTenantAttrMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	attr_name        *string
	attr_remark      *string
	is_deleted       *int64
	addis_deleted    *int64
	status           *int64
	addstatus        *int64
	create_user      *int64
	addcreate_user   *int64
	update_user      *int64
	addupdate_user   *int64
	create_time      *date.DateTime
	update_time      *date.DateTime
	clearedFields    map[string]struct{}
	parentx          *int64
	clearedparentx   bool
	childrens        map[int64]struct{}
	removedchildrens map[int64]struct{}
	clearedchildrens bool
	attrRoles        map[int64]struct{}
	removedattrRoles map[int64]struct{}
	clearedattrRoles bool
	done             bool
	oldValue         func(context.Context) (*AsTenantAttr, error)
	predicates       []predicate.AsTenantAttr
}

var _ ent.Mutation = (*AsTenantAttrMutation)(nil)

// astenantattrOption allows management of the mutation configuration using functional options.
type astenantattrOption func(*AsTenantAttrMutation)

// newAsTenantAttrMutation creates new mutation for the AsTenantAttr entity.
func newAsTenantAttrMutation(c config, op Op, opts ...astenantattrOption) *AsTenantAttrMutation {
	m := &AsTenantAttrMutation{
		config:        c,
		op:            op,
		typ:           TypeAsTenantAttr,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsTenantAttrID sets the ID field of the mutation.
func withAsTenantAttrID(id int64) astenantattrOption {
	return func(m *AsTenantAttrMutation) {
		var (
			err   error
			once  sync.Once
			value *AsTenantAttr
		)
		m.oldValue = func(ctx context.Context) (*AsTenantAttr, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsTenantAttr.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsTenantAttr sets the old AsTenantAttr of the mutation.
func withAsTenantAttr(node *AsTenantAttr) astenantattrOption {
	return func(m *AsTenantAttrMutation) {
		m.oldValue = func(context.Context) (*AsTenantAttr, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsTenantAttrMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsTenantAttrMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsTenantAttr entities.
func (m *AsTenantAttrMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsTenantAttrMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsTenantAttrMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsTenantAttr.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetParentID sets the "parent_id" field.
func (m *AsTenantAttrMutation) SetParentID(i int64) {
	m.parentx = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *AsTenantAttrMutation) ParentID() (r int64, exists bool) {
	v := m.parentx
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the AsTenantAttr entity.
// If the AsTenantAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *AsTenantAttrMutation) ClearParentID() {
	m.parentx = nil
	m.clearedFields[astenantattr.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *AsTenantAttrMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[astenantattr.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *AsTenantAttrMutation) ResetParentID() {
	m.parentx = nil
	delete(m.clearedFields, astenantattr.FieldParentID)
}

// SetAttrName sets the "attr_name" field.
func (m *AsTenantAttrMutation) SetAttrName(s string) {
	m.attr_name = &s
}

// AttrName returns the value of the "attr_name" field in the mutation.
func (m *AsTenantAttrMutation) AttrName() (r string, exists bool) {
	v := m.attr_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrName returns the old "attr_name" field's value of the AsTenantAttr entity.
// If the AsTenantAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrMutation) OldAttrName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttrName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttrName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrName: %w", err)
	}
	return oldValue.AttrName, nil
}

// ResetAttrName resets all changes to the "attr_name" field.
func (m *AsTenantAttrMutation) ResetAttrName() {
	m.attr_name = nil
}

// SetAttrRemark sets the "attr_remark" field.
func (m *AsTenantAttrMutation) SetAttrRemark(s string) {
	m.attr_remark = &s
}

// AttrRemark returns the value of the "attr_remark" field in the mutation.
func (m *AsTenantAttrMutation) AttrRemark() (r string, exists bool) {
	v := m.attr_remark
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrRemark returns the old "attr_remark" field's value of the AsTenantAttr entity.
// If the AsTenantAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrMutation) OldAttrRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttrRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttrRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrRemark: %w", err)
	}
	return oldValue.AttrRemark, nil
}

// ClearAttrRemark clears the value of the "attr_remark" field.
func (m *AsTenantAttrMutation) ClearAttrRemark() {
	m.attr_remark = nil
	m.clearedFields[astenantattr.FieldAttrRemark] = struct{}{}
}

// AttrRemarkCleared returns if the "attr_remark" field was cleared in this mutation.
func (m *AsTenantAttrMutation) AttrRemarkCleared() bool {
	_, ok := m.clearedFields[astenantattr.FieldAttrRemark]
	return ok
}

// ResetAttrRemark resets all changes to the "attr_remark" field.
func (m *AsTenantAttrMutation) ResetAttrRemark() {
	m.attr_remark = nil
	delete(m.clearedFields, astenantattr.FieldAttrRemark)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsTenantAttrMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsTenantAttrMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsTenantAttr entity.
// If the AsTenantAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsTenantAttrMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsTenantAttrMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsTenantAttrMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsTenantAttrMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsTenantAttrMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsTenantAttr entity.
// If the AsTenantAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsTenantAttrMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsTenantAttrMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsTenantAttrMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[astenantattr.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsTenantAttrMutation) StatusCleared() bool {
	_, ok := m.clearedFields[astenantattr.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsTenantAttrMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, astenantattr.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsTenantAttrMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsTenantAttrMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsTenantAttr entity.
// If the AsTenantAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsTenantAttrMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsTenantAttrMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsTenantAttrMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[astenantattr.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsTenantAttrMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[astenantattr.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsTenantAttrMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, astenantattr.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsTenantAttrMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsTenantAttrMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsTenantAttr entity.
// If the AsTenantAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsTenantAttrMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsTenantAttrMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsTenantAttrMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[astenantattr.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsTenantAttrMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[astenantattr.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsTenantAttrMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, astenantattr.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsTenantAttrMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsTenantAttrMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsTenantAttr entity.
// If the AsTenantAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsTenantAttrMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[astenantattr.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsTenantAttrMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[astenantattr.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsTenantAttrMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, astenantattr.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsTenantAttrMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsTenantAttrMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsTenantAttr entity.
// If the AsTenantAttr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsTenantAttrMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[astenantattr.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsTenantAttrMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[astenantattr.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsTenantAttrMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, astenantattr.FieldUpdateTime)
}

// SetParentxID sets the "parentx" edge to the AsTenantAttr entity by id.
func (m *AsTenantAttrMutation) SetParentxID(id int64) {
	m.parentx = &id
}

// ClearParentx clears the "parentx" edge to the AsTenantAttr entity.
func (m *AsTenantAttrMutation) ClearParentx() {
	m.clearedparentx = true
}

// ParentxCleared reports if the "parentx" edge to the AsTenantAttr entity was cleared.
func (m *AsTenantAttrMutation) ParentxCleared() bool {
	return m.ParentIDCleared() || m.clearedparentx
}

// ParentxID returns the "parentx" edge ID in the mutation.
func (m *AsTenantAttrMutation) ParentxID() (id int64, exists bool) {
	if m.parentx != nil {
		return *m.parentx, true
	}
	return
}

// ParentxIDs returns the "parentx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentxID instead. It exists only for internal usage by the builders.
func (m *AsTenantAttrMutation) ParentxIDs() (ids []int64) {
	if id := m.parentx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentx resets all changes to the "parentx" edge.
func (m *AsTenantAttrMutation) ResetParentx() {
	m.parentx = nil
	m.clearedparentx = false
}

// AddChildrenIDs adds the "childrens" edge to the AsTenantAttr entity by ids.
func (m *AsTenantAttrMutation) AddChildrenIDs(ids ...int64) {
	if m.childrens == nil {
		m.childrens = make(map[int64]struct{})
	}
	for i := range ids {
		m.childrens[ids[i]] = struct{}{}
	}
}

// ClearChildrens clears the "childrens" edge to the AsTenantAttr entity.
func (m *AsTenantAttrMutation) ClearChildrens() {
	m.clearedchildrens = true
}

// ChildrensCleared reports if the "childrens" edge to the AsTenantAttr entity was cleared.
func (m *AsTenantAttrMutation) ChildrensCleared() bool {
	return m.clearedchildrens
}

// RemoveChildrenIDs removes the "childrens" edge to the AsTenantAttr entity by IDs.
func (m *AsTenantAttrMutation) RemoveChildrenIDs(ids ...int64) {
	if m.removedchildrens == nil {
		m.removedchildrens = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.childrens, ids[i])
		m.removedchildrens[ids[i]] = struct{}{}
	}
}

// RemovedChildrens returns the removed IDs of the "childrens" edge to the AsTenantAttr entity.
func (m *AsTenantAttrMutation) RemovedChildrensIDs() (ids []int64) {
	for id := range m.removedchildrens {
		ids = append(ids, id)
	}
	return
}

// ChildrensIDs returns the "childrens" edge IDs in the mutation.
func (m *AsTenantAttrMutation) ChildrensIDs() (ids []int64) {
	for id := range m.childrens {
		ids = append(ids, id)
	}
	return
}

// ResetChildrens resets all changes to the "childrens" edge.
func (m *AsTenantAttrMutation) ResetChildrens() {
	m.childrens = nil
	m.clearedchildrens = false
	m.removedchildrens = nil
}

// AddAttrRoleIDs adds the "attrRoles" edge to the AsTenantAttrRole entity by ids.
func (m *AsTenantAttrMutation) AddAttrRoleIDs(ids ...int64) {
	if m.attrRoles == nil {
		m.attrRoles = make(map[int64]struct{})
	}
	for i := range ids {
		m.attrRoles[ids[i]] = struct{}{}
	}
}

// ClearAttrRoles clears the "attrRoles" edge to the AsTenantAttrRole entity.
func (m *AsTenantAttrMutation) ClearAttrRoles() {
	m.clearedattrRoles = true
}

// AttrRolesCleared reports if the "attrRoles" edge to the AsTenantAttrRole entity was cleared.
func (m *AsTenantAttrMutation) AttrRolesCleared() bool {
	return m.clearedattrRoles
}

// RemoveAttrRoleIDs removes the "attrRoles" edge to the AsTenantAttrRole entity by IDs.
func (m *AsTenantAttrMutation) RemoveAttrRoleIDs(ids ...int64) {
	if m.removedattrRoles == nil {
		m.removedattrRoles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.attrRoles, ids[i])
		m.removedattrRoles[ids[i]] = struct{}{}
	}
}

// RemovedAttrRoles returns the removed IDs of the "attrRoles" edge to the AsTenantAttrRole entity.
func (m *AsTenantAttrMutation) RemovedAttrRolesIDs() (ids []int64) {
	for id := range m.removedattrRoles {
		ids = append(ids, id)
	}
	return
}

// AttrRolesIDs returns the "attrRoles" edge IDs in the mutation.
func (m *AsTenantAttrMutation) AttrRolesIDs() (ids []int64) {
	for id := range m.attrRoles {
		ids = append(ids, id)
	}
	return
}

// ResetAttrRoles resets all changes to the "attrRoles" edge.
func (m *AsTenantAttrMutation) ResetAttrRoles() {
	m.attrRoles = nil
	m.clearedattrRoles = false
	m.removedattrRoles = nil
}

// Where appends a list predicates to the AsTenantAttrMutation builder.
func (m *AsTenantAttrMutation) Where(ps ...predicate.AsTenantAttr) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsTenantAttrMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsTenantAttr).
func (m *AsTenantAttrMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsTenantAttrMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.parentx != nil {
		fields = append(fields, astenantattr.FieldParentID)
	}
	if m.attr_name != nil {
		fields = append(fields, astenantattr.FieldAttrName)
	}
	if m.attr_remark != nil {
		fields = append(fields, astenantattr.FieldAttrRemark)
	}
	if m.is_deleted != nil {
		fields = append(fields, astenantattr.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, astenantattr.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, astenantattr.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, astenantattr.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, astenantattr.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, astenantattr.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsTenantAttrMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case astenantattr.FieldParentID:
		return m.ParentID()
	case astenantattr.FieldAttrName:
		return m.AttrName()
	case astenantattr.FieldAttrRemark:
		return m.AttrRemark()
	case astenantattr.FieldIsDeleted:
		return m.IsDeleted()
	case astenantattr.FieldStatus:
		return m.Status()
	case astenantattr.FieldCreateUser:
		return m.CreateUser()
	case astenantattr.FieldUpdateUser:
		return m.UpdateUser()
	case astenantattr.FieldCreateTime:
		return m.CreateTime()
	case astenantattr.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsTenantAttrMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case astenantattr.FieldParentID:
		return m.OldParentID(ctx)
	case astenantattr.FieldAttrName:
		return m.OldAttrName(ctx)
	case astenantattr.FieldAttrRemark:
		return m.OldAttrRemark(ctx)
	case astenantattr.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case astenantattr.FieldStatus:
		return m.OldStatus(ctx)
	case astenantattr.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case astenantattr.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case astenantattr.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case astenantattr.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsTenantAttr field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsTenantAttrMutation) SetField(name string, value ent.Value) error {
	switch name {
	case astenantattr.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case astenantattr.FieldAttrName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrName(v)
		return nil
	case astenantattr.FieldAttrRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrRemark(v)
		return nil
	case astenantattr.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case astenantattr.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case astenantattr.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case astenantattr.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case astenantattr.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case astenantattr.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttr field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsTenantAttrMutation) AddedFields() []string {
	var fields []string
	if m.addis_deleted != nil {
		fields = append(fields, astenantattr.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, astenantattr.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, astenantattr.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, astenantattr.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsTenantAttrMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case astenantattr.FieldIsDeleted:
		return m.AddedIsDeleted()
	case astenantattr.FieldStatus:
		return m.AddedStatus()
	case astenantattr.FieldCreateUser:
		return m.AddedCreateUser()
	case astenantattr.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsTenantAttrMutation) AddField(name string, value ent.Value) error {
	switch name {
	case astenantattr.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case astenantattr.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case astenantattr.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case astenantattr.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttr numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsTenantAttrMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(astenantattr.FieldParentID) {
		fields = append(fields, astenantattr.FieldParentID)
	}
	if m.FieldCleared(astenantattr.FieldAttrRemark) {
		fields = append(fields, astenantattr.FieldAttrRemark)
	}
	if m.FieldCleared(astenantattr.FieldStatus) {
		fields = append(fields, astenantattr.FieldStatus)
	}
	if m.FieldCleared(astenantattr.FieldCreateUser) {
		fields = append(fields, astenantattr.FieldCreateUser)
	}
	if m.FieldCleared(astenantattr.FieldUpdateUser) {
		fields = append(fields, astenantattr.FieldUpdateUser)
	}
	if m.FieldCleared(astenantattr.FieldCreateTime) {
		fields = append(fields, astenantattr.FieldCreateTime)
	}
	if m.FieldCleared(astenantattr.FieldUpdateTime) {
		fields = append(fields, astenantattr.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsTenantAttrMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsTenantAttrMutation) ClearField(name string) error {
	switch name {
	case astenantattr.FieldParentID:
		m.ClearParentID()
		return nil
	case astenantattr.FieldAttrRemark:
		m.ClearAttrRemark()
		return nil
	case astenantattr.FieldStatus:
		m.ClearStatus()
		return nil
	case astenantattr.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case astenantattr.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case astenantattr.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case astenantattr.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttr nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsTenantAttrMutation) ResetField(name string) error {
	switch name {
	case astenantattr.FieldParentID:
		m.ResetParentID()
		return nil
	case astenantattr.FieldAttrName:
		m.ResetAttrName()
		return nil
	case astenantattr.FieldAttrRemark:
		m.ResetAttrRemark()
		return nil
	case astenantattr.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case astenantattr.FieldStatus:
		m.ResetStatus()
		return nil
	case astenantattr.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case astenantattr.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case astenantattr.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case astenantattr.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttr field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsTenantAttrMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parentx != nil {
		edges = append(edges, astenantattr.EdgeParentx)
	}
	if m.childrens != nil {
		edges = append(edges, astenantattr.EdgeChildrens)
	}
	if m.attrRoles != nil {
		edges = append(edges, astenantattr.EdgeAttrRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsTenantAttrMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case astenantattr.EdgeParentx:
		if id := m.parentx; id != nil {
			return []ent.Value{*id}
		}
	case astenantattr.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.childrens))
		for id := range m.childrens {
			ids = append(ids, id)
		}
		return ids
	case astenantattr.EdgeAttrRoles:
		ids := make([]ent.Value, 0, len(m.attrRoles))
		for id := range m.attrRoles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsTenantAttrMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildrens != nil {
		edges = append(edges, astenantattr.EdgeChildrens)
	}
	if m.removedattrRoles != nil {
		edges = append(edges, astenantattr.EdgeAttrRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsTenantAttrMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case astenantattr.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.removedchildrens))
		for id := range m.removedchildrens {
			ids = append(ids, id)
		}
		return ids
	case astenantattr.EdgeAttrRoles:
		ids := make([]ent.Value, 0, len(m.removedattrRoles))
		for id := range m.removedattrRoles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsTenantAttrMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparentx {
		edges = append(edges, astenantattr.EdgeParentx)
	}
	if m.clearedchildrens {
		edges = append(edges, astenantattr.EdgeChildrens)
	}
	if m.clearedattrRoles {
		edges = append(edges, astenantattr.EdgeAttrRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsTenantAttrMutation) EdgeCleared(name string) bool {
	switch name {
	case astenantattr.EdgeParentx:
		return m.clearedparentx
	case astenantattr.EdgeChildrens:
		return m.clearedchildrens
	case astenantattr.EdgeAttrRoles:
		return m.clearedattrRoles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsTenantAttrMutation) ClearEdge(name string) error {
	switch name {
	case astenantattr.EdgeParentx:
		m.ClearParentx()
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttr unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsTenantAttrMutation) ResetEdge(name string) error {
	switch name {
	case astenantattr.EdgeParentx:
		m.ResetParentx()
		return nil
	case astenantattr.EdgeChildrens:
		m.ResetChildrens()
		return nil
	case astenantattr.EdgeAttrRoles:
		m.ResetAttrRoles()
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttr edge %s", name)
}

// AsTenantAttrRoleMutation represents an operation that mutates the AsTenantAttrRole nodes in the graph.
type AsTenantAttrRoleMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	is_default         *int64
	addis_default      *int64
	is_deleted         *int64
	addis_deleted      *int64
	status             *int64
	addstatus          *int64
	create_user        *int64
	addcreate_user     *int64
	update_user        *int64
	addupdate_user     *int64
	create_time        *date.DateTime
	update_time        *date.DateTime
	clearedFields      map[string]struct{}
	tenantAttrx        *int64
	clearedtenantAttrx bool
	rolex              *int64
	clearedrolex       bool
	done               bool
	oldValue           func(context.Context) (*AsTenantAttrRole, error)
	predicates         []predicate.AsTenantAttrRole
}

var _ ent.Mutation = (*AsTenantAttrRoleMutation)(nil)

// astenantattrroleOption allows management of the mutation configuration using functional options.
type astenantattrroleOption func(*AsTenantAttrRoleMutation)

// newAsTenantAttrRoleMutation creates new mutation for the AsTenantAttrRole entity.
func newAsTenantAttrRoleMutation(c config, op Op, opts ...astenantattrroleOption) *AsTenantAttrRoleMutation {
	m := &AsTenantAttrRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAsTenantAttrRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsTenantAttrRoleID sets the ID field of the mutation.
func withAsTenantAttrRoleID(id int64) astenantattrroleOption {
	return func(m *AsTenantAttrRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AsTenantAttrRole
		)
		m.oldValue = func(ctx context.Context) (*AsTenantAttrRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsTenantAttrRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsTenantAttrRole sets the old AsTenantAttrRole of the mutation.
func withAsTenantAttrRole(node *AsTenantAttrRole) astenantattrroleOption {
	return func(m *AsTenantAttrRoleMutation) {
		m.oldValue = func(context.Context) (*AsTenantAttrRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsTenantAttrRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsTenantAttrRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsTenantAttrRole entities.
func (m *AsTenantAttrRoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsTenantAttrRoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsTenantAttrRoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsTenantAttrRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAttrID sets the "attr_id" field.
func (m *AsTenantAttrRoleMutation) SetAttrID(i int64) {
	m.tenantAttrx = &i
}

// AttrID returns the value of the "attr_id" field in the mutation.
func (m *AsTenantAttrRoleMutation) AttrID() (r int64, exists bool) {
	v := m.tenantAttrx
	if v == nil {
		return
	}
	return *v, true
}

// OldAttrID returns the old "attr_id" field's value of the AsTenantAttrRole entity.
// If the AsTenantAttrRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrRoleMutation) OldAttrID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttrID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttrID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttrID: %w", err)
	}
	return oldValue.AttrID, nil
}

// ClearAttrID clears the value of the "attr_id" field.
func (m *AsTenantAttrRoleMutation) ClearAttrID() {
	m.tenantAttrx = nil
	m.clearedFields[astenantattrrole.FieldAttrID] = struct{}{}
}

// AttrIDCleared returns if the "attr_id" field was cleared in this mutation.
func (m *AsTenantAttrRoleMutation) AttrIDCleared() bool {
	_, ok := m.clearedFields[astenantattrrole.FieldAttrID]
	return ok
}

// ResetAttrID resets all changes to the "attr_id" field.
func (m *AsTenantAttrRoleMutation) ResetAttrID() {
	m.tenantAttrx = nil
	delete(m.clearedFields, astenantattrrole.FieldAttrID)
}

// SetRoleID sets the "role_id" field.
func (m *AsTenantAttrRoleMutation) SetRoleID(i int64) {
	m.rolex = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AsTenantAttrRoleMutation) RoleID() (r int64, exists bool) {
	v := m.rolex
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AsTenantAttrRole entity.
// If the AsTenantAttrRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrRoleMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *AsTenantAttrRoleMutation) ClearRoleID() {
	m.rolex = nil
	m.clearedFields[astenantattrrole.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *AsTenantAttrRoleMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[astenantattrrole.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AsTenantAttrRoleMutation) ResetRoleID() {
	m.rolex = nil
	delete(m.clearedFields, astenantattrrole.FieldRoleID)
}

// SetIsDefault sets the "is_default" field.
func (m *AsTenantAttrRoleMutation) SetIsDefault(i int64) {
	m.is_default = &i
	m.addis_default = nil
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *AsTenantAttrRoleMutation) IsDefault() (r int64, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the AsTenantAttrRole entity.
// If the AsTenantAttrRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrRoleMutation) OldIsDefault(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// AddIsDefault adds i to the "is_default" field.
func (m *AsTenantAttrRoleMutation) AddIsDefault(i int64) {
	if m.addis_default != nil {
		*m.addis_default += i
	} else {
		m.addis_default = &i
	}
}

// AddedIsDefault returns the value that was added to the "is_default" field in this mutation.
func (m *AsTenantAttrRoleMutation) AddedIsDefault() (r int64, exists bool) {
	v := m.addis_default
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *AsTenantAttrRoleMutation) ResetIsDefault() {
	m.is_default = nil
	m.addis_default = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsTenantAttrRoleMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsTenantAttrRoleMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsTenantAttrRole entity.
// If the AsTenantAttrRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrRoleMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsTenantAttrRoleMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsTenantAttrRoleMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsTenantAttrRoleMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsTenantAttrRoleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsTenantAttrRoleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsTenantAttrRole entity.
// If the AsTenantAttrRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrRoleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsTenantAttrRoleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsTenantAttrRoleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsTenantAttrRoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[astenantattrrole.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsTenantAttrRoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[astenantattrrole.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsTenantAttrRoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, astenantattrrole.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsTenantAttrRoleMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsTenantAttrRoleMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsTenantAttrRole entity.
// If the AsTenantAttrRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrRoleMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsTenantAttrRoleMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsTenantAttrRoleMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsTenantAttrRoleMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[astenantattrrole.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsTenantAttrRoleMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[astenantattrrole.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsTenantAttrRoleMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, astenantattrrole.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsTenantAttrRoleMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsTenantAttrRoleMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsTenantAttrRole entity.
// If the AsTenantAttrRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrRoleMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsTenantAttrRoleMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsTenantAttrRoleMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsTenantAttrRoleMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[astenantattrrole.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsTenantAttrRoleMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[astenantattrrole.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsTenantAttrRoleMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, astenantattrrole.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsTenantAttrRoleMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsTenantAttrRoleMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsTenantAttrRole entity.
// If the AsTenantAttrRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrRoleMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsTenantAttrRoleMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[astenantattrrole.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsTenantAttrRoleMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[astenantattrrole.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsTenantAttrRoleMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, astenantattrrole.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsTenantAttrRoleMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsTenantAttrRoleMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsTenantAttrRole entity.
// If the AsTenantAttrRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantAttrRoleMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsTenantAttrRoleMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[astenantattrrole.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsTenantAttrRoleMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[astenantattrrole.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsTenantAttrRoleMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, astenantattrrole.FieldUpdateTime)
}

// SetTenantAttrxID sets the "tenantAttrx" edge to the AsTenantAttr entity by id.
func (m *AsTenantAttrRoleMutation) SetTenantAttrxID(id int64) {
	m.tenantAttrx = &id
}

// ClearTenantAttrx clears the "tenantAttrx" edge to the AsTenantAttr entity.
func (m *AsTenantAttrRoleMutation) ClearTenantAttrx() {
	m.clearedtenantAttrx = true
}

// TenantAttrxCleared reports if the "tenantAttrx" edge to the AsTenantAttr entity was cleared.
func (m *AsTenantAttrRoleMutation) TenantAttrxCleared() bool {
	return m.AttrIDCleared() || m.clearedtenantAttrx
}

// TenantAttrxID returns the "tenantAttrx" edge ID in the mutation.
func (m *AsTenantAttrRoleMutation) TenantAttrxID() (id int64, exists bool) {
	if m.tenantAttrx != nil {
		return *m.tenantAttrx, true
	}
	return
}

// TenantAttrxIDs returns the "tenantAttrx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantAttrxID instead. It exists only for internal usage by the builders.
func (m *AsTenantAttrRoleMutation) TenantAttrxIDs() (ids []int64) {
	if id := m.tenantAttrx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenantAttrx resets all changes to the "tenantAttrx" edge.
func (m *AsTenantAttrRoleMutation) ResetTenantAttrx() {
	m.tenantAttrx = nil
	m.clearedtenantAttrx = false
}

// SetRolexID sets the "rolex" edge to the AsRole entity by id.
func (m *AsTenantAttrRoleMutation) SetRolexID(id int64) {
	m.rolex = &id
}

// ClearRolex clears the "rolex" edge to the AsRole entity.
func (m *AsTenantAttrRoleMutation) ClearRolex() {
	m.clearedrolex = true
}

// RolexCleared reports if the "rolex" edge to the AsRole entity was cleared.
func (m *AsTenantAttrRoleMutation) RolexCleared() bool {
	return m.RoleIDCleared() || m.clearedrolex
}

// RolexID returns the "rolex" edge ID in the mutation.
func (m *AsTenantAttrRoleMutation) RolexID() (id int64, exists bool) {
	if m.rolex != nil {
		return *m.rolex, true
	}
	return
}

// RolexIDs returns the "rolex" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolexID instead. It exists only for internal usage by the builders.
func (m *AsTenantAttrRoleMutation) RolexIDs() (ids []int64) {
	if id := m.rolex; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRolex resets all changes to the "rolex" edge.
func (m *AsTenantAttrRoleMutation) ResetRolex() {
	m.rolex = nil
	m.clearedrolex = false
}

// Where appends a list predicates to the AsTenantAttrRoleMutation builder.
func (m *AsTenantAttrRoleMutation) Where(ps ...predicate.AsTenantAttrRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsTenantAttrRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsTenantAttrRole).
func (m *AsTenantAttrRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsTenantAttrRoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.tenantAttrx != nil {
		fields = append(fields, astenantattrrole.FieldAttrID)
	}
	if m.rolex != nil {
		fields = append(fields, astenantattrrole.FieldRoleID)
	}
	if m.is_default != nil {
		fields = append(fields, astenantattrrole.FieldIsDefault)
	}
	if m.is_deleted != nil {
		fields = append(fields, astenantattrrole.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, astenantattrrole.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, astenantattrrole.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, astenantattrrole.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, astenantattrrole.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, astenantattrrole.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsTenantAttrRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case astenantattrrole.FieldAttrID:
		return m.AttrID()
	case astenantattrrole.FieldRoleID:
		return m.RoleID()
	case astenantattrrole.FieldIsDefault:
		return m.IsDefault()
	case astenantattrrole.FieldIsDeleted:
		return m.IsDeleted()
	case astenantattrrole.FieldStatus:
		return m.Status()
	case astenantattrrole.FieldCreateUser:
		return m.CreateUser()
	case astenantattrrole.FieldUpdateUser:
		return m.UpdateUser()
	case astenantattrrole.FieldCreateTime:
		return m.CreateTime()
	case astenantattrrole.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsTenantAttrRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case astenantattrrole.FieldAttrID:
		return m.OldAttrID(ctx)
	case astenantattrrole.FieldRoleID:
		return m.OldRoleID(ctx)
	case astenantattrrole.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case astenantattrrole.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case astenantattrrole.FieldStatus:
		return m.OldStatus(ctx)
	case astenantattrrole.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case astenantattrrole.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case astenantattrrole.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case astenantattrrole.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsTenantAttrRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsTenantAttrRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case astenantattrrole.FieldAttrID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttrID(v)
		return nil
	case astenantattrrole.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case astenantattrrole.FieldIsDefault:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case astenantattrrole.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case astenantattrrole.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case astenantattrrole.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case astenantattrrole.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case astenantattrrole.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case astenantattrrole.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttrRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsTenantAttrRoleMutation) AddedFields() []string {
	var fields []string
	if m.addis_default != nil {
		fields = append(fields, astenantattrrole.FieldIsDefault)
	}
	if m.addis_deleted != nil {
		fields = append(fields, astenantattrrole.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, astenantattrrole.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, astenantattrrole.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, astenantattrrole.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsTenantAttrRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case astenantattrrole.FieldIsDefault:
		return m.AddedIsDefault()
	case astenantattrrole.FieldIsDeleted:
		return m.AddedIsDeleted()
	case astenantattrrole.FieldStatus:
		return m.AddedStatus()
	case astenantattrrole.FieldCreateUser:
		return m.AddedCreateUser()
	case astenantattrrole.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsTenantAttrRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case astenantattrrole.FieldIsDefault:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDefault(v)
		return nil
	case astenantattrrole.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case astenantattrrole.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case astenantattrrole.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case astenantattrrole.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttrRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsTenantAttrRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(astenantattrrole.FieldAttrID) {
		fields = append(fields, astenantattrrole.FieldAttrID)
	}
	if m.FieldCleared(astenantattrrole.FieldRoleID) {
		fields = append(fields, astenantattrrole.FieldRoleID)
	}
	if m.FieldCleared(astenantattrrole.FieldStatus) {
		fields = append(fields, astenantattrrole.FieldStatus)
	}
	if m.FieldCleared(astenantattrrole.FieldCreateUser) {
		fields = append(fields, astenantattrrole.FieldCreateUser)
	}
	if m.FieldCleared(astenantattrrole.FieldUpdateUser) {
		fields = append(fields, astenantattrrole.FieldUpdateUser)
	}
	if m.FieldCleared(astenantattrrole.FieldCreateTime) {
		fields = append(fields, astenantattrrole.FieldCreateTime)
	}
	if m.FieldCleared(astenantattrrole.FieldUpdateTime) {
		fields = append(fields, astenantattrrole.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsTenantAttrRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsTenantAttrRoleMutation) ClearField(name string) error {
	switch name {
	case astenantattrrole.FieldAttrID:
		m.ClearAttrID()
		return nil
	case astenantattrrole.FieldRoleID:
		m.ClearRoleID()
		return nil
	case astenantattrrole.FieldStatus:
		m.ClearStatus()
		return nil
	case astenantattrrole.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case astenantattrrole.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case astenantattrrole.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case astenantattrrole.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttrRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsTenantAttrRoleMutation) ResetField(name string) error {
	switch name {
	case astenantattrrole.FieldAttrID:
		m.ResetAttrID()
		return nil
	case astenantattrrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case astenantattrrole.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case astenantattrrole.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case astenantattrrole.FieldStatus:
		m.ResetStatus()
		return nil
	case astenantattrrole.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case astenantattrrole.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case astenantattrrole.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case astenantattrrole.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttrRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsTenantAttrRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenantAttrx != nil {
		edges = append(edges, astenantattrrole.EdgeTenantAttrx)
	}
	if m.rolex != nil {
		edges = append(edges, astenantattrrole.EdgeRolex)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsTenantAttrRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case astenantattrrole.EdgeTenantAttrx:
		if id := m.tenantAttrx; id != nil {
			return []ent.Value{*id}
		}
	case astenantattrrole.EdgeRolex:
		if id := m.rolex; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsTenantAttrRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsTenantAttrRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsTenantAttrRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenantAttrx {
		edges = append(edges, astenantattrrole.EdgeTenantAttrx)
	}
	if m.clearedrolex {
		edges = append(edges, astenantattrrole.EdgeRolex)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsTenantAttrRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case astenantattrrole.EdgeTenantAttrx:
		return m.clearedtenantAttrx
	case astenantattrrole.EdgeRolex:
		return m.clearedrolex
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsTenantAttrRoleMutation) ClearEdge(name string) error {
	switch name {
	case astenantattrrole.EdgeTenantAttrx:
		m.ClearTenantAttrx()
		return nil
	case astenantattrrole.EdgeRolex:
		m.ClearRolex()
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttrRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsTenantAttrRoleMutation) ResetEdge(name string) error {
	switch name {
	case astenantattrrole.EdgeTenantAttrx:
		m.ResetTenantAttrx()
		return nil
	case astenantattrrole.EdgeRolex:
		m.ResetRolex()
		return nil
	}
	return fmt.Errorf("unknown AsTenantAttrRole edge %s", name)
}

// AsTenantIconMutation represents an operation that mutates the AsTenantIcon nodes in the graph.
type AsTenantIconMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	tenant_code    *string
	icon           *string
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AsTenantIcon, error)
	predicates     []predicate.AsTenantIcon
}

var _ ent.Mutation = (*AsTenantIconMutation)(nil)

// astenanticonOption allows management of the mutation configuration using functional options.
type astenanticonOption func(*AsTenantIconMutation)

// newAsTenantIconMutation creates new mutation for the AsTenantIcon entity.
func newAsTenantIconMutation(c config, op Op, opts ...astenanticonOption) *AsTenantIconMutation {
	m := &AsTenantIconMutation{
		config:        c,
		op:            op,
		typ:           TypeAsTenantIcon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsTenantIconID sets the ID field of the mutation.
func withAsTenantIconID(id int64) astenanticonOption {
	return func(m *AsTenantIconMutation) {
		var (
			err   error
			once  sync.Once
			value *AsTenantIcon
		)
		m.oldValue = func(ctx context.Context) (*AsTenantIcon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsTenantIcon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsTenantIcon sets the old AsTenantIcon of the mutation.
func withAsTenantIcon(node *AsTenantIcon) astenanticonOption {
	return func(m *AsTenantIconMutation) {
		m.oldValue = func(context.Context) (*AsTenantIcon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsTenantIconMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsTenantIconMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsTenantIcon entities.
func (m *AsTenantIconMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsTenantIconMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsTenantIconMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsTenantIcon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantCode sets the "tenant_code" field.
func (m *AsTenantIconMutation) SetTenantCode(s string) {
	m.tenant_code = &s
}

// TenantCode returns the value of the "tenant_code" field in the mutation.
func (m *AsTenantIconMutation) TenantCode() (r string, exists bool) {
	v := m.tenant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantCode returns the old "tenant_code" field's value of the AsTenantIcon entity.
// If the AsTenantIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantIconMutation) OldTenantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantCode: %w", err)
	}
	return oldValue.TenantCode, nil
}

// ClearTenantCode clears the value of the "tenant_code" field.
func (m *AsTenantIconMutation) ClearTenantCode() {
	m.tenant_code = nil
	m.clearedFields[astenanticon.FieldTenantCode] = struct{}{}
}

// TenantCodeCleared returns if the "tenant_code" field was cleared in this mutation.
func (m *AsTenantIconMutation) TenantCodeCleared() bool {
	_, ok := m.clearedFields[astenanticon.FieldTenantCode]
	return ok
}

// ResetTenantCode resets all changes to the "tenant_code" field.
func (m *AsTenantIconMutation) ResetTenantCode() {
	m.tenant_code = nil
	delete(m.clearedFields, astenanticon.FieldTenantCode)
}

// SetIcon sets the "icon" field.
func (m *AsTenantIconMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AsTenantIconMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the AsTenantIcon entity.
// If the AsTenantIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantIconMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *AsTenantIconMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[astenanticon.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *AsTenantIconMutation) IconCleared() bool {
	_, ok := m.clearedFields[astenanticon.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *AsTenantIconMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, astenanticon.FieldIcon)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsTenantIconMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsTenantIconMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsTenantIcon entity.
// If the AsTenantIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantIconMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsTenantIconMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsTenantIconMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsTenantIconMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsTenantIconMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsTenantIconMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsTenantIcon entity.
// If the AsTenantIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantIconMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsTenantIconMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsTenantIconMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsTenantIconMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[astenanticon.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsTenantIconMutation) StatusCleared() bool {
	_, ok := m.clearedFields[astenanticon.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsTenantIconMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, astenanticon.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsTenantIconMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsTenantIconMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsTenantIcon entity.
// If the AsTenantIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantIconMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsTenantIconMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsTenantIconMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsTenantIconMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[astenanticon.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsTenantIconMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[astenanticon.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsTenantIconMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, astenanticon.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsTenantIconMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsTenantIconMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsTenantIcon entity.
// If the AsTenantIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantIconMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsTenantIconMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsTenantIconMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsTenantIconMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[astenanticon.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsTenantIconMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[astenanticon.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsTenantIconMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, astenanticon.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsTenantIconMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsTenantIconMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsTenantIcon entity.
// If the AsTenantIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantIconMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsTenantIconMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[astenanticon.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsTenantIconMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[astenanticon.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsTenantIconMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, astenanticon.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsTenantIconMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsTenantIconMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsTenantIcon entity.
// If the AsTenantIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsTenantIconMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsTenantIconMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[astenanticon.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsTenantIconMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[astenanticon.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsTenantIconMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, astenanticon.FieldUpdateTime)
}

// Where appends a list predicates to the AsTenantIconMutation builder.
func (m *AsTenantIconMutation) Where(ps ...predicate.AsTenantIcon) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsTenantIconMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsTenantIcon).
func (m *AsTenantIconMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsTenantIconMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant_code != nil {
		fields = append(fields, astenanticon.FieldTenantCode)
	}
	if m.icon != nil {
		fields = append(fields, astenanticon.FieldIcon)
	}
	if m.is_deleted != nil {
		fields = append(fields, astenanticon.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, astenanticon.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, astenanticon.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, astenanticon.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, astenanticon.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, astenanticon.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsTenantIconMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case astenanticon.FieldTenantCode:
		return m.TenantCode()
	case astenanticon.FieldIcon:
		return m.Icon()
	case astenanticon.FieldIsDeleted:
		return m.IsDeleted()
	case astenanticon.FieldStatus:
		return m.Status()
	case astenanticon.FieldCreateUser:
		return m.CreateUser()
	case astenanticon.FieldUpdateUser:
		return m.UpdateUser()
	case astenanticon.FieldCreateTime:
		return m.CreateTime()
	case astenanticon.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsTenantIconMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case astenanticon.FieldTenantCode:
		return m.OldTenantCode(ctx)
	case astenanticon.FieldIcon:
		return m.OldIcon(ctx)
	case astenanticon.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case astenanticon.FieldStatus:
		return m.OldStatus(ctx)
	case astenanticon.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case astenanticon.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case astenanticon.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case astenanticon.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsTenantIcon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsTenantIconMutation) SetField(name string, value ent.Value) error {
	switch name {
	case astenanticon.FieldTenantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantCode(v)
		return nil
	case astenanticon.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case astenanticon.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case astenanticon.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case astenanticon.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case astenanticon.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case astenanticon.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case astenanticon.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsTenantIcon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsTenantIconMutation) AddedFields() []string {
	var fields []string
	if m.addis_deleted != nil {
		fields = append(fields, astenanticon.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, astenanticon.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, astenanticon.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, astenanticon.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsTenantIconMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case astenanticon.FieldIsDeleted:
		return m.AddedIsDeleted()
	case astenanticon.FieldStatus:
		return m.AddedStatus()
	case astenanticon.FieldCreateUser:
		return m.AddedCreateUser()
	case astenanticon.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsTenantIconMutation) AddField(name string, value ent.Value) error {
	switch name {
	case astenanticon.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case astenanticon.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case astenanticon.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case astenanticon.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsTenantIcon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsTenantIconMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(astenanticon.FieldTenantCode) {
		fields = append(fields, astenanticon.FieldTenantCode)
	}
	if m.FieldCleared(astenanticon.FieldIcon) {
		fields = append(fields, astenanticon.FieldIcon)
	}
	if m.FieldCleared(astenanticon.FieldStatus) {
		fields = append(fields, astenanticon.FieldStatus)
	}
	if m.FieldCleared(astenanticon.FieldCreateUser) {
		fields = append(fields, astenanticon.FieldCreateUser)
	}
	if m.FieldCleared(astenanticon.FieldUpdateUser) {
		fields = append(fields, astenanticon.FieldUpdateUser)
	}
	if m.FieldCleared(astenanticon.FieldCreateTime) {
		fields = append(fields, astenanticon.FieldCreateTime)
	}
	if m.FieldCleared(astenanticon.FieldUpdateTime) {
		fields = append(fields, astenanticon.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsTenantIconMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsTenantIconMutation) ClearField(name string) error {
	switch name {
	case astenanticon.FieldTenantCode:
		m.ClearTenantCode()
		return nil
	case astenanticon.FieldIcon:
		m.ClearIcon()
		return nil
	case astenanticon.FieldStatus:
		m.ClearStatus()
		return nil
	case astenanticon.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case astenanticon.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case astenanticon.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case astenanticon.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsTenantIcon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsTenantIconMutation) ResetField(name string) error {
	switch name {
	case astenanticon.FieldTenantCode:
		m.ResetTenantCode()
		return nil
	case astenanticon.FieldIcon:
		m.ResetIcon()
		return nil
	case astenanticon.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case astenanticon.FieldStatus:
		m.ResetStatus()
		return nil
	case astenanticon.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case astenanticon.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case astenanticon.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case astenanticon.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsTenantIcon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsTenantIconMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsTenantIconMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsTenantIconMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsTenantIconMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsTenantIconMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsTenantIconMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsTenantIconMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AsTenantIcon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsTenantIconMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AsTenantIcon edge %s", name)
}

// AsUnitMutation represents an operation that mutates the AsUnit nodes in the graph.
type AsUnitMutation struct {
	config
	op                                         Op
	typ                                        string
	id                                         *int64
	unit_name                                  *string
	unit_name_en                               *string
	organization_form                          *int64
	addorganization_form                       *int64
	unit_type                                  *int64
	addunit_type                               *int64
	parent_node_name                           *string
	charge_section_id                          *int64
	addcharge_section_id                       *int64
	charge_section_code                        *string
	charge_section_name                        *string
	local_financial_code                       *string
	local_financial_name                       *string
	local_financial_id                         *string
	office_administration_code                 *string
	office_administration_name                 *string
	administration_division_code               *string
	administration_division_name               *string
	budget_code                                *int64
	addbudget_code                             *int64
	college_code                               *string
	organization_code                          *string
	unit_type_code                             *int64
	addunit_type_code                          *int64
	unit_type_name                             *int64
	addunit_type_name                          *int64
	unit_basic_property                        *int64
	addunit_basic_property                     *int64
	social_credit_code                         *string
	budget_unit_name                           *string
	budget_unit_code                           *string
	budget_management_level                    *int64
	addbudget_management_level                 *int64
	firm_name                                  *string
	firm_code                                  *string
	telephone_number                           *string
	phone_number                               *string
	fax_number                                 *string
	email_address                              *string
	province                                   *string
	city                                       *string
	county                                     *string
	street_address                             *string
	postal_code                                *string
	fund_supply_mode_name                      *int64
	addfund_supply_mode_name                   *int64
	fund_supply_mode_code                      *int64
	addfund_supply_mode_code                   *int64
	administration_level_name                  *int64
	addadministration_level_name               *int64
	administration_level_type                  *int64
	addadministration_level_type               *int64
	department_category_name                   *int64
	adddepartment_category_name                *int64
	business_department_classification_code    *int64
	addbusiness_department_classification_code *int64
	principal                                  *string
	contact                                    *string
	corporate_representative                   *string
	economic_type                              *int64
	addeconomic_type                           *int64
	financial_affiliation                      *string
	financial_unit                             *int64
	addfinancial_unit                          *int64
	vertical_unit                              *int64
	addvertical_unit                           *int64
	virtual_unit                               *int64
	addvirtual_unit                            *int64
	accounting_system                          *int64
	addaccounting_system                       *int64
	corporate_tag                              *string
	maintainer_mark                            *string
	supplier_mark                              *string
	manufacture_mark                           *string
	asset_disposal_agency_tag                  *string
	state_asset_management_company             *string
	institution_number                         *int64
	addinstitution_number                      *int64
	authorized_number                          *int64
	addauthorized_number                       *int64
	of_side_number                             *int64
	addof_side_number                          *int64
	institution_authority                      *string
	administration_authority                   *string
	enable_time                                *date.DateTime
	disable_time                               *date.DateTime
	seal_time                                  *date.DateTime
	unit_remark                                *string
	asset_download_status                      *string
	latitude_and_longitude                     *string
	sort                                       *int64
	addsort                                    *int64
	organ_code                                 *string
	had_inner_number                           *int64
	addhad_inner_number                        *int64
	approve_inner_number                       *int64
	addapprove_inner_number                    *int64
	img                                        *string
	link_man                                   *string
	link_phone                                 *string
	unit_code                                  *string
	authority_total                            *int64
	addauthority_total                         *int64
	staff_on_active_duty                       *int64
	addstaff_on_active_duty                    *int64
	retired_staff                              *int64
	addretired_staff                           *int64
	other_staff                                *int64
	addother_staff                             *int64
	is_virtual                                 *string
	unit_reform                                *int64
	addunit_reform                             *int64
	person_expenditure                         *int64
	addperson_expenditure                      *int64
	institution_type                           *string
	department_identification                  *int64
	adddepartment_identification               *int64
	total_headcount                            *int64
	addtotal_headcount                         *int64
	is_deleted                                 *int64
	addis_deleted                              *int64
	status                                     *int64
	addstatus                                  *int64
	create_user                                *int64
	addcreate_user                             *int64
	update_user                                *int64
	addupdate_user                             *int64
	create_time                                *date.DateTime
	update_time                                *date.DateTime
	clearedFields                              map[string]struct{}
	tenantx                                    *int64
	clearedtenantx                             bool
	done                                       bool
	oldValue                                   func(context.Context) (*AsUnit, error)
	predicates                                 []predicate.AsUnit
}

var _ ent.Mutation = (*AsUnitMutation)(nil)

// asunitOption allows management of the mutation configuration using functional options.
type asunitOption func(*AsUnitMutation)

// newAsUnitMutation creates new mutation for the AsUnit entity.
func newAsUnitMutation(c config, op Op, opts ...asunitOption) *AsUnitMutation {
	m := &AsUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeAsUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsUnitID sets the ID field of the mutation.
func withAsUnitID(id int64) asunitOption {
	return func(m *AsUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *AsUnit
		)
		m.oldValue = func(ctx context.Context) (*AsUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsUnit sets the old AsUnit of the mutation.
func withAsUnit(node *AsUnit) asunitOption {
	return func(m *AsUnitMutation) {
		m.oldValue = func(context.Context) (*AsUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsUnit entities.
func (m *AsUnitMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsUnitMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsUnitMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUnitName sets the "unit_name" field.
func (m *AsUnitMutation) SetUnitName(s string) {
	m.unit_name = &s
}

// UnitName returns the value of the "unit_name" field in the mutation.
func (m *AsUnitMutation) UnitName() (r string, exists bool) {
	v := m.unit_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitName returns the old "unit_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUnitName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitName: %w", err)
	}
	return oldValue.UnitName, nil
}

// ResetUnitName resets all changes to the "unit_name" field.
func (m *AsUnitMutation) ResetUnitName() {
	m.unit_name = nil
}

// SetUnitNameEn sets the "unit_name_en" field.
func (m *AsUnitMutation) SetUnitNameEn(s string) {
	m.unit_name_en = &s
}

// UnitNameEn returns the value of the "unit_name_en" field in the mutation.
func (m *AsUnitMutation) UnitNameEn() (r string, exists bool) {
	v := m.unit_name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitNameEn returns the old "unit_name_en" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUnitNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitNameEn: %w", err)
	}
	return oldValue.UnitNameEn, nil
}

// ClearUnitNameEn clears the value of the "unit_name_en" field.
func (m *AsUnitMutation) ClearUnitNameEn() {
	m.unit_name_en = nil
	m.clearedFields[asunit.FieldUnitNameEn] = struct{}{}
}

// UnitNameEnCleared returns if the "unit_name_en" field was cleared in this mutation.
func (m *AsUnitMutation) UnitNameEnCleared() bool {
	_, ok := m.clearedFields[asunit.FieldUnitNameEn]
	return ok
}

// ResetUnitNameEn resets all changes to the "unit_name_en" field.
func (m *AsUnitMutation) ResetUnitNameEn() {
	m.unit_name_en = nil
	delete(m.clearedFields, asunit.FieldUnitNameEn)
}

// SetOrganizationForm sets the "organization_form" field.
func (m *AsUnitMutation) SetOrganizationForm(i int64) {
	m.organization_form = &i
	m.addorganization_form = nil
}

// OrganizationForm returns the value of the "organization_form" field in the mutation.
func (m *AsUnitMutation) OrganizationForm() (r int64, exists bool) {
	v := m.organization_form
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationForm returns the old "organization_form" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldOrganizationForm(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationForm: %w", err)
	}
	return oldValue.OrganizationForm, nil
}

// AddOrganizationForm adds i to the "organization_form" field.
func (m *AsUnitMutation) AddOrganizationForm(i int64) {
	if m.addorganization_form != nil {
		*m.addorganization_form += i
	} else {
		m.addorganization_form = &i
	}
}

// AddedOrganizationForm returns the value that was added to the "organization_form" field in this mutation.
func (m *AsUnitMutation) AddedOrganizationForm() (r int64, exists bool) {
	v := m.addorganization_form
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrganizationForm clears the value of the "organization_form" field.
func (m *AsUnitMutation) ClearOrganizationForm() {
	m.organization_form = nil
	m.addorganization_form = nil
	m.clearedFields[asunit.FieldOrganizationForm] = struct{}{}
}

// OrganizationFormCleared returns if the "organization_form" field was cleared in this mutation.
func (m *AsUnitMutation) OrganizationFormCleared() bool {
	_, ok := m.clearedFields[asunit.FieldOrganizationForm]
	return ok
}

// ResetOrganizationForm resets all changes to the "organization_form" field.
func (m *AsUnitMutation) ResetOrganizationForm() {
	m.organization_form = nil
	m.addorganization_form = nil
	delete(m.clearedFields, asunit.FieldOrganizationForm)
}

// SetUnitType sets the "unit_type" field.
func (m *AsUnitMutation) SetUnitType(i int64) {
	m.unit_type = &i
	m.addunit_type = nil
}

// UnitType returns the value of the "unit_type" field in the mutation.
func (m *AsUnitMutation) UnitType() (r int64, exists bool) {
	v := m.unit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitType returns the old "unit_type" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUnitType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitType: %w", err)
	}
	return oldValue.UnitType, nil
}

// AddUnitType adds i to the "unit_type" field.
func (m *AsUnitMutation) AddUnitType(i int64) {
	if m.addunit_type != nil {
		*m.addunit_type += i
	} else {
		m.addunit_type = &i
	}
}

// AddedUnitType returns the value that was added to the "unit_type" field in this mutation.
func (m *AsUnitMutation) AddedUnitType() (r int64, exists bool) {
	v := m.addunit_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitType clears the value of the "unit_type" field.
func (m *AsUnitMutation) ClearUnitType() {
	m.unit_type = nil
	m.addunit_type = nil
	m.clearedFields[asunit.FieldUnitType] = struct{}{}
}

// UnitTypeCleared returns if the "unit_type" field was cleared in this mutation.
func (m *AsUnitMutation) UnitTypeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldUnitType]
	return ok
}

// ResetUnitType resets all changes to the "unit_type" field.
func (m *AsUnitMutation) ResetUnitType() {
	m.unit_type = nil
	m.addunit_type = nil
	delete(m.clearedFields, asunit.FieldUnitType)
}

// SetParentNodeName sets the "parent_node_name" field.
func (m *AsUnitMutation) SetParentNodeName(s string) {
	m.parent_node_name = &s
}

// ParentNodeName returns the value of the "parent_node_name" field in the mutation.
func (m *AsUnitMutation) ParentNodeName() (r string, exists bool) {
	v := m.parent_node_name
	if v == nil {
		return
	}
	return *v, true
}

// OldParentNodeName returns the old "parent_node_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldParentNodeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentNodeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentNodeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentNodeName: %w", err)
	}
	return oldValue.ParentNodeName, nil
}

// ClearParentNodeName clears the value of the "parent_node_name" field.
func (m *AsUnitMutation) ClearParentNodeName() {
	m.parent_node_name = nil
	m.clearedFields[asunit.FieldParentNodeName] = struct{}{}
}

// ParentNodeNameCleared returns if the "parent_node_name" field was cleared in this mutation.
func (m *AsUnitMutation) ParentNodeNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldParentNodeName]
	return ok
}

// ResetParentNodeName resets all changes to the "parent_node_name" field.
func (m *AsUnitMutation) ResetParentNodeName() {
	m.parent_node_name = nil
	delete(m.clearedFields, asunit.FieldParentNodeName)
}

// SetChargeSectionID sets the "charge_section_id" field.
func (m *AsUnitMutation) SetChargeSectionID(i int64) {
	m.charge_section_id = &i
	m.addcharge_section_id = nil
}

// ChargeSectionID returns the value of the "charge_section_id" field in the mutation.
func (m *AsUnitMutation) ChargeSectionID() (r int64, exists bool) {
	v := m.charge_section_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeSectionID returns the old "charge_section_id" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldChargeSectionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeSectionID: %w", err)
	}
	return oldValue.ChargeSectionID, nil
}

// AddChargeSectionID adds i to the "charge_section_id" field.
func (m *AsUnitMutation) AddChargeSectionID(i int64) {
	if m.addcharge_section_id != nil {
		*m.addcharge_section_id += i
	} else {
		m.addcharge_section_id = &i
	}
}

// AddedChargeSectionID returns the value that was added to the "charge_section_id" field in this mutation.
func (m *AsUnitMutation) AddedChargeSectionID() (r int64, exists bool) {
	v := m.addcharge_section_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearChargeSectionID clears the value of the "charge_section_id" field.
func (m *AsUnitMutation) ClearChargeSectionID() {
	m.charge_section_id = nil
	m.addcharge_section_id = nil
	m.clearedFields[asunit.FieldChargeSectionID] = struct{}{}
}

// ChargeSectionIDCleared returns if the "charge_section_id" field was cleared in this mutation.
func (m *AsUnitMutation) ChargeSectionIDCleared() bool {
	_, ok := m.clearedFields[asunit.FieldChargeSectionID]
	return ok
}

// ResetChargeSectionID resets all changes to the "charge_section_id" field.
func (m *AsUnitMutation) ResetChargeSectionID() {
	m.charge_section_id = nil
	m.addcharge_section_id = nil
	delete(m.clearedFields, asunit.FieldChargeSectionID)
}

// SetChargeSectionCode sets the "charge_section_code" field.
func (m *AsUnitMutation) SetChargeSectionCode(s string) {
	m.charge_section_code = &s
}

// ChargeSectionCode returns the value of the "charge_section_code" field in the mutation.
func (m *AsUnitMutation) ChargeSectionCode() (r string, exists bool) {
	v := m.charge_section_code
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeSectionCode returns the old "charge_section_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldChargeSectionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeSectionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeSectionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeSectionCode: %w", err)
	}
	return oldValue.ChargeSectionCode, nil
}

// ClearChargeSectionCode clears the value of the "charge_section_code" field.
func (m *AsUnitMutation) ClearChargeSectionCode() {
	m.charge_section_code = nil
	m.clearedFields[asunit.FieldChargeSectionCode] = struct{}{}
}

// ChargeSectionCodeCleared returns if the "charge_section_code" field was cleared in this mutation.
func (m *AsUnitMutation) ChargeSectionCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldChargeSectionCode]
	return ok
}

// ResetChargeSectionCode resets all changes to the "charge_section_code" field.
func (m *AsUnitMutation) ResetChargeSectionCode() {
	m.charge_section_code = nil
	delete(m.clearedFields, asunit.FieldChargeSectionCode)
}

// SetChargeSectionName sets the "charge_section_name" field.
func (m *AsUnitMutation) SetChargeSectionName(s string) {
	m.charge_section_name = &s
}

// ChargeSectionName returns the value of the "charge_section_name" field in the mutation.
func (m *AsUnitMutation) ChargeSectionName() (r string, exists bool) {
	v := m.charge_section_name
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeSectionName returns the old "charge_section_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldChargeSectionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeSectionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeSectionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeSectionName: %w", err)
	}
	return oldValue.ChargeSectionName, nil
}

// ClearChargeSectionName clears the value of the "charge_section_name" field.
func (m *AsUnitMutation) ClearChargeSectionName() {
	m.charge_section_name = nil
	m.clearedFields[asunit.FieldChargeSectionName] = struct{}{}
}

// ChargeSectionNameCleared returns if the "charge_section_name" field was cleared in this mutation.
func (m *AsUnitMutation) ChargeSectionNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldChargeSectionName]
	return ok
}

// ResetChargeSectionName resets all changes to the "charge_section_name" field.
func (m *AsUnitMutation) ResetChargeSectionName() {
	m.charge_section_name = nil
	delete(m.clearedFields, asunit.FieldChargeSectionName)
}

// SetLocalFinancialCode sets the "local_financial_code" field.
func (m *AsUnitMutation) SetLocalFinancialCode(s string) {
	m.local_financial_code = &s
}

// LocalFinancialCode returns the value of the "local_financial_code" field in the mutation.
func (m *AsUnitMutation) LocalFinancialCode() (r string, exists bool) {
	v := m.local_financial_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalFinancialCode returns the old "local_financial_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldLocalFinancialCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalFinancialCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalFinancialCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalFinancialCode: %w", err)
	}
	return oldValue.LocalFinancialCode, nil
}

// ClearLocalFinancialCode clears the value of the "local_financial_code" field.
func (m *AsUnitMutation) ClearLocalFinancialCode() {
	m.local_financial_code = nil
	m.clearedFields[asunit.FieldLocalFinancialCode] = struct{}{}
}

// LocalFinancialCodeCleared returns if the "local_financial_code" field was cleared in this mutation.
func (m *AsUnitMutation) LocalFinancialCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldLocalFinancialCode]
	return ok
}

// ResetLocalFinancialCode resets all changes to the "local_financial_code" field.
func (m *AsUnitMutation) ResetLocalFinancialCode() {
	m.local_financial_code = nil
	delete(m.clearedFields, asunit.FieldLocalFinancialCode)
}

// SetLocalFinancialName sets the "local_financial_name" field.
func (m *AsUnitMutation) SetLocalFinancialName(s string) {
	m.local_financial_name = &s
}

// LocalFinancialName returns the value of the "local_financial_name" field in the mutation.
func (m *AsUnitMutation) LocalFinancialName() (r string, exists bool) {
	v := m.local_financial_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalFinancialName returns the old "local_financial_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldLocalFinancialName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalFinancialName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalFinancialName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalFinancialName: %w", err)
	}
	return oldValue.LocalFinancialName, nil
}

// ClearLocalFinancialName clears the value of the "local_financial_name" field.
func (m *AsUnitMutation) ClearLocalFinancialName() {
	m.local_financial_name = nil
	m.clearedFields[asunit.FieldLocalFinancialName] = struct{}{}
}

// LocalFinancialNameCleared returns if the "local_financial_name" field was cleared in this mutation.
func (m *AsUnitMutation) LocalFinancialNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldLocalFinancialName]
	return ok
}

// ResetLocalFinancialName resets all changes to the "local_financial_name" field.
func (m *AsUnitMutation) ResetLocalFinancialName() {
	m.local_financial_name = nil
	delete(m.clearedFields, asunit.FieldLocalFinancialName)
}

// SetLocalFinancialID sets the "local_financial_id" field.
func (m *AsUnitMutation) SetLocalFinancialID(s string) {
	m.local_financial_id = &s
}

// LocalFinancialID returns the value of the "local_financial_id" field in the mutation.
func (m *AsUnitMutation) LocalFinancialID() (r string, exists bool) {
	v := m.local_financial_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalFinancialID returns the old "local_financial_id" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldLocalFinancialID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalFinancialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalFinancialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalFinancialID: %w", err)
	}
	return oldValue.LocalFinancialID, nil
}

// ClearLocalFinancialID clears the value of the "local_financial_id" field.
func (m *AsUnitMutation) ClearLocalFinancialID() {
	m.local_financial_id = nil
	m.clearedFields[asunit.FieldLocalFinancialID] = struct{}{}
}

// LocalFinancialIDCleared returns if the "local_financial_id" field was cleared in this mutation.
func (m *AsUnitMutation) LocalFinancialIDCleared() bool {
	_, ok := m.clearedFields[asunit.FieldLocalFinancialID]
	return ok
}

// ResetLocalFinancialID resets all changes to the "local_financial_id" field.
func (m *AsUnitMutation) ResetLocalFinancialID() {
	m.local_financial_id = nil
	delete(m.clearedFields, asunit.FieldLocalFinancialID)
}

// SetOfficeAdministrationCode sets the "office_administration_code" field.
func (m *AsUnitMutation) SetOfficeAdministrationCode(s string) {
	m.office_administration_code = &s
}

// OfficeAdministrationCode returns the value of the "office_administration_code" field in the mutation.
func (m *AsUnitMutation) OfficeAdministrationCode() (r string, exists bool) {
	v := m.office_administration_code
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeAdministrationCode returns the old "office_administration_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldOfficeAdministrationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeAdministrationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeAdministrationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeAdministrationCode: %w", err)
	}
	return oldValue.OfficeAdministrationCode, nil
}

// ClearOfficeAdministrationCode clears the value of the "office_administration_code" field.
func (m *AsUnitMutation) ClearOfficeAdministrationCode() {
	m.office_administration_code = nil
	m.clearedFields[asunit.FieldOfficeAdministrationCode] = struct{}{}
}

// OfficeAdministrationCodeCleared returns if the "office_administration_code" field was cleared in this mutation.
func (m *AsUnitMutation) OfficeAdministrationCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldOfficeAdministrationCode]
	return ok
}

// ResetOfficeAdministrationCode resets all changes to the "office_administration_code" field.
func (m *AsUnitMutation) ResetOfficeAdministrationCode() {
	m.office_administration_code = nil
	delete(m.clearedFields, asunit.FieldOfficeAdministrationCode)
}

// SetOfficeAdministrationName sets the "office_administration_name" field.
func (m *AsUnitMutation) SetOfficeAdministrationName(s string) {
	m.office_administration_name = &s
}

// OfficeAdministrationName returns the value of the "office_administration_name" field in the mutation.
func (m *AsUnitMutation) OfficeAdministrationName() (r string, exists bool) {
	v := m.office_administration_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficeAdministrationName returns the old "office_administration_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldOfficeAdministrationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficeAdministrationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficeAdministrationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficeAdministrationName: %w", err)
	}
	return oldValue.OfficeAdministrationName, nil
}

// ClearOfficeAdministrationName clears the value of the "office_administration_name" field.
func (m *AsUnitMutation) ClearOfficeAdministrationName() {
	m.office_administration_name = nil
	m.clearedFields[asunit.FieldOfficeAdministrationName] = struct{}{}
}

// OfficeAdministrationNameCleared returns if the "office_administration_name" field was cleared in this mutation.
func (m *AsUnitMutation) OfficeAdministrationNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldOfficeAdministrationName]
	return ok
}

// ResetOfficeAdministrationName resets all changes to the "office_administration_name" field.
func (m *AsUnitMutation) ResetOfficeAdministrationName() {
	m.office_administration_name = nil
	delete(m.clearedFields, asunit.FieldOfficeAdministrationName)
}

// SetAdministrationDivisionCode sets the "administration_division_code" field.
func (m *AsUnitMutation) SetAdministrationDivisionCode(s string) {
	m.administration_division_code = &s
}

// AdministrationDivisionCode returns the value of the "administration_division_code" field in the mutation.
func (m *AsUnitMutation) AdministrationDivisionCode() (r string, exists bool) {
	v := m.administration_division_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAdministrationDivisionCode returns the old "administration_division_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldAdministrationDivisionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdministrationDivisionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdministrationDivisionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdministrationDivisionCode: %w", err)
	}
	return oldValue.AdministrationDivisionCode, nil
}

// ClearAdministrationDivisionCode clears the value of the "administration_division_code" field.
func (m *AsUnitMutation) ClearAdministrationDivisionCode() {
	m.administration_division_code = nil
	m.clearedFields[asunit.FieldAdministrationDivisionCode] = struct{}{}
}

// AdministrationDivisionCodeCleared returns if the "administration_division_code" field was cleared in this mutation.
func (m *AsUnitMutation) AdministrationDivisionCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldAdministrationDivisionCode]
	return ok
}

// ResetAdministrationDivisionCode resets all changes to the "administration_division_code" field.
func (m *AsUnitMutation) ResetAdministrationDivisionCode() {
	m.administration_division_code = nil
	delete(m.clearedFields, asunit.FieldAdministrationDivisionCode)
}

// SetAdministrationDivisionName sets the "administration_division_name" field.
func (m *AsUnitMutation) SetAdministrationDivisionName(s string) {
	m.administration_division_name = &s
}

// AdministrationDivisionName returns the value of the "administration_division_name" field in the mutation.
func (m *AsUnitMutation) AdministrationDivisionName() (r string, exists bool) {
	v := m.administration_division_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAdministrationDivisionName returns the old "administration_division_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldAdministrationDivisionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdministrationDivisionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdministrationDivisionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdministrationDivisionName: %w", err)
	}
	return oldValue.AdministrationDivisionName, nil
}

// ClearAdministrationDivisionName clears the value of the "administration_division_name" field.
func (m *AsUnitMutation) ClearAdministrationDivisionName() {
	m.administration_division_name = nil
	m.clearedFields[asunit.FieldAdministrationDivisionName] = struct{}{}
}

// AdministrationDivisionNameCleared returns if the "administration_division_name" field was cleared in this mutation.
func (m *AsUnitMutation) AdministrationDivisionNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldAdministrationDivisionName]
	return ok
}

// ResetAdministrationDivisionName resets all changes to the "administration_division_name" field.
func (m *AsUnitMutation) ResetAdministrationDivisionName() {
	m.administration_division_name = nil
	delete(m.clearedFields, asunit.FieldAdministrationDivisionName)
}

// SetBudgetCode sets the "budget_code" field.
func (m *AsUnitMutation) SetBudgetCode(i int64) {
	m.budget_code = &i
	m.addbudget_code = nil
}

// BudgetCode returns the value of the "budget_code" field in the mutation.
func (m *AsUnitMutation) BudgetCode() (r int64, exists bool) {
	v := m.budget_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBudgetCode returns the old "budget_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldBudgetCode(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBudgetCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBudgetCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudgetCode: %w", err)
	}
	return oldValue.BudgetCode, nil
}

// AddBudgetCode adds i to the "budget_code" field.
func (m *AsUnitMutation) AddBudgetCode(i int64) {
	if m.addbudget_code != nil {
		*m.addbudget_code += i
	} else {
		m.addbudget_code = &i
	}
}

// AddedBudgetCode returns the value that was added to the "budget_code" field in this mutation.
func (m *AsUnitMutation) AddedBudgetCode() (r int64, exists bool) {
	v := m.addbudget_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearBudgetCode clears the value of the "budget_code" field.
func (m *AsUnitMutation) ClearBudgetCode() {
	m.budget_code = nil
	m.addbudget_code = nil
	m.clearedFields[asunit.FieldBudgetCode] = struct{}{}
}

// BudgetCodeCleared returns if the "budget_code" field was cleared in this mutation.
func (m *AsUnitMutation) BudgetCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldBudgetCode]
	return ok
}

// ResetBudgetCode resets all changes to the "budget_code" field.
func (m *AsUnitMutation) ResetBudgetCode() {
	m.budget_code = nil
	m.addbudget_code = nil
	delete(m.clearedFields, asunit.FieldBudgetCode)
}

// SetCollegeCode sets the "college_code" field.
func (m *AsUnitMutation) SetCollegeCode(s string) {
	m.college_code = &s
}

// CollegeCode returns the value of the "college_code" field in the mutation.
func (m *AsUnitMutation) CollegeCode() (r string, exists bool) {
	v := m.college_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCollegeCode returns the old "college_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldCollegeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollegeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollegeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollegeCode: %w", err)
	}
	return oldValue.CollegeCode, nil
}

// ClearCollegeCode clears the value of the "college_code" field.
func (m *AsUnitMutation) ClearCollegeCode() {
	m.college_code = nil
	m.clearedFields[asunit.FieldCollegeCode] = struct{}{}
}

// CollegeCodeCleared returns if the "college_code" field was cleared in this mutation.
func (m *AsUnitMutation) CollegeCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldCollegeCode]
	return ok
}

// ResetCollegeCode resets all changes to the "college_code" field.
func (m *AsUnitMutation) ResetCollegeCode() {
	m.college_code = nil
	delete(m.clearedFields, asunit.FieldCollegeCode)
}

// SetOrganizationCode sets the "organization_code" field.
func (m *AsUnitMutation) SetOrganizationCode(s string) {
	m.organization_code = &s
}

// OrganizationCode returns the value of the "organization_code" field in the mutation.
func (m *AsUnitMutation) OrganizationCode() (r string, exists bool) {
	v := m.organization_code
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationCode returns the old "organization_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldOrganizationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationCode: %w", err)
	}
	return oldValue.OrganizationCode, nil
}

// ClearOrganizationCode clears the value of the "organization_code" field.
func (m *AsUnitMutation) ClearOrganizationCode() {
	m.organization_code = nil
	m.clearedFields[asunit.FieldOrganizationCode] = struct{}{}
}

// OrganizationCodeCleared returns if the "organization_code" field was cleared in this mutation.
func (m *AsUnitMutation) OrganizationCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldOrganizationCode]
	return ok
}

// ResetOrganizationCode resets all changes to the "organization_code" field.
func (m *AsUnitMutation) ResetOrganizationCode() {
	m.organization_code = nil
	delete(m.clearedFields, asunit.FieldOrganizationCode)
}

// SetUnitTypeCode sets the "unit_type_code" field.
func (m *AsUnitMutation) SetUnitTypeCode(i int64) {
	m.unit_type_code = &i
	m.addunit_type_code = nil
}

// UnitTypeCode returns the value of the "unit_type_code" field in the mutation.
func (m *AsUnitMutation) UnitTypeCode() (r int64, exists bool) {
	v := m.unit_type_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitTypeCode returns the old "unit_type_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUnitTypeCode(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitTypeCode: %w", err)
	}
	return oldValue.UnitTypeCode, nil
}

// AddUnitTypeCode adds i to the "unit_type_code" field.
func (m *AsUnitMutation) AddUnitTypeCode(i int64) {
	if m.addunit_type_code != nil {
		*m.addunit_type_code += i
	} else {
		m.addunit_type_code = &i
	}
}

// AddedUnitTypeCode returns the value that was added to the "unit_type_code" field in this mutation.
func (m *AsUnitMutation) AddedUnitTypeCode() (r int64, exists bool) {
	v := m.addunit_type_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitTypeCode clears the value of the "unit_type_code" field.
func (m *AsUnitMutation) ClearUnitTypeCode() {
	m.unit_type_code = nil
	m.addunit_type_code = nil
	m.clearedFields[asunit.FieldUnitTypeCode] = struct{}{}
}

// UnitTypeCodeCleared returns if the "unit_type_code" field was cleared in this mutation.
func (m *AsUnitMutation) UnitTypeCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldUnitTypeCode]
	return ok
}

// ResetUnitTypeCode resets all changes to the "unit_type_code" field.
func (m *AsUnitMutation) ResetUnitTypeCode() {
	m.unit_type_code = nil
	m.addunit_type_code = nil
	delete(m.clearedFields, asunit.FieldUnitTypeCode)
}

// SetUnitTypeName sets the "unit_type_name" field.
func (m *AsUnitMutation) SetUnitTypeName(i int64) {
	m.unit_type_name = &i
	m.addunit_type_name = nil
}

// UnitTypeName returns the value of the "unit_type_name" field in the mutation.
func (m *AsUnitMutation) UnitTypeName() (r int64, exists bool) {
	v := m.unit_type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitTypeName returns the old "unit_type_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUnitTypeName(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitTypeName: %w", err)
	}
	return oldValue.UnitTypeName, nil
}

// AddUnitTypeName adds i to the "unit_type_name" field.
func (m *AsUnitMutation) AddUnitTypeName(i int64) {
	if m.addunit_type_name != nil {
		*m.addunit_type_name += i
	} else {
		m.addunit_type_name = &i
	}
}

// AddedUnitTypeName returns the value that was added to the "unit_type_name" field in this mutation.
func (m *AsUnitMutation) AddedUnitTypeName() (r int64, exists bool) {
	v := m.addunit_type_name
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitTypeName clears the value of the "unit_type_name" field.
func (m *AsUnitMutation) ClearUnitTypeName() {
	m.unit_type_name = nil
	m.addunit_type_name = nil
	m.clearedFields[asunit.FieldUnitTypeName] = struct{}{}
}

// UnitTypeNameCleared returns if the "unit_type_name" field was cleared in this mutation.
func (m *AsUnitMutation) UnitTypeNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldUnitTypeName]
	return ok
}

// ResetUnitTypeName resets all changes to the "unit_type_name" field.
func (m *AsUnitMutation) ResetUnitTypeName() {
	m.unit_type_name = nil
	m.addunit_type_name = nil
	delete(m.clearedFields, asunit.FieldUnitTypeName)
}

// SetUnitBasicProperty sets the "unit_basic_property" field.
func (m *AsUnitMutation) SetUnitBasicProperty(i int64) {
	m.unit_basic_property = &i
	m.addunit_basic_property = nil
}

// UnitBasicProperty returns the value of the "unit_basic_property" field in the mutation.
func (m *AsUnitMutation) UnitBasicProperty() (r int64, exists bool) {
	v := m.unit_basic_property
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitBasicProperty returns the old "unit_basic_property" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUnitBasicProperty(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitBasicProperty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitBasicProperty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitBasicProperty: %w", err)
	}
	return oldValue.UnitBasicProperty, nil
}

// AddUnitBasicProperty adds i to the "unit_basic_property" field.
func (m *AsUnitMutation) AddUnitBasicProperty(i int64) {
	if m.addunit_basic_property != nil {
		*m.addunit_basic_property += i
	} else {
		m.addunit_basic_property = &i
	}
}

// AddedUnitBasicProperty returns the value that was added to the "unit_basic_property" field in this mutation.
func (m *AsUnitMutation) AddedUnitBasicProperty() (r int64, exists bool) {
	v := m.addunit_basic_property
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitBasicProperty clears the value of the "unit_basic_property" field.
func (m *AsUnitMutation) ClearUnitBasicProperty() {
	m.unit_basic_property = nil
	m.addunit_basic_property = nil
	m.clearedFields[asunit.FieldUnitBasicProperty] = struct{}{}
}

// UnitBasicPropertyCleared returns if the "unit_basic_property" field was cleared in this mutation.
func (m *AsUnitMutation) UnitBasicPropertyCleared() bool {
	_, ok := m.clearedFields[asunit.FieldUnitBasicProperty]
	return ok
}

// ResetUnitBasicProperty resets all changes to the "unit_basic_property" field.
func (m *AsUnitMutation) ResetUnitBasicProperty() {
	m.unit_basic_property = nil
	m.addunit_basic_property = nil
	delete(m.clearedFields, asunit.FieldUnitBasicProperty)
}

// SetSocialCreditCode sets the "social_credit_code" field.
func (m *AsUnitMutation) SetSocialCreditCode(s string) {
	m.social_credit_code = &s
}

// SocialCreditCode returns the value of the "social_credit_code" field in the mutation.
func (m *AsUnitMutation) SocialCreditCode() (r string, exists bool) {
	v := m.social_credit_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialCreditCode returns the old "social_credit_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldSocialCreditCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialCreditCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialCreditCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialCreditCode: %w", err)
	}
	return oldValue.SocialCreditCode, nil
}

// ClearSocialCreditCode clears the value of the "social_credit_code" field.
func (m *AsUnitMutation) ClearSocialCreditCode() {
	m.social_credit_code = nil
	m.clearedFields[asunit.FieldSocialCreditCode] = struct{}{}
}

// SocialCreditCodeCleared returns if the "social_credit_code" field was cleared in this mutation.
func (m *AsUnitMutation) SocialCreditCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldSocialCreditCode]
	return ok
}

// ResetSocialCreditCode resets all changes to the "social_credit_code" field.
func (m *AsUnitMutation) ResetSocialCreditCode() {
	m.social_credit_code = nil
	delete(m.clearedFields, asunit.FieldSocialCreditCode)
}

// SetBudgetUnitName sets the "budget_unit_name" field.
func (m *AsUnitMutation) SetBudgetUnitName(s string) {
	m.budget_unit_name = &s
}

// BudgetUnitName returns the value of the "budget_unit_name" field in the mutation.
func (m *AsUnitMutation) BudgetUnitName() (r string, exists bool) {
	v := m.budget_unit_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBudgetUnitName returns the old "budget_unit_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldBudgetUnitName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBudgetUnitName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBudgetUnitName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudgetUnitName: %w", err)
	}
	return oldValue.BudgetUnitName, nil
}

// ClearBudgetUnitName clears the value of the "budget_unit_name" field.
func (m *AsUnitMutation) ClearBudgetUnitName() {
	m.budget_unit_name = nil
	m.clearedFields[asunit.FieldBudgetUnitName] = struct{}{}
}

// BudgetUnitNameCleared returns if the "budget_unit_name" field was cleared in this mutation.
func (m *AsUnitMutation) BudgetUnitNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldBudgetUnitName]
	return ok
}

// ResetBudgetUnitName resets all changes to the "budget_unit_name" field.
func (m *AsUnitMutation) ResetBudgetUnitName() {
	m.budget_unit_name = nil
	delete(m.clearedFields, asunit.FieldBudgetUnitName)
}

// SetBudgetUnitCode sets the "budget_unit_code" field.
func (m *AsUnitMutation) SetBudgetUnitCode(s string) {
	m.budget_unit_code = &s
}

// BudgetUnitCode returns the value of the "budget_unit_code" field in the mutation.
func (m *AsUnitMutation) BudgetUnitCode() (r string, exists bool) {
	v := m.budget_unit_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBudgetUnitCode returns the old "budget_unit_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldBudgetUnitCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBudgetUnitCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBudgetUnitCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudgetUnitCode: %w", err)
	}
	return oldValue.BudgetUnitCode, nil
}

// ClearBudgetUnitCode clears the value of the "budget_unit_code" field.
func (m *AsUnitMutation) ClearBudgetUnitCode() {
	m.budget_unit_code = nil
	m.clearedFields[asunit.FieldBudgetUnitCode] = struct{}{}
}

// BudgetUnitCodeCleared returns if the "budget_unit_code" field was cleared in this mutation.
func (m *AsUnitMutation) BudgetUnitCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldBudgetUnitCode]
	return ok
}

// ResetBudgetUnitCode resets all changes to the "budget_unit_code" field.
func (m *AsUnitMutation) ResetBudgetUnitCode() {
	m.budget_unit_code = nil
	delete(m.clearedFields, asunit.FieldBudgetUnitCode)
}

// SetBudgetManagementLevel sets the "budget_management_level" field.
func (m *AsUnitMutation) SetBudgetManagementLevel(i int64) {
	m.budget_management_level = &i
	m.addbudget_management_level = nil
}

// BudgetManagementLevel returns the value of the "budget_management_level" field in the mutation.
func (m *AsUnitMutation) BudgetManagementLevel() (r int64, exists bool) {
	v := m.budget_management_level
	if v == nil {
		return
	}
	return *v, true
}

// OldBudgetManagementLevel returns the old "budget_management_level" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldBudgetManagementLevel(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBudgetManagementLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBudgetManagementLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudgetManagementLevel: %w", err)
	}
	return oldValue.BudgetManagementLevel, nil
}

// AddBudgetManagementLevel adds i to the "budget_management_level" field.
func (m *AsUnitMutation) AddBudgetManagementLevel(i int64) {
	if m.addbudget_management_level != nil {
		*m.addbudget_management_level += i
	} else {
		m.addbudget_management_level = &i
	}
}

// AddedBudgetManagementLevel returns the value that was added to the "budget_management_level" field in this mutation.
func (m *AsUnitMutation) AddedBudgetManagementLevel() (r int64, exists bool) {
	v := m.addbudget_management_level
	if v == nil {
		return
	}
	return *v, true
}

// ClearBudgetManagementLevel clears the value of the "budget_management_level" field.
func (m *AsUnitMutation) ClearBudgetManagementLevel() {
	m.budget_management_level = nil
	m.addbudget_management_level = nil
	m.clearedFields[asunit.FieldBudgetManagementLevel] = struct{}{}
}

// BudgetManagementLevelCleared returns if the "budget_management_level" field was cleared in this mutation.
func (m *AsUnitMutation) BudgetManagementLevelCleared() bool {
	_, ok := m.clearedFields[asunit.FieldBudgetManagementLevel]
	return ok
}

// ResetBudgetManagementLevel resets all changes to the "budget_management_level" field.
func (m *AsUnitMutation) ResetBudgetManagementLevel() {
	m.budget_management_level = nil
	m.addbudget_management_level = nil
	delete(m.clearedFields, asunit.FieldBudgetManagementLevel)
}

// SetFirmName sets the "firm_name" field.
func (m *AsUnitMutation) SetFirmName(s string) {
	m.firm_name = &s
}

// FirmName returns the value of the "firm_name" field in the mutation.
func (m *AsUnitMutation) FirmName() (r string, exists bool) {
	v := m.firm_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirmName returns the old "firm_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldFirmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirmName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirmName: %w", err)
	}
	return oldValue.FirmName, nil
}

// ClearFirmName clears the value of the "firm_name" field.
func (m *AsUnitMutation) ClearFirmName() {
	m.firm_name = nil
	m.clearedFields[asunit.FieldFirmName] = struct{}{}
}

// FirmNameCleared returns if the "firm_name" field was cleared in this mutation.
func (m *AsUnitMutation) FirmNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldFirmName]
	return ok
}

// ResetFirmName resets all changes to the "firm_name" field.
func (m *AsUnitMutation) ResetFirmName() {
	m.firm_name = nil
	delete(m.clearedFields, asunit.FieldFirmName)
}

// SetFirmCode sets the "firm_code" field.
func (m *AsUnitMutation) SetFirmCode(s string) {
	m.firm_code = &s
}

// FirmCode returns the value of the "firm_code" field in the mutation.
func (m *AsUnitMutation) FirmCode() (r string, exists bool) {
	v := m.firm_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFirmCode returns the old "firm_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldFirmCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirmCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirmCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirmCode: %w", err)
	}
	return oldValue.FirmCode, nil
}

// ClearFirmCode clears the value of the "firm_code" field.
func (m *AsUnitMutation) ClearFirmCode() {
	m.firm_code = nil
	m.clearedFields[asunit.FieldFirmCode] = struct{}{}
}

// FirmCodeCleared returns if the "firm_code" field was cleared in this mutation.
func (m *AsUnitMutation) FirmCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldFirmCode]
	return ok
}

// ResetFirmCode resets all changes to the "firm_code" field.
func (m *AsUnitMutation) ResetFirmCode() {
	m.firm_code = nil
	delete(m.clearedFields, asunit.FieldFirmCode)
}

// SetTelephoneNumber sets the "telephone_number" field.
func (m *AsUnitMutation) SetTelephoneNumber(s string) {
	m.telephone_number = &s
}

// TelephoneNumber returns the value of the "telephone_number" field in the mutation.
func (m *AsUnitMutation) TelephoneNumber() (r string, exists bool) {
	v := m.telephone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephoneNumber returns the old "telephone_number" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldTelephoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelephoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelephoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephoneNumber: %w", err)
	}
	return oldValue.TelephoneNumber, nil
}

// ClearTelephoneNumber clears the value of the "telephone_number" field.
func (m *AsUnitMutation) ClearTelephoneNumber() {
	m.telephone_number = nil
	m.clearedFields[asunit.FieldTelephoneNumber] = struct{}{}
}

// TelephoneNumberCleared returns if the "telephone_number" field was cleared in this mutation.
func (m *AsUnitMutation) TelephoneNumberCleared() bool {
	_, ok := m.clearedFields[asunit.FieldTelephoneNumber]
	return ok
}

// ResetTelephoneNumber resets all changes to the "telephone_number" field.
func (m *AsUnitMutation) ResetTelephoneNumber() {
	m.telephone_number = nil
	delete(m.clearedFields, asunit.FieldTelephoneNumber)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *AsUnitMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *AsUnitMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *AsUnitMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[asunit.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *AsUnitMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[asunit.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *AsUnitMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, asunit.FieldPhoneNumber)
}

// SetFaxNumber sets the "fax_number" field.
func (m *AsUnitMutation) SetFaxNumber(s string) {
	m.fax_number = &s
}

// FaxNumber returns the value of the "fax_number" field in the mutation.
func (m *AsUnitMutation) FaxNumber() (r string, exists bool) {
	v := m.fax_number
	if v == nil {
		return
	}
	return *v, true
}

// OldFaxNumber returns the old "fax_number" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldFaxNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaxNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaxNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaxNumber: %w", err)
	}
	return oldValue.FaxNumber, nil
}

// ClearFaxNumber clears the value of the "fax_number" field.
func (m *AsUnitMutation) ClearFaxNumber() {
	m.fax_number = nil
	m.clearedFields[asunit.FieldFaxNumber] = struct{}{}
}

// FaxNumberCleared returns if the "fax_number" field was cleared in this mutation.
func (m *AsUnitMutation) FaxNumberCleared() bool {
	_, ok := m.clearedFields[asunit.FieldFaxNumber]
	return ok
}

// ResetFaxNumber resets all changes to the "fax_number" field.
func (m *AsUnitMutation) ResetFaxNumber() {
	m.fax_number = nil
	delete(m.clearedFields, asunit.FieldFaxNumber)
}

// SetEmailAddress sets the "email_address" field.
func (m *AsUnitMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *AsUnitMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ClearEmailAddress clears the value of the "email_address" field.
func (m *AsUnitMutation) ClearEmailAddress() {
	m.email_address = nil
	m.clearedFields[asunit.FieldEmailAddress] = struct{}{}
}

// EmailAddressCleared returns if the "email_address" field was cleared in this mutation.
func (m *AsUnitMutation) EmailAddressCleared() bool {
	_, ok := m.clearedFields[asunit.FieldEmailAddress]
	return ok
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *AsUnitMutation) ResetEmailAddress() {
	m.email_address = nil
	delete(m.clearedFields, asunit.FieldEmailAddress)
}

// SetProvince sets the "province" field.
func (m *AsUnitMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *AsUnitMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *AsUnitMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[asunit.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *AsUnitMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[asunit.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *AsUnitMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, asunit.FieldProvince)
}

// SetCity sets the "city" field.
func (m *AsUnitMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AsUnitMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *AsUnitMutation) ClearCity() {
	m.city = nil
	m.clearedFields[asunit.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *AsUnitMutation) CityCleared() bool {
	_, ok := m.clearedFields[asunit.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *AsUnitMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, asunit.FieldCity)
}

// SetCounty sets the "county" field.
func (m *AsUnitMutation) SetCounty(s string) {
	m.county = &s
}

// County returns the value of the "county" field in the mutation.
func (m *AsUnitMutation) County() (r string, exists bool) {
	v := m.county
	if v == nil {
		return
	}
	return *v, true
}

// OldCounty returns the old "county" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldCounty(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCounty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCounty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCounty: %w", err)
	}
	return oldValue.County, nil
}

// ClearCounty clears the value of the "county" field.
func (m *AsUnitMutation) ClearCounty() {
	m.county = nil
	m.clearedFields[asunit.FieldCounty] = struct{}{}
}

// CountyCleared returns if the "county" field was cleared in this mutation.
func (m *AsUnitMutation) CountyCleared() bool {
	_, ok := m.clearedFields[asunit.FieldCounty]
	return ok
}

// ResetCounty resets all changes to the "county" field.
func (m *AsUnitMutation) ResetCounty() {
	m.county = nil
	delete(m.clearedFields, asunit.FieldCounty)
}

// SetStreetAddress sets the "street_address" field.
func (m *AsUnitMutation) SetStreetAddress(s string) {
	m.street_address = &s
}

// StreetAddress returns the value of the "street_address" field in the mutation.
func (m *AsUnitMutation) StreetAddress() (r string, exists bool) {
	v := m.street_address
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetAddress returns the old "street_address" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldStreetAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetAddress: %w", err)
	}
	return oldValue.StreetAddress, nil
}

// ClearStreetAddress clears the value of the "street_address" field.
func (m *AsUnitMutation) ClearStreetAddress() {
	m.street_address = nil
	m.clearedFields[asunit.FieldStreetAddress] = struct{}{}
}

// StreetAddressCleared returns if the "street_address" field was cleared in this mutation.
func (m *AsUnitMutation) StreetAddressCleared() bool {
	_, ok := m.clearedFields[asunit.FieldStreetAddress]
	return ok
}

// ResetStreetAddress resets all changes to the "street_address" field.
func (m *AsUnitMutation) ResetStreetAddress() {
	m.street_address = nil
	delete(m.clearedFields, asunit.FieldStreetAddress)
}

// SetPostalCode sets the "postal_code" field.
func (m *AsUnitMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *AsUnitMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *AsUnitMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[asunit.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *AsUnitMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *AsUnitMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, asunit.FieldPostalCode)
}

// SetFundSupplyModeName sets the "fund_supply_mode_name" field.
func (m *AsUnitMutation) SetFundSupplyModeName(i int64) {
	m.fund_supply_mode_name = &i
	m.addfund_supply_mode_name = nil
}

// FundSupplyModeName returns the value of the "fund_supply_mode_name" field in the mutation.
func (m *AsUnitMutation) FundSupplyModeName() (r int64, exists bool) {
	v := m.fund_supply_mode_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFundSupplyModeName returns the old "fund_supply_mode_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldFundSupplyModeName(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFundSupplyModeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFundSupplyModeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundSupplyModeName: %w", err)
	}
	return oldValue.FundSupplyModeName, nil
}

// AddFundSupplyModeName adds i to the "fund_supply_mode_name" field.
func (m *AsUnitMutation) AddFundSupplyModeName(i int64) {
	if m.addfund_supply_mode_name != nil {
		*m.addfund_supply_mode_name += i
	} else {
		m.addfund_supply_mode_name = &i
	}
}

// AddedFundSupplyModeName returns the value that was added to the "fund_supply_mode_name" field in this mutation.
func (m *AsUnitMutation) AddedFundSupplyModeName() (r int64, exists bool) {
	v := m.addfund_supply_mode_name
	if v == nil {
		return
	}
	return *v, true
}

// ClearFundSupplyModeName clears the value of the "fund_supply_mode_name" field.
func (m *AsUnitMutation) ClearFundSupplyModeName() {
	m.fund_supply_mode_name = nil
	m.addfund_supply_mode_name = nil
	m.clearedFields[asunit.FieldFundSupplyModeName] = struct{}{}
}

// FundSupplyModeNameCleared returns if the "fund_supply_mode_name" field was cleared in this mutation.
func (m *AsUnitMutation) FundSupplyModeNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldFundSupplyModeName]
	return ok
}

// ResetFundSupplyModeName resets all changes to the "fund_supply_mode_name" field.
func (m *AsUnitMutation) ResetFundSupplyModeName() {
	m.fund_supply_mode_name = nil
	m.addfund_supply_mode_name = nil
	delete(m.clearedFields, asunit.FieldFundSupplyModeName)
}

// SetFundSupplyModeCode sets the "fund_supply_mode_code" field.
func (m *AsUnitMutation) SetFundSupplyModeCode(i int64) {
	m.fund_supply_mode_code = &i
	m.addfund_supply_mode_code = nil
}

// FundSupplyModeCode returns the value of the "fund_supply_mode_code" field in the mutation.
func (m *AsUnitMutation) FundSupplyModeCode() (r int64, exists bool) {
	v := m.fund_supply_mode_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFundSupplyModeCode returns the old "fund_supply_mode_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldFundSupplyModeCode(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFundSupplyModeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFundSupplyModeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundSupplyModeCode: %w", err)
	}
	return oldValue.FundSupplyModeCode, nil
}

// AddFundSupplyModeCode adds i to the "fund_supply_mode_code" field.
func (m *AsUnitMutation) AddFundSupplyModeCode(i int64) {
	if m.addfund_supply_mode_code != nil {
		*m.addfund_supply_mode_code += i
	} else {
		m.addfund_supply_mode_code = &i
	}
}

// AddedFundSupplyModeCode returns the value that was added to the "fund_supply_mode_code" field in this mutation.
func (m *AsUnitMutation) AddedFundSupplyModeCode() (r int64, exists bool) {
	v := m.addfund_supply_mode_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearFundSupplyModeCode clears the value of the "fund_supply_mode_code" field.
func (m *AsUnitMutation) ClearFundSupplyModeCode() {
	m.fund_supply_mode_code = nil
	m.addfund_supply_mode_code = nil
	m.clearedFields[asunit.FieldFundSupplyModeCode] = struct{}{}
}

// FundSupplyModeCodeCleared returns if the "fund_supply_mode_code" field was cleared in this mutation.
func (m *AsUnitMutation) FundSupplyModeCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldFundSupplyModeCode]
	return ok
}

// ResetFundSupplyModeCode resets all changes to the "fund_supply_mode_code" field.
func (m *AsUnitMutation) ResetFundSupplyModeCode() {
	m.fund_supply_mode_code = nil
	m.addfund_supply_mode_code = nil
	delete(m.clearedFields, asunit.FieldFundSupplyModeCode)
}

// SetAdministrationLevelName sets the "administration_level_name" field.
func (m *AsUnitMutation) SetAdministrationLevelName(i int64) {
	m.administration_level_name = &i
	m.addadministration_level_name = nil
}

// AdministrationLevelName returns the value of the "administration_level_name" field in the mutation.
func (m *AsUnitMutation) AdministrationLevelName() (r int64, exists bool) {
	v := m.administration_level_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAdministrationLevelName returns the old "administration_level_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldAdministrationLevelName(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdministrationLevelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdministrationLevelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdministrationLevelName: %w", err)
	}
	return oldValue.AdministrationLevelName, nil
}

// AddAdministrationLevelName adds i to the "administration_level_name" field.
func (m *AsUnitMutation) AddAdministrationLevelName(i int64) {
	if m.addadministration_level_name != nil {
		*m.addadministration_level_name += i
	} else {
		m.addadministration_level_name = &i
	}
}

// AddedAdministrationLevelName returns the value that was added to the "administration_level_name" field in this mutation.
func (m *AsUnitMutation) AddedAdministrationLevelName() (r int64, exists bool) {
	v := m.addadministration_level_name
	if v == nil {
		return
	}
	return *v, true
}

// ClearAdministrationLevelName clears the value of the "administration_level_name" field.
func (m *AsUnitMutation) ClearAdministrationLevelName() {
	m.administration_level_name = nil
	m.addadministration_level_name = nil
	m.clearedFields[asunit.FieldAdministrationLevelName] = struct{}{}
}

// AdministrationLevelNameCleared returns if the "administration_level_name" field was cleared in this mutation.
func (m *AsUnitMutation) AdministrationLevelNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldAdministrationLevelName]
	return ok
}

// ResetAdministrationLevelName resets all changes to the "administration_level_name" field.
func (m *AsUnitMutation) ResetAdministrationLevelName() {
	m.administration_level_name = nil
	m.addadministration_level_name = nil
	delete(m.clearedFields, asunit.FieldAdministrationLevelName)
}

// SetAdministrationLevelType sets the "administration_level_type" field.
func (m *AsUnitMutation) SetAdministrationLevelType(i int64) {
	m.administration_level_type = &i
	m.addadministration_level_type = nil
}

// AdministrationLevelType returns the value of the "administration_level_type" field in the mutation.
func (m *AsUnitMutation) AdministrationLevelType() (r int64, exists bool) {
	v := m.administration_level_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAdministrationLevelType returns the old "administration_level_type" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldAdministrationLevelType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdministrationLevelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdministrationLevelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdministrationLevelType: %w", err)
	}
	return oldValue.AdministrationLevelType, nil
}

// AddAdministrationLevelType adds i to the "administration_level_type" field.
func (m *AsUnitMutation) AddAdministrationLevelType(i int64) {
	if m.addadministration_level_type != nil {
		*m.addadministration_level_type += i
	} else {
		m.addadministration_level_type = &i
	}
}

// AddedAdministrationLevelType returns the value that was added to the "administration_level_type" field in this mutation.
func (m *AsUnitMutation) AddedAdministrationLevelType() (r int64, exists bool) {
	v := m.addadministration_level_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearAdministrationLevelType clears the value of the "administration_level_type" field.
func (m *AsUnitMutation) ClearAdministrationLevelType() {
	m.administration_level_type = nil
	m.addadministration_level_type = nil
	m.clearedFields[asunit.FieldAdministrationLevelType] = struct{}{}
}

// AdministrationLevelTypeCleared returns if the "administration_level_type" field was cleared in this mutation.
func (m *AsUnitMutation) AdministrationLevelTypeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldAdministrationLevelType]
	return ok
}

// ResetAdministrationLevelType resets all changes to the "administration_level_type" field.
func (m *AsUnitMutation) ResetAdministrationLevelType() {
	m.administration_level_type = nil
	m.addadministration_level_type = nil
	delete(m.clearedFields, asunit.FieldAdministrationLevelType)
}

// SetDepartmentCategoryName sets the "department_category_name" field.
func (m *AsUnitMutation) SetDepartmentCategoryName(i int64) {
	m.department_category_name = &i
	m.adddepartment_category_name = nil
}

// DepartmentCategoryName returns the value of the "department_category_name" field in the mutation.
func (m *AsUnitMutation) DepartmentCategoryName() (r int64, exists bool) {
	v := m.department_category_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentCategoryName returns the old "department_category_name" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldDepartmentCategoryName(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentCategoryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentCategoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentCategoryName: %w", err)
	}
	return oldValue.DepartmentCategoryName, nil
}

// AddDepartmentCategoryName adds i to the "department_category_name" field.
func (m *AsUnitMutation) AddDepartmentCategoryName(i int64) {
	if m.adddepartment_category_name != nil {
		*m.adddepartment_category_name += i
	} else {
		m.adddepartment_category_name = &i
	}
}

// AddedDepartmentCategoryName returns the value that was added to the "department_category_name" field in this mutation.
func (m *AsUnitMutation) AddedDepartmentCategoryName() (r int64, exists bool) {
	v := m.adddepartment_category_name
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepartmentCategoryName clears the value of the "department_category_name" field.
func (m *AsUnitMutation) ClearDepartmentCategoryName() {
	m.department_category_name = nil
	m.adddepartment_category_name = nil
	m.clearedFields[asunit.FieldDepartmentCategoryName] = struct{}{}
}

// DepartmentCategoryNameCleared returns if the "department_category_name" field was cleared in this mutation.
func (m *AsUnitMutation) DepartmentCategoryNameCleared() bool {
	_, ok := m.clearedFields[asunit.FieldDepartmentCategoryName]
	return ok
}

// ResetDepartmentCategoryName resets all changes to the "department_category_name" field.
func (m *AsUnitMutation) ResetDepartmentCategoryName() {
	m.department_category_name = nil
	m.adddepartment_category_name = nil
	delete(m.clearedFields, asunit.FieldDepartmentCategoryName)
}

// SetBusinessDepartmentClassificationCode sets the "business_department_classification_code" field.
func (m *AsUnitMutation) SetBusinessDepartmentClassificationCode(i int64) {
	m.business_department_classification_code = &i
	m.addbusiness_department_classification_code = nil
}

// BusinessDepartmentClassificationCode returns the value of the "business_department_classification_code" field in the mutation.
func (m *AsUnitMutation) BusinessDepartmentClassificationCode() (r int64, exists bool) {
	v := m.business_department_classification_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessDepartmentClassificationCode returns the old "business_department_classification_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldBusinessDepartmentClassificationCode(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessDepartmentClassificationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessDepartmentClassificationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessDepartmentClassificationCode: %w", err)
	}
	return oldValue.BusinessDepartmentClassificationCode, nil
}

// AddBusinessDepartmentClassificationCode adds i to the "business_department_classification_code" field.
func (m *AsUnitMutation) AddBusinessDepartmentClassificationCode(i int64) {
	if m.addbusiness_department_classification_code != nil {
		*m.addbusiness_department_classification_code += i
	} else {
		m.addbusiness_department_classification_code = &i
	}
}

// AddedBusinessDepartmentClassificationCode returns the value that was added to the "business_department_classification_code" field in this mutation.
func (m *AsUnitMutation) AddedBusinessDepartmentClassificationCode() (r int64, exists bool) {
	v := m.addbusiness_department_classification_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearBusinessDepartmentClassificationCode clears the value of the "business_department_classification_code" field.
func (m *AsUnitMutation) ClearBusinessDepartmentClassificationCode() {
	m.business_department_classification_code = nil
	m.addbusiness_department_classification_code = nil
	m.clearedFields[asunit.FieldBusinessDepartmentClassificationCode] = struct{}{}
}

// BusinessDepartmentClassificationCodeCleared returns if the "business_department_classification_code" field was cleared in this mutation.
func (m *AsUnitMutation) BusinessDepartmentClassificationCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldBusinessDepartmentClassificationCode]
	return ok
}

// ResetBusinessDepartmentClassificationCode resets all changes to the "business_department_classification_code" field.
func (m *AsUnitMutation) ResetBusinessDepartmentClassificationCode() {
	m.business_department_classification_code = nil
	m.addbusiness_department_classification_code = nil
	delete(m.clearedFields, asunit.FieldBusinessDepartmentClassificationCode)
}

// SetPrincipal sets the "principal" field.
func (m *AsUnitMutation) SetPrincipal(s string) {
	m.principal = &s
}

// Principal returns the value of the "principal" field in the mutation.
func (m *AsUnitMutation) Principal() (r string, exists bool) {
	v := m.principal
	if v == nil {
		return
	}
	return *v, true
}

// OldPrincipal returns the old "principal" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldPrincipal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrincipal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrincipal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrincipal: %w", err)
	}
	return oldValue.Principal, nil
}

// ClearPrincipal clears the value of the "principal" field.
func (m *AsUnitMutation) ClearPrincipal() {
	m.principal = nil
	m.clearedFields[asunit.FieldPrincipal] = struct{}{}
}

// PrincipalCleared returns if the "principal" field was cleared in this mutation.
func (m *AsUnitMutation) PrincipalCleared() bool {
	_, ok := m.clearedFields[asunit.FieldPrincipal]
	return ok
}

// ResetPrincipal resets all changes to the "principal" field.
func (m *AsUnitMutation) ResetPrincipal() {
	m.principal = nil
	delete(m.clearedFields, asunit.FieldPrincipal)
}

// SetContact sets the "contact" field.
func (m *AsUnitMutation) SetContact(s string) {
	m.contact = &s
}

// Contact returns the value of the "contact" field in the mutation.
func (m *AsUnitMutation) Contact() (r string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ClearContact clears the value of the "contact" field.
func (m *AsUnitMutation) ClearContact() {
	m.contact = nil
	m.clearedFields[asunit.FieldContact] = struct{}{}
}

// ContactCleared returns if the "contact" field was cleared in this mutation.
func (m *AsUnitMutation) ContactCleared() bool {
	_, ok := m.clearedFields[asunit.FieldContact]
	return ok
}

// ResetContact resets all changes to the "contact" field.
func (m *AsUnitMutation) ResetContact() {
	m.contact = nil
	delete(m.clearedFields, asunit.FieldContact)
}

// SetCorporateRepresentative sets the "corporate_representative" field.
func (m *AsUnitMutation) SetCorporateRepresentative(s string) {
	m.corporate_representative = &s
}

// CorporateRepresentative returns the value of the "corporate_representative" field in the mutation.
func (m *AsUnitMutation) CorporateRepresentative() (r string, exists bool) {
	v := m.corporate_representative
	if v == nil {
		return
	}
	return *v, true
}

// OldCorporateRepresentative returns the old "corporate_representative" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldCorporateRepresentative(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorporateRepresentative is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorporateRepresentative requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorporateRepresentative: %w", err)
	}
	return oldValue.CorporateRepresentative, nil
}

// ClearCorporateRepresentative clears the value of the "corporate_representative" field.
func (m *AsUnitMutation) ClearCorporateRepresentative() {
	m.corporate_representative = nil
	m.clearedFields[asunit.FieldCorporateRepresentative] = struct{}{}
}

// CorporateRepresentativeCleared returns if the "corporate_representative" field was cleared in this mutation.
func (m *AsUnitMutation) CorporateRepresentativeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldCorporateRepresentative]
	return ok
}

// ResetCorporateRepresentative resets all changes to the "corporate_representative" field.
func (m *AsUnitMutation) ResetCorporateRepresentative() {
	m.corporate_representative = nil
	delete(m.clearedFields, asunit.FieldCorporateRepresentative)
}

// SetEconomicType sets the "economic_type" field.
func (m *AsUnitMutation) SetEconomicType(i int64) {
	m.economic_type = &i
	m.addeconomic_type = nil
}

// EconomicType returns the value of the "economic_type" field in the mutation.
func (m *AsUnitMutation) EconomicType() (r int64, exists bool) {
	v := m.economic_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEconomicType returns the old "economic_type" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldEconomicType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEconomicType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEconomicType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEconomicType: %w", err)
	}
	return oldValue.EconomicType, nil
}

// AddEconomicType adds i to the "economic_type" field.
func (m *AsUnitMutation) AddEconomicType(i int64) {
	if m.addeconomic_type != nil {
		*m.addeconomic_type += i
	} else {
		m.addeconomic_type = &i
	}
}

// AddedEconomicType returns the value that was added to the "economic_type" field in this mutation.
func (m *AsUnitMutation) AddedEconomicType() (r int64, exists bool) {
	v := m.addeconomic_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearEconomicType clears the value of the "economic_type" field.
func (m *AsUnitMutation) ClearEconomicType() {
	m.economic_type = nil
	m.addeconomic_type = nil
	m.clearedFields[asunit.FieldEconomicType] = struct{}{}
}

// EconomicTypeCleared returns if the "economic_type" field was cleared in this mutation.
func (m *AsUnitMutation) EconomicTypeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldEconomicType]
	return ok
}

// ResetEconomicType resets all changes to the "economic_type" field.
func (m *AsUnitMutation) ResetEconomicType() {
	m.economic_type = nil
	m.addeconomic_type = nil
	delete(m.clearedFields, asunit.FieldEconomicType)
}

// SetFinancialAffiliation sets the "financial_affiliation" field.
func (m *AsUnitMutation) SetFinancialAffiliation(s string) {
	m.financial_affiliation = &s
}

// FinancialAffiliation returns the value of the "financial_affiliation" field in the mutation.
func (m *AsUnitMutation) FinancialAffiliation() (r string, exists bool) {
	v := m.financial_affiliation
	if v == nil {
		return
	}
	return *v, true
}

// OldFinancialAffiliation returns the old "financial_affiliation" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldFinancialAffiliation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinancialAffiliation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinancialAffiliation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinancialAffiliation: %w", err)
	}
	return oldValue.FinancialAffiliation, nil
}

// ClearFinancialAffiliation clears the value of the "financial_affiliation" field.
func (m *AsUnitMutation) ClearFinancialAffiliation() {
	m.financial_affiliation = nil
	m.clearedFields[asunit.FieldFinancialAffiliation] = struct{}{}
}

// FinancialAffiliationCleared returns if the "financial_affiliation" field was cleared in this mutation.
func (m *AsUnitMutation) FinancialAffiliationCleared() bool {
	_, ok := m.clearedFields[asunit.FieldFinancialAffiliation]
	return ok
}

// ResetFinancialAffiliation resets all changes to the "financial_affiliation" field.
func (m *AsUnitMutation) ResetFinancialAffiliation() {
	m.financial_affiliation = nil
	delete(m.clearedFields, asunit.FieldFinancialAffiliation)
}

// SetFinancialUnit sets the "financial_unit" field.
func (m *AsUnitMutation) SetFinancialUnit(i int64) {
	m.financial_unit = &i
	m.addfinancial_unit = nil
}

// FinancialUnit returns the value of the "financial_unit" field in the mutation.
func (m *AsUnitMutation) FinancialUnit() (r int64, exists bool) {
	v := m.financial_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldFinancialUnit returns the old "financial_unit" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldFinancialUnit(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinancialUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinancialUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinancialUnit: %w", err)
	}
	return oldValue.FinancialUnit, nil
}

// AddFinancialUnit adds i to the "financial_unit" field.
func (m *AsUnitMutation) AddFinancialUnit(i int64) {
	if m.addfinancial_unit != nil {
		*m.addfinancial_unit += i
	} else {
		m.addfinancial_unit = &i
	}
}

// AddedFinancialUnit returns the value that was added to the "financial_unit" field in this mutation.
func (m *AsUnitMutation) AddedFinancialUnit() (r int64, exists bool) {
	v := m.addfinancial_unit
	if v == nil {
		return
	}
	return *v, true
}

// ClearFinancialUnit clears the value of the "financial_unit" field.
func (m *AsUnitMutation) ClearFinancialUnit() {
	m.financial_unit = nil
	m.addfinancial_unit = nil
	m.clearedFields[asunit.FieldFinancialUnit] = struct{}{}
}

// FinancialUnitCleared returns if the "financial_unit" field was cleared in this mutation.
func (m *AsUnitMutation) FinancialUnitCleared() bool {
	_, ok := m.clearedFields[asunit.FieldFinancialUnit]
	return ok
}

// ResetFinancialUnit resets all changes to the "financial_unit" field.
func (m *AsUnitMutation) ResetFinancialUnit() {
	m.financial_unit = nil
	m.addfinancial_unit = nil
	delete(m.clearedFields, asunit.FieldFinancialUnit)
}

// SetVerticalUnit sets the "vertical_unit" field.
func (m *AsUnitMutation) SetVerticalUnit(i int64) {
	m.vertical_unit = &i
	m.addvertical_unit = nil
}

// VerticalUnit returns the value of the "vertical_unit" field in the mutation.
func (m *AsUnitMutation) VerticalUnit() (r int64, exists bool) {
	v := m.vertical_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldVerticalUnit returns the old "vertical_unit" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldVerticalUnit(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerticalUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerticalUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerticalUnit: %w", err)
	}
	return oldValue.VerticalUnit, nil
}

// AddVerticalUnit adds i to the "vertical_unit" field.
func (m *AsUnitMutation) AddVerticalUnit(i int64) {
	if m.addvertical_unit != nil {
		*m.addvertical_unit += i
	} else {
		m.addvertical_unit = &i
	}
}

// AddedVerticalUnit returns the value that was added to the "vertical_unit" field in this mutation.
func (m *AsUnitMutation) AddedVerticalUnit() (r int64, exists bool) {
	v := m.addvertical_unit
	if v == nil {
		return
	}
	return *v, true
}

// ClearVerticalUnit clears the value of the "vertical_unit" field.
func (m *AsUnitMutation) ClearVerticalUnit() {
	m.vertical_unit = nil
	m.addvertical_unit = nil
	m.clearedFields[asunit.FieldVerticalUnit] = struct{}{}
}

// VerticalUnitCleared returns if the "vertical_unit" field was cleared in this mutation.
func (m *AsUnitMutation) VerticalUnitCleared() bool {
	_, ok := m.clearedFields[asunit.FieldVerticalUnit]
	return ok
}

// ResetVerticalUnit resets all changes to the "vertical_unit" field.
func (m *AsUnitMutation) ResetVerticalUnit() {
	m.vertical_unit = nil
	m.addvertical_unit = nil
	delete(m.clearedFields, asunit.FieldVerticalUnit)
}

// SetVirtualUnit sets the "virtual_unit" field.
func (m *AsUnitMutation) SetVirtualUnit(i int64) {
	m.virtual_unit = &i
	m.addvirtual_unit = nil
}

// VirtualUnit returns the value of the "virtual_unit" field in the mutation.
func (m *AsUnitMutation) VirtualUnit() (r int64, exists bool) {
	v := m.virtual_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldVirtualUnit returns the old "virtual_unit" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldVirtualUnit(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVirtualUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVirtualUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVirtualUnit: %w", err)
	}
	return oldValue.VirtualUnit, nil
}

// AddVirtualUnit adds i to the "virtual_unit" field.
func (m *AsUnitMutation) AddVirtualUnit(i int64) {
	if m.addvirtual_unit != nil {
		*m.addvirtual_unit += i
	} else {
		m.addvirtual_unit = &i
	}
}

// AddedVirtualUnit returns the value that was added to the "virtual_unit" field in this mutation.
func (m *AsUnitMutation) AddedVirtualUnit() (r int64, exists bool) {
	v := m.addvirtual_unit
	if v == nil {
		return
	}
	return *v, true
}

// ClearVirtualUnit clears the value of the "virtual_unit" field.
func (m *AsUnitMutation) ClearVirtualUnit() {
	m.virtual_unit = nil
	m.addvirtual_unit = nil
	m.clearedFields[asunit.FieldVirtualUnit] = struct{}{}
}

// VirtualUnitCleared returns if the "virtual_unit" field was cleared in this mutation.
func (m *AsUnitMutation) VirtualUnitCleared() bool {
	_, ok := m.clearedFields[asunit.FieldVirtualUnit]
	return ok
}

// ResetVirtualUnit resets all changes to the "virtual_unit" field.
func (m *AsUnitMutation) ResetVirtualUnit() {
	m.virtual_unit = nil
	m.addvirtual_unit = nil
	delete(m.clearedFields, asunit.FieldVirtualUnit)
}

// SetAccountingSystem sets the "accounting_system" field.
func (m *AsUnitMutation) SetAccountingSystem(i int64) {
	m.accounting_system = &i
	m.addaccounting_system = nil
}

// AccountingSystem returns the value of the "accounting_system" field in the mutation.
func (m *AsUnitMutation) AccountingSystem() (r int64, exists bool) {
	v := m.accounting_system
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountingSystem returns the old "accounting_system" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldAccountingSystem(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountingSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountingSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountingSystem: %w", err)
	}
	return oldValue.AccountingSystem, nil
}

// AddAccountingSystem adds i to the "accounting_system" field.
func (m *AsUnitMutation) AddAccountingSystem(i int64) {
	if m.addaccounting_system != nil {
		*m.addaccounting_system += i
	} else {
		m.addaccounting_system = &i
	}
}

// AddedAccountingSystem returns the value that was added to the "accounting_system" field in this mutation.
func (m *AsUnitMutation) AddedAccountingSystem() (r int64, exists bool) {
	v := m.addaccounting_system
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccountingSystem clears the value of the "accounting_system" field.
func (m *AsUnitMutation) ClearAccountingSystem() {
	m.accounting_system = nil
	m.addaccounting_system = nil
	m.clearedFields[asunit.FieldAccountingSystem] = struct{}{}
}

// AccountingSystemCleared returns if the "accounting_system" field was cleared in this mutation.
func (m *AsUnitMutation) AccountingSystemCleared() bool {
	_, ok := m.clearedFields[asunit.FieldAccountingSystem]
	return ok
}

// ResetAccountingSystem resets all changes to the "accounting_system" field.
func (m *AsUnitMutation) ResetAccountingSystem() {
	m.accounting_system = nil
	m.addaccounting_system = nil
	delete(m.clearedFields, asunit.FieldAccountingSystem)
}

// SetCorporateTag sets the "corporate_tag" field.
func (m *AsUnitMutation) SetCorporateTag(s string) {
	m.corporate_tag = &s
}

// CorporateTag returns the value of the "corporate_tag" field in the mutation.
func (m *AsUnitMutation) CorporateTag() (r string, exists bool) {
	v := m.corporate_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldCorporateTag returns the old "corporate_tag" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldCorporateTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorporateTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorporateTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorporateTag: %w", err)
	}
	return oldValue.CorporateTag, nil
}

// ClearCorporateTag clears the value of the "corporate_tag" field.
func (m *AsUnitMutation) ClearCorporateTag() {
	m.corporate_tag = nil
	m.clearedFields[asunit.FieldCorporateTag] = struct{}{}
}

// CorporateTagCleared returns if the "corporate_tag" field was cleared in this mutation.
func (m *AsUnitMutation) CorporateTagCleared() bool {
	_, ok := m.clearedFields[asunit.FieldCorporateTag]
	return ok
}

// ResetCorporateTag resets all changes to the "corporate_tag" field.
func (m *AsUnitMutation) ResetCorporateTag() {
	m.corporate_tag = nil
	delete(m.clearedFields, asunit.FieldCorporateTag)
}

// SetMaintainerMark sets the "maintainer_mark" field.
func (m *AsUnitMutation) SetMaintainerMark(s string) {
	m.maintainer_mark = &s
}

// MaintainerMark returns the value of the "maintainer_mark" field in the mutation.
func (m *AsUnitMutation) MaintainerMark() (r string, exists bool) {
	v := m.maintainer_mark
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainerMark returns the old "maintainer_mark" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldMaintainerMark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainerMark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainerMark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainerMark: %w", err)
	}
	return oldValue.MaintainerMark, nil
}

// ClearMaintainerMark clears the value of the "maintainer_mark" field.
func (m *AsUnitMutation) ClearMaintainerMark() {
	m.maintainer_mark = nil
	m.clearedFields[asunit.FieldMaintainerMark] = struct{}{}
}

// MaintainerMarkCleared returns if the "maintainer_mark" field was cleared in this mutation.
func (m *AsUnitMutation) MaintainerMarkCleared() bool {
	_, ok := m.clearedFields[asunit.FieldMaintainerMark]
	return ok
}

// ResetMaintainerMark resets all changes to the "maintainer_mark" field.
func (m *AsUnitMutation) ResetMaintainerMark() {
	m.maintainer_mark = nil
	delete(m.clearedFields, asunit.FieldMaintainerMark)
}

// SetSupplierMark sets the "supplier_mark" field.
func (m *AsUnitMutation) SetSupplierMark(s string) {
	m.supplier_mark = &s
}

// SupplierMark returns the value of the "supplier_mark" field in the mutation.
func (m *AsUnitMutation) SupplierMark() (r string, exists bool) {
	v := m.supplier_mark
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierMark returns the old "supplier_mark" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldSupplierMark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierMark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierMark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierMark: %w", err)
	}
	return oldValue.SupplierMark, nil
}

// ClearSupplierMark clears the value of the "supplier_mark" field.
func (m *AsUnitMutation) ClearSupplierMark() {
	m.supplier_mark = nil
	m.clearedFields[asunit.FieldSupplierMark] = struct{}{}
}

// SupplierMarkCleared returns if the "supplier_mark" field was cleared in this mutation.
func (m *AsUnitMutation) SupplierMarkCleared() bool {
	_, ok := m.clearedFields[asunit.FieldSupplierMark]
	return ok
}

// ResetSupplierMark resets all changes to the "supplier_mark" field.
func (m *AsUnitMutation) ResetSupplierMark() {
	m.supplier_mark = nil
	delete(m.clearedFields, asunit.FieldSupplierMark)
}

// SetManufactureMark sets the "manufacture_mark" field.
func (m *AsUnitMutation) SetManufactureMark(s string) {
	m.manufacture_mark = &s
}

// ManufactureMark returns the value of the "manufacture_mark" field in the mutation.
func (m *AsUnitMutation) ManufactureMark() (r string, exists bool) {
	v := m.manufacture_mark
	if v == nil {
		return
	}
	return *v, true
}

// OldManufactureMark returns the old "manufacture_mark" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldManufactureMark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufactureMark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufactureMark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufactureMark: %w", err)
	}
	return oldValue.ManufactureMark, nil
}

// ClearManufactureMark clears the value of the "manufacture_mark" field.
func (m *AsUnitMutation) ClearManufactureMark() {
	m.manufacture_mark = nil
	m.clearedFields[asunit.FieldManufactureMark] = struct{}{}
}

// ManufactureMarkCleared returns if the "manufacture_mark" field was cleared in this mutation.
func (m *AsUnitMutation) ManufactureMarkCleared() bool {
	_, ok := m.clearedFields[asunit.FieldManufactureMark]
	return ok
}

// ResetManufactureMark resets all changes to the "manufacture_mark" field.
func (m *AsUnitMutation) ResetManufactureMark() {
	m.manufacture_mark = nil
	delete(m.clearedFields, asunit.FieldManufactureMark)
}

// SetAssetDisposalAgencyTag sets the "asset_disposal_agency_tag" field.
func (m *AsUnitMutation) SetAssetDisposalAgencyTag(s string) {
	m.asset_disposal_agency_tag = &s
}

// AssetDisposalAgencyTag returns the value of the "asset_disposal_agency_tag" field in the mutation.
func (m *AsUnitMutation) AssetDisposalAgencyTag() (r string, exists bool) {
	v := m.asset_disposal_agency_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetDisposalAgencyTag returns the old "asset_disposal_agency_tag" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldAssetDisposalAgencyTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetDisposalAgencyTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetDisposalAgencyTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetDisposalAgencyTag: %w", err)
	}
	return oldValue.AssetDisposalAgencyTag, nil
}

// ClearAssetDisposalAgencyTag clears the value of the "asset_disposal_agency_tag" field.
func (m *AsUnitMutation) ClearAssetDisposalAgencyTag() {
	m.asset_disposal_agency_tag = nil
	m.clearedFields[asunit.FieldAssetDisposalAgencyTag] = struct{}{}
}

// AssetDisposalAgencyTagCleared returns if the "asset_disposal_agency_tag" field was cleared in this mutation.
func (m *AsUnitMutation) AssetDisposalAgencyTagCleared() bool {
	_, ok := m.clearedFields[asunit.FieldAssetDisposalAgencyTag]
	return ok
}

// ResetAssetDisposalAgencyTag resets all changes to the "asset_disposal_agency_tag" field.
func (m *AsUnitMutation) ResetAssetDisposalAgencyTag() {
	m.asset_disposal_agency_tag = nil
	delete(m.clearedFields, asunit.FieldAssetDisposalAgencyTag)
}

// SetStateAssetManagementCompany sets the "state_asset_management_company" field.
func (m *AsUnitMutation) SetStateAssetManagementCompany(s string) {
	m.state_asset_management_company = &s
}

// StateAssetManagementCompany returns the value of the "state_asset_management_company" field in the mutation.
func (m *AsUnitMutation) StateAssetManagementCompany() (r string, exists bool) {
	v := m.state_asset_management_company
	if v == nil {
		return
	}
	return *v, true
}

// OldStateAssetManagementCompany returns the old "state_asset_management_company" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldStateAssetManagementCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateAssetManagementCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateAssetManagementCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateAssetManagementCompany: %w", err)
	}
	return oldValue.StateAssetManagementCompany, nil
}

// ClearStateAssetManagementCompany clears the value of the "state_asset_management_company" field.
func (m *AsUnitMutation) ClearStateAssetManagementCompany() {
	m.state_asset_management_company = nil
	m.clearedFields[asunit.FieldStateAssetManagementCompany] = struct{}{}
}

// StateAssetManagementCompanyCleared returns if the "state_asset_management_company" field was cleared in this mutation.
func (m *AsUnitMutation) StateAssetManagementCompanyCleared() bool {
	_, ok := m.clearedFields[asunit.FieldStateAssetManagementCompany]
	return ok
}

// ResetStateAssetManagementCompany resets all changes to the "state_asset_management_company" field.
func (m *AsUnitMutation) ResetStateAssetManagementCompany() {
	m.state_asset_management_company = nil
	delete(m.clearedFields, asunit.FieldStateAssetManagementCompany)
}

// SetInstitutionNumber sets the "institution_number" field.
func (m *AsUnitMutation) SetInstitutionNumber(i int64) {
	m.institution_number = &i
	m.addinstitution_number = nil
}

// InstitutionNumber returns the value of the "institution_number" field in the mutation.
func (m *AsUnitMutation) InstitutionNumber() (r int64, exists bool) {
	v := m.institution_number
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitutionNumber returns the old "institution_number" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldInstitutionNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitutionNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitutionNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitutionNumber: %w", err)
	}
	return oldValue.InstitutionNumber, nil
}

// AddInstitutionNumber adds i to the "institution_number" field.
func (m *AsUnitMutation) AddInstitutionNumber(i int64) {
	if m.addinstitution_number != nil {
		*m.addinstitution_number += i
	} else {
		m.addinstitution_number = &i
	}
}

// AddedInstitutionNumber returns the value that was added to the "institution_number" field in this mutation.
func (m *AsUnitMutation) AddedInstitutionNumber() (r int64, exists bool) {
	v := m.addinstitution_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearInstitutionNumber clears the value of the "institution_number" field.
func (m *AsUnitMutation) ClearInstitutionNumber() {
	m.institution_number = nil
	m.addinstitution_number = nil
	m.clearedFields[asunit.FieldInstitutionNumber] = struct{}{}
}

// InstitutionNumberCleared returns if the "institution_number" field was cleared in this mutation.
func (m *AsUnitMutation) InstitutionNumberCleared() bool {
	_, ok := m.clearedFields[asunit.FieldInstitutionNumber]
	return ok
}

// ResetInstitutionNumber resets all changes to the "institution_number" field.
func (m *AsUnitMutation) ResetInstitutionNumber() {
	m.institution_number = nil
	m.addinstitution_number = nil
	delete(m.clearedFields, asunit.FieldInstitutionNumber)
}

// SetAuthorizedNumber sets the "authorized_number" field.
func (m *AsUnitMutation) SetAuthorizedNumber(i int64) {
	m.authorized_number = &i
	m.addauthorized_number = nil
}

// AuthorizedNumber returns the value of the "authorized_number" field in the mutation.
func (m *AsUnitMutation) AuthorizedNumber() (r int64, exists bool) {
	v := m.authorized_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizedNumber returns the old "authorized_number" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldAuthorizedNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizedNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizedNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizedNumber: %w", err)
	}
	return oldValue.AuthorizedNumber, nil
}

// AddAuthorizedNumber adds i to the "authorized_number" field.
func (m *AsUnitMutation) AddAuthorizedNumber(i int64) {
	if m.addauthorized_number != nil {
		*m.addauthorized_number += i
	} else {
		m.addauthorized_number = &i
	}
}

// AddedAuthorizedNumber returns the value that was added to the "authorized_number" field in this mutation.
func (m *AsUnitMutation) AddedAuthorizedNumber() (r int64, exists bool) {
	v := m.addauthorized_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearAuthorizedNumber clears the value of the "authorized_number" field.
func (m *AsUnitMutation) ClearAuthorizedNumber() {
	m.authorized_number = nil
	m.addauthorized_number = nil
	m.clearedFields[asunit.FieldAuthorizedNumber] = struct{}{}
}

// AuthorizedNumberCleared returns if the "authorized_number" field was cleared in this mutation.
func (m *AsUnitMutation) AuthorizedNumberCleared() bool {
	_, ok := m.clearedFields[asunit.FieldAuthorizedNumber]
	return ok
}

// ResetAuthorizedNumber resets all changes to the "authorized_number" field.
func (m *AsUnitMutation) ResetAuthorizedNumber() {
	m.authorized_number = nil
	m.addauthorized_number = nil
	delete(m.clearedFields, asunit.FieldAuthorizedNumber)
}

// SetOfSideNumber sets the "of_side_number" field.
func (m *AsUnitMutation) SetOfSideNumber(i int64) {
	m.of_side_number = &i
	m.addof_side_number = nil
}

// OfSideNumber returns the value of the "of_side_number" field in the mutation.
func (m *AsUnitMutation) OfSideNumber() (r int64, exists bool) {
	v := m.of_side_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOfSideNumber returns the old "of_side_number" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldOfSideNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfSideNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfSideNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfSideNumber: %w", err)
	}
	return oldValue.OfSideNumber, nil
}

// AddOfSideNumber adds i to the "of_side_number" field.
func (m *AsUnitMutation) AddOfSideNumber(i int64) {
	if m.addof_side_number != nil {
		*m.addof_side_number += i
	} else {
		m.addof_side_number = &i
	}
}

// AddedOfSideNumber returns the value that was added to the "of_side_number" field in this mutation.
func (m *AsUnitMutation) AddedOfSideNumber() (r int64, exists bool) {
	v := m.addof_side_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearOfSideNumber clears the value of the "of_side_number" field.
func (m *AsUnitMutation) ClearOfSideNumber() {
	m.of_side_number = nil
	m.addof_side_number = nil
	m.clearedFields[asunit.FieldOfSideNumber] = struct{}{}
}

// OfSideNumberCleared returns if the "of_side_number" field was cleared in this mutation.
func (m *AsUnitMutation) OfSideNumberCleared() bool {
	_, ok := m.clearedFields[asunit.FieldOfSideNumber]
	return ok
}

// ResetOfSideNumber resets all changes to the "of_side_number" field.
func (m *AsUnitMutation) ResetOfSideNumber() {
	m.of_side_number = nil
	m.addof_side_number = nil
	delete(m.clearedFields, asunit.FieldOfSideNumber)
}

// SetInstitutionAuthority sets the "institution_authority" field.
func (m *AsUnitMutation) SetInstitutionAuthority(s string) {
	m.institution_authority = &s
}

// InstitutionAuthority returns the value of the "institution_authority" field in the mutation.
func (m *AsUnitMutation) InstitutionAuthority() (r string, exists bool) {
	v := m.institution_authority
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitutionAuthority returns the old "institution_authority" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldInstitutionAuthority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitutionAuthority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitutionAuthority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitutionAuthority: %w", err)
	}
	return oldValue.InstitutionAuthority, nil
}

// ClearInstitutionAuthority clears the value of the "institution_authority" field.
func (m *AsUnitMutation) ClearInstitutionAuthority() {
	m.institution_authority = nil
	m.clearedFields[asunit.FieldInstitutionAuthority] = struct{}{}
}

// InstitutionAuthorityCleared returns if the "institution_authority" field was cleared in this mutation.
func (m *AsUnitMutation) InstitutionAuthorityCleared() bool {
	_, ok := m.clearedFields[asunit.FieldInstitutionAuthority]
	return ok
}

// ResetInstitutionAuthority resets all changes to the "institution_authority" field.
func (m *AsUnitMutation) ResetInstitutionAuthority() {
	m.institution_authority = nil
	delete(m.clearedFields, asunit.FieldInstitutionAuthority)
}

// SetAdministrationAuthority sets the "administration_authority" field.
func (m *AsUnitMutation) SetAdministrationAuthority(s string) {
	m.administration_authority = &s
}

// AdministrationAuthority returns the value of the "administration_authority" field in the mutation.
func (m *AsUnitMutation) AdministrationAuthority() (r string, exists bool) {
	v := m.administration_authority
	if v == nil {
		return
	}
	return *v, true
}

// OldAdministrationAuthority returns the old "administration_authority" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldAdministrationAuthority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdministrationAuthority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdministrationAuthority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdministrationAuthority: %w", err)
	}
	return oldValue.AdministrationAuthority, nil
}

// ClearAdministrationAuthority clears the value of the "administration_authority" field.
func (m *AsUnitMutation) ClearAdministrationAuthority() {
	m.administration_authority = nil
	m.clearedFields[asunit.FieldAdministrationAuthority] = struct{}{}
}

// AdministrationAuthorityCleared returns if the "administration_authority" field was cleared in this mutation.
func (m *AsUnitMutation) AdministrationAuthorityCleared() bool {
	_, ok := m.clearedFields[asunit.FieldAdministrationAuthority]
	return ok
}

// ResetAdministrationAuthority resets all changes to the "administration_authority" field.
func (m *AsUnitMutation) ResetAdministrationAuthority() {
	m.administration_authority = nil
	delete(m.clearedFields, asunit.FieldAdministrationAuthority)
}

// SetEnableTime sets the "enable_time" field.
func (m *AsUnitMutation) SetEnableTime(dt date.DateTime) {
	m.enable_time = &dt
}

// EnableTime returns the value of the "enable_time" field in the mutation.
func (m *AsUnitMutation) EnableTime() (r date.DateTime, exists bool) {
	v := m.enable_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableTime returns the old "enable_time" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldEnableTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableTime: %w", err)
	}
	return oldValue.EnableTime, nil
}

// ClearEnableTime clears the value of the "enable_time" field.
func (m *AsUnitMutation) ClearEnableTime() {
	m.enable_time = nil
	m.clearedFields[asunit.FieldEnableTime] = struct{}{}
}

// EnableTimeCleared returns if the "enable_time" field was cleared in this mutation.
func (m *AsUnitMutation) EnableTimeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldEnableTime]
	return ok
}

// ResetEnableTime resets all changes to the "enable_time" field.
func (m *AsUnitMutation) ResetEnableTime() {
	m.enable_time = nil
	delete(m.clearedFields, asunit.FieldEnableTime)
}

// SetDisableTime sets the "disable_time" field.
func (m *AsUnitMutation) SetDisableTime(dt date.DateTime) {
	m.disable_time = &dt
}

// DisableTime returns the value of the "disable_time" field in the mutation.
func (m *AsUnitMutation) DisableTime() (r date.DateTime, exists bool) {
	v := m.disable_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDisableTime returns the old "disable_time" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldDisableTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisableTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisableTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisableTime: %w", err)
	}
	return oldValue.DisableTime, nil
}

// ClearDisableTime clears the value of the "disable_time" field.
func (m *AsUnitMutation) ClearDisableTime() {
	m.disable_time = nil
	m.clearedFields[asunit.FieldDisableTime] = struct{}{}
}

// DisableTimeCleared returns if the "disable_time" field was cleared in this mutation.
func (m *AsUnitMutation) DisableTimeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldDisableTime]
	return ok
}

// ResetDisableTime resets all changes to the "disable_time" field.
func (m *AsUnitMutation) ResetDisableTime() {
	m.disable_time = nil
	delete(m.clearedFields, asunit.FieldDisableTime)
}

// SetSealTime sets the "seal_time" field.
func (m *AsUnitMutation) SetSealTime(dt date.DateTime) {
	m.seal_time = &dt
}

// SealTime returns the value of the "seal_time" field in the mutation.
func (m *AsUnitMutation) SealTime() (r date.DateTime, exists bool) {
	v := m.seal_time
	if v == nil {
		return
	}
	return *v, true
}

// OldSealTime returns the old "seal_time" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldSealTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSealTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSealTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSealTime: %w", err)
	}
	return oldValue.SealTime, nil
}

// ClearSealTime clears the value of the "seal_time" field.
func (m *AsUnitMutation) ClearSealTime() {
	m.seal_time = nil
	m.clearedFields[asunit.FieldSealTime] = struct{}{}
}

// SealTimeCleared returns if the "seal_time" field was cleared in this mutation.
func (m *AsUnitMutation) SealTimeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldSealTime]
	return ok
}

// ResetSealTime resets all changes to the "seal_time" field.
func (m *AsUnitMutation) ResetSealTime() {
	m.seal_time = nil
	delete(m.clearedFields, asunit.FieldSealTime)
}

// SetUnitRemark sets the "unit_remark" field.
func (m *AsUnitMutation) SetUnitRemark(s string) {
	m.unit_remark = &s
}

// UnitRemark returns the value of the "unit_remark" field in the mutation.
func (m *AsUnitMutation) UnitRemark() (r string, exists bool) {
	v := m.unit_remark
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitRemark returns the old "unit_remark" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUnitRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitRemark: %w", err)
	}
	return oldValue.UnitRemark, nil
}

// ClearUnitRemark clears the value of the "unit_remark" field.
func (m *AsUnitMutation) ClearUnitRemark() {
	m.unit_remark = nil
	m.clearedFields[asunit.FieldUnitRemark] = struct{}{}
}

// UnitRemarkCleared returns if the "unit_remark" field was cleared in this mutation.
func (m *AsUnitMutation) UnitRemarkCleared() bool {
	_, ok := m.clearedFields[asunit.FieldUnitRemark]
	return ok
}

// ResetUnitRemark resets all changes to the "unit_remark" field.
func (m *AsUnitMutation) ResetUnitRemark() {
	m.unit_remark = nil
	delete(m.clearedFields, asunit.FieldUnitRemark)
}

// SetAssetDownloadStatus sets the "asset_download_status" field.
func (m *AsUnitMutation) SetAssetDownloadStatus(s string) {
	m.asset_download_status = &s
}

// AssetDownloadStatus returns the value of the "asset_download_status" field in the mutation.
func (m *AsUnitMutation) AssetDownloadStatus() (r string, exists bool) {
	v := m.asset_download_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetDownloadStatus returns the old "asset_download_status" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldAssetDownloadStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetDownloadStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetDownloadStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetDownloadStatus: %w", err)
	}
	return oldValue.AssetDownloadStatus, nil
}

// ClearAssetDownloadStatus clears the value of the "asset_download_status" field.
func (m *AsUnitMutation) ClearAssetDownloadStatus() {
	m.asset_download_status = nil
	m.clearedFields[asunit.FieldAssetDownloadStatus] = struct{}{}
}

// AssetDownloadStatusCleared returns if the "asset_download_status" field was cleared in this mutation.
func (m *AsUnitMutation) AssetDownloadStatusCleared() bool {
	_, ok := m.clearedFields[asunit.FieldAssetDownloadStatus]
	return ok
}

// ResetAssetDownloadStatus resets all changes to the "asset_download_status" field.
func (m *AsUnitMutation) ResetAssetDownloadStatus() {
	m.asset_download_status = nil
	delete(m.clearedFields, asunit.FieldAssetDownloadStatus)
}

// SetLatitudeAndLongitude sets the "latitude_and_longitude" field.
func (m *AsUnitMutation) SetLatitudeAndLongitude(s string) {
	m.latitude_and_longitude = &s
}

// LatitudeAndLongitude returns the value of the "latitude_and_longitude" field in the mutation.
func (m *AsUnitMutation) LatitudeAndLongitude() (r string, exists bool) {
	v := m.latitude_and_longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitudeAndLongitude returns the old "latitude_and_longitude" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldLatitudeAndLongitude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitudeAndLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitudeAndLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitudeAndLongitude: %w", err)
	}
	return oldValue.LatitudeAndLongitude, nil
}

// ClearLatitudeAndLongitude clears the value of the "latitude_and_longitude" field.
func (m *AsUnitMutation) ClearLatitudeAndLongitude() {
	m.latitude_and_longitude = nil
	m.clearedFields[asunit.FieldLatitudeAndLongitude] = struct{}{}
}

// LatitudeAndLongitudeCleared returns if the "latitude_and_longitude" field was cleared in this mutation.
func (m *AsUnitMutation) LatitudeAndLongitudeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldLatitudeAndLongitude]
	return ok
}

// ResetLatitudeAndLongitude resets all changes to the "latitude_and_longitude" field.
func (m *AsUnitMutation) ResetLatitudeAndLongitude() {
	m.latitude_and_longitude = nil
	delete(m.clearedFields, asunit.FieldLatitudeAndLongitude)
}

// SetSort sets the "sort" field.
func (m *AsUnitMutation) SetSort(i int64) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AsUnitMutation) Sort() (r int64, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldSort(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AsUnitMutation) AddSort(i int64) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AsUnitMutation) AddedSort() (r int64, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *AsUnitMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[asunit.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *AsUnitMutation) SortCleared() bool {
	_, ok := m.clearedFields[asunit.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *AsUnitMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, asunit.FieldSort)
}

// SetOrganCode sets the "organ_code" field.
func (m *AsUnitMutation) SetOrganCode(s string) {
	m.organ_code = &s
}

// OrganCode returns the value of the "organ_code" field in the mutation.
func (m *AsUnitMutation) OrganCode() (r string, exists bool) {
	v := m.organ_code
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganCode returns the old "organ_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldOrganCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganCode: %w", err)
	}
	return oldValue.OrganCode, nil
}

// ClearOrganCode clears the value of the "organ_code" field.
func (m *AsUnitMutation) ClearOrganCode() {
	m.organ_code = nil
	m.clearedFields[asunit.FieldOrganCode] = struct{}{}
}

// OrganCodeCleared returns if the "organ_code" field was cleared in this mutation.
func (m *AsUnitMutation) OrganCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldOrganCode]
	return ok
}

// ResetOrganCode resets all changes to the "organ_code" field.
func (m *AsUnitMutation) ResetOrganCode() {
	m.organ_code = nil
	delete(m.clearedFields, asunit.FieldOrganCode)
}

// SetHadInnerNumber sets the "had_inner_number" field.
func (m *AsUnitMutation) SetHadInnerNumber(i int64) {
	m.had_inner_number = &i
	m.addhad_inner_number = nil
}

// HadInnerNumber returns the value of the "had_inner_number" field in the mutation.
func (m *AsUnitMutation) HadInnerNumber() (r int64, exists bool) {
	v := m.had_inner_number
	if v == nil {
		return
	}
	return *v, true
}

// OldHadInnerNumber returns the old "had_inner_number" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldHadInnerNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHadInnerNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHadInnerNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHadInnerNumber: %w", err)
	}
	return oldValue.HadInnerNumber, nil
}

// AddHadInnerNumber adds i to the "had_inner_number" field.
func (m *AsUnitMutation) AddHadInnerNumber(i int64) {
	if m.addhad_inner_number != nil {
		*m.addhad_inner_number += i
	} else {
		m.addhad_inner_number = &i
	}
}

// AddedHadInnerNumber returns the value that was added to the "had_inner_number" field in this mutation.
func (m *AsUnitMutation) AddedHadInnerNumber() (r int64, exists bool) {
	v := m.addhad_inner_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearHadInnerNumber clears the value of the "had_inner_number" field.
func (m *AsUnitMutation) ClearHadInnerNumber() {
	m.had_inner_number = nil
	m.addhad_inner_number = nil
	m.clearedFields[asunit.FieldHadInnerNumber] = struct{}{}
}

// HadInnerNumberCleared returns if the "had_inner_number" field was cleared in this mutation.
func (m *AsUnitMutation) HadInnerNumberCleared() bool {
	_, ok := m.clearedFields[asunit.FieldHadInnerNumber]
	return ok
}

// ResetHadInnerNumber resets all changes to the "had_inner_number" field.
func (m *AsUnitMutation) ResetHadInnerNumber() {
	m.had_inner_number = nil
	m.addhad_inner_number = nil
	delete(m.clearedFields, asunit.FieldHadInnerNumber)
}

// SetApproveInnerNumber sets the "approve_inner_number" field.
func (m *AsUnitMutation) SetApproveInnerNumber(i int64) {
	m.approve_inner_number = &i
	m.addapprove_inner_number = nil
}

// ApproveInnerNumber returns the value of the "approve_inner_number" field in the mutation.
func (m *AsUnitMutation) ApproveInnerNumber() (r int64, exists bool) {
	v := m.approve_inner_number
	if v == nil {
		return
	}
	return *v, true
}

// OldApproveInnerNumber returns the old "approve_inner_number" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldApproveInnerNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproveInnerNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproveInnerNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproveInnerNumber: %w", err)
	}
	return oldValue.ApproveInnerNumber, nil
}

// AddApproveInnerNumber adds i to the "approve_inner_number" field.
func (m *AsUnitMutation) AddApproveInnerNumber(i int64) {
	if m.addapprove_inner_number != nil {
		*m.addapprove_inner_number += i
	} else {
		m.addapprove_inner_number = &i
	}
}

// AddedApproveInnerNumber returns the value that was added to the "approve_inner_number" field in this mutation.
func (m *AsUnitMutation) AddedApproveInnerNumber() (r int64, exists bool) {
	v := m.addapprove_inner_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearApproveInnerNumber clears the value of the "approve_inner_number" field.
func (m *AsUnitMutation) ClearApproveInnerNumber() {
	m.approve_inner_number = nil
	m.addapprove_inner_number = nil
	m.clearedFields[asunit.FieldApproveInnerNumber] = struct{}{}
}

// ApproveInnerNumberCleared returns if the "approve_inner_number" field was cleared in this mutation.
func (m *AsUnitMutation) ApproveInnerNumberCleared() bool {
	_, ok := m.clearedFields[asunit.FieldApproveInnerNumber]
	return ok
}

// ResetApproveInnerNumber resets all changes to the "approve_inner_number" field.
func (m *AsUnitMutation) ResetApproveInnerNumber() {
	m.approve_inner_number = nil
	m.addapprove_inner_number = nil
	delete(m.clearedFields, asunit.FieldApproveInnerNumber)
}

// SetImg sets the "img" field.
func (m *AsUnitMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *AsUnitMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ClearImg clears the value of the "img" field.
func (m *AsUnitMutation) ClearImg() {
	m.img = nil
	m.clearedFields[asunit.FieldImg] = struct{}{}
}

// ImgCleared returns if the "img" field was cleared in this mutation.
func (m *AsUnitMutation) ImgCleared() bool {
	_, ok := m.clearedFields[asunit.FieldImg]
	return ok
}

// ResetImg resets all changes to the "img" field.
func (m *AsUnitMutation) ResetImg() {
	m.img = nil
	delete(m.clearedFields, asunit.FieldImg)
}

// SetLinkMan sets the "link_man" field.
func (m *AsUnitMutation) SetLinkMan(s string) {
	m.link_man = &s
}

// LinkMan returns the value of the "link_man" field in the mutation.
func (m *AsUnitMutation) LinkMan() (r string, exists bool) {
	v := m.link_man
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkMan returns the old "link_man" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldLinkMan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkMan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkMan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkMan: %w", err)
	}
	return oldValue.LinkMan, nil
}

// ClearLinkMan clears the value of the "link_man" field.
func (m *AsUnitMutation) ClearLinkMan() {
	m.link_man = nil
	m.clearedFields[asunit.FieldLinkMan] = struct{}{}
}

// LinkManCleared returns if the "link_man" field was cleared in this mutation.
func (m *AsUnitMutation) LinkManCleared() bool {
	_, ok := m.clearedFields[asunit.FieldLinkMan]
	return ok
}

// ResetLinkMan resets all changes to the "link_man" field.
func (m *AsUnitMutation) ResetLinkMan() {
	m.link_man = nil
	delete(m.clearedFields, asunit.FieldLinkMan)
}

// SetLinkPhone sets the "link_phone" field.
func (m *AsUnitMutation) SetLinkPhone(s string) {
	m.link_phone = &s
}

// LinkPhone returns the value of the "link_phone" field in the mutation.
func (m *AsUnitMutation) LinkPhone() (r string, exists bool) {
	v := m.link_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkPhone returns the old "link_phone" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldLinkPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkPhone: %w", err)
	}
	return oldValue.LinkPhone, nil
}

// ClearLinkPhone clears the value of the "link_phone" field.
func (m *AsUnitMutation) ClearLinkPhone() {
	m.link_phone = nil
	m.clearedFields[asunit.FieldLinkPhone] = struct{}{}
}

// LinkPhoneCleared returns if the "link_phone" field was cleared in this mutation.
func (m *AsUnitMutation) LinkPhoneCleared() bool {
	_, ok := m.clearedFields[asunit.FieldLinkPhone]
	return ok
}

// ResetLinkPhone resets all changes to the "link_phone" field.
func (m *AsUnitMutation) ResetLinkPhone() {
	m.link_phone = nil
	delete(m.clearedFields, asunit.FieldLinkPhone)
}

// SetTenantID sets the "tenant_id" field.
func (m *AsUnitMutation) SetTenantID(i int64) {
	m.tenantx = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AsUnitMutation) TenantID() (r int64, exists bool) {
	v := m.tenantx
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldTenantID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AsUnitMutation) ClearTenantID() {
	m.tenantx = nil
	m.clearedFields[asunit.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AsUnitMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[asunit.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AsUnitMutation) ResetTenantID() {
	m.tenantx = nil
	delete(m.clearedFields, asunit.FieldTenantID)
}

// SetUnitCode sets the "unit_code" field.
func (m *AsUnitMutation) SetUnitCode(s string) {
	m.unit_code = &s
}

// UnitCode returns the value of the "unit_code" field in the mutation.
func (m *AsUnitMutation) UnitCode() (r string, exists bool) {
	v := m.unit_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCode returns the old "unit_code" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUnitCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCode: %w", err)
	}
	return oldValue.UnitCode, nil
}

// ClearUnitCode clears the value of the "unit_code" field.
func (m *AsUnitMutation) ClearUnitCode() {
	m.unit_code = nil
	m.clearedFields[asunit.FieldUnitCode] = struct{}{}
}

// UnitCodeCleared returns if the "unit_code" field was cleared in this mutation.
func (m *AsUnitMutation) UnitCodeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldUnitCode]
	return ok
}

// ResetUnitCode resets all changes to the "unit_code" field.
func (m *AsUnitMutation) ResetUnitCode() {
	m.unit_code = nil
	delete(m.clearedFields, asunit.FieldUnitCode)
}

// SetAuthorityTotal sets the "authority_total" field.
func (m *AsUnitMutation) SetAuthorityTotal(i int64) {
	m.authority_total = &i
	m.addauthority_total = nil
}

// AuthorityTotal returns the value of the "authority_total" field in the mutation.
func (m *AsUnitMutation) AuthorityTotal() (r int64, exists bool) {
	v := m.authority_total
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorityTotal returns the old "authority_total" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldAuthorityTotal(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorityTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorityTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorityTotal: %w", err)
	}
	return oldValue.AuthorityTotal, nil
}

// AddAuthorityTotal adds i to the "authority_total" field.
func (m *AsUnitMutation) AddAuthorityTotal(i int64) {
	if m.addauthority_total != nil {
		*m.addauthority_total += i
	} else {
		m.addauthority_total = &i
	}
}

// AddedAuthorityTotal returns the value that was added to the "authority_total" field in this mutation.
func (m *AsUnitMutation) AddedAuthorityTotal() (r int64, exists bool) {
	v := m.addauthority_total
	if v == nil {
		return
	}
	return *v, true
}

// ClearAuthorityTotal clears the value of the "authority_total" field.
func (m *AsUnitMutation) ClearAuthorityTotal() {
	m.authority_total = nil
	m.addauthority_total = nil
	m.clearedFields[asunit.FieldAuthorityTotal] = struct{}{}
}

// AuthorityTotalCleared returns if the "authority_total" field was cleared in this mutation.
func (m *AsUnitMutation) AuthorityTotalCleared() bool {
	_, ok := m.clearedFields[asunit.FieldAuthorityTotal]
	return ok
}

// ResetAuthorityTotal resets all changes to the "authority_total" field.
func (m *AsUnitMutation) ResetAuthorityTotal() {
	m.authority_total = nil
	m.addauthority_total = nil
	delete(m.clearedFields, asunit.FieldAuthorityTotal)
}

// SetStaffOnActiveDuty sets the "staff_on_active_duty" field.
func (m *AsUnitMutation) SetStaffOnActiveDuty(i int64) {
	m.staff_on_active_duty = &i
	m.addstaff_on_active_duty = nil
}

// StaffOnActiveDuty returns the value of the "staff_on_active_duty" field in the mutation.
func (m *AsUnitMutation) StaffOnActiveDuty() (r int64, exists bool) {
	v := m.staff_on_active_duty
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffOnActiveDuty returns the old "staff_on_active_duty" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldStaffOnActiveDuty(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStaffOnActiveDuty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStaffOnActiveDuty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffOnActiveDuty: %w", err)
	}
	return oldValue.StaffOnActiveDuty, nil
}

// AddStaffOnActiveDuty adds i to the "staff_on_active_duty" field.
func (m *AsUnitMutation) AddStaffOnActiveDuty(i int64) {
	if m.addstaff_on_active_duty != nil {
		*m.addstaff_on_active_duty += i
	} else {
		m.addstaff_on_active_duty = &i
	}
}

// AddedStaffOnActiveDuty returns the value that was added to the "staff_on_active_duty" field in this mutation.
func (m *AsUnitMutation) AddedStaffOnActiveDuty() (r int64, exists bool) {
	v := m.addstaff_on_active_duty
	if v == nil {
		return
	}
	return *v, true
}

// ClearStaffOnActiveDuty clears the value of the "staff_on_active_duty" field.
func (m *AsUnitMutation) ClearStaffOnActiveDuty() {
	m.staff_on_active_duty = nil
	m.addstaff_on_active_duty = nil
	m.clearedFields[asunit.FieldStaffOnActiveDuty] = struct{}{}
}

// StaffOnActiveDutyCleared returns if the "staff_on_active_duty" field was cleared in this mutation.
func (m *AsUnitMutation) StaffOnActiveDutyCleared() bool {
	_, ok := m.clearedFields[asunit.FieldStaffOnActiveDuty]
	return ok
}

// ResetStaffOnActiveDuty resets all changes to the "staff_on_active_duty" field.
func (m *AsUnitMutation) ResetStaffOnActiveDuty() {
	m.staff_on_active_duty = nil
	m.addstaff_on_active_duty = nil
	delete(m.clearedFields, asunit.FieldStaffOnActiveDuty)
}

// SetRetiredStaff sets the "retired_staff" field.
func (m *AsUnitMutation) SetRetiredStaff(i int64) {
	m.retired_staff = &i
	m.addretired_staff = nil
}

// RetiredStaff returns the value of the "retired_staff" field in the mutation.
func (m *AsUnitMutation) RetiredStaff() (r int64, exists bool) {
	v := m.retired_staff
	if v == nil {
		return
	}
	return *v, true
}

// OldRetiredStaff returns the old "retired_staff" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldRetiredStaff(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetiredStaff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetiredStaff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetiredStaff: %w", err)
	}
	return oldValue.RetiredStaff, nil
}

// AddRetiredStaff adds i to the "retired_staff" field.
func (m *AsUnitMutation) AddRetiredStaff(i int64) {
	if m.addretired_staff != nil {
		*m.addretired_staff += i
	} else {
		m.addretired_staff = &i
	}
}

// AddedRetiredStaff returns the value that was added to the "retired_staff" field in this mutation.
func (m *AsUnitMutation) AddedRetiredStaff() (r int64, exists bool) {
	v := m.addretired_staff
	if v == nil {
		return
	}
	return *v, true
}

// ClearRetiredStaff clears the value of the "retired_staff" field.
func (m *AsUnitMutation) ClearRetiredStaff() {
	m.retired_staff = nil
	m.addretired_staff = nil
	m.clearedFields[asunit.FieldRetiredStaff] = struct{}{}
}

// RetiredStaffCleared returns if the "retired_staff" field was cleared in this mutation.
func (m *AsUnitMutation) RetiredStaffCleared() bool {
	_, ok := m.clearedFields[asunit.FieldRetiredStaff]
	return ok
}

// ResetRetiredStaff resets all changes to the "retired_staff" field.
func (m *AsUnitMutation) ResetRetiredStaff() {
	m.retired_staff = nil
	m.addretired_staff = nil
	delete(m.clearedFields, asunit.FieldRetiredStaff)
}

// SetOtherStaff sets the "other_staff" field.
func (m *AsUnitMutation) SetOtherStaff(i int64) {
	m.other_staff = &i
	m.addother_staff = nil
}

// OtherStaff returns the value of the "other_staff" field in the mutation.
func (m *AsUnitMutation) OtherStaff() (r int64, exists bool) {
	v := m.other_staff
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherStaff returns the old "other_staff" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldOtherStaff(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherStaff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherStaff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherStaff: %w", err)
	}
	return oldValue.OtherStaff, nil
}

// AddOtherStaff adds i to the "other_staff" field.
func (m *AsUnitMutation) AddOtherStaff(i int64) {
	if m.addother_staff != nil {
		*m.addother_staff += i
	} else {
		m.addother_staff = &i
	}
}

// AddedOtherStaff returns the value that was added to the "other_staff" field in this mutation.
func (m *AsUnitMutation) AddedOtherStaff() (r int64, exists bool) {
	v := m.addother_staff
	if v == nil {
		return
	}
	return *v, true
}

// ClearOtherStaff clears the value of the "other_staff" field.
func (m *AsUnitMutation) ClearOtherStaff() {
	m.other_staff = nil
	m.addother_staff = nil
	m.clearedFields[asunit.FieldOtherStaff] = struct{}{}
}

// OtherStaffCleared returns if the "other_staff" field was cleared in this mutation.
func (m *AsUnitMutation) OtherStaffCleared() bool {
	_, ok := m.clearedFields[asunit.FieldOtherStaff]
	return ok
}

// ResetOtherStaff resets all changes to the "other_staff" field.
func (m *AsUnitMutation) ResetOtherStaff() {
	m.other_staff = nil
	m.addother_staff = nil
	delete(m.clearedFields, asunit.FieldOtherStaff)
}

// SetIsVirtual sets the "is_virtual" field.
func (m *AsUnitMutation) SetIsVirtual(s string) {
	m.is_virtual = &s
}

// IsVirtual returns the value of the "is_virtual" field in the mutation.
func (m *AsUnitMutation) IsVirtual() (r string, exists bool) {
	v := m.is_virtual
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVirtual returns the old "is_virtual" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldIsVirtual(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVirtual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVirtual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVirtual: %w", err)
	}
	return oldValue.IsVirtual, nil
}

// ResetIsVirtual resets all changes to the "is_virtual" field.
func (m *AsUnitMutation) ResetIsVirtual() {
	m.is_virtual = nil
}

// SetUnitReform sets the "unit_reform" field.
func (m *AsUnitMutation) SetUnitReform(i int64) {
	m.unit_reform = &i
	m.addunit_reform = nil
}

// UnitReform returns the value of the "unit_reform" field in the mutation.
func (m *AsUnitMutation) UnitReform() (r int64, exists bool) {
	v := m.unit_reform
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitReform returns the old "unit_reform" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUnitReform(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitReform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitReform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitReform: %w", err)
	}
	return oldValue.UnitReform, nil
}

// AddUnitReform adds i to the "unit_reform" field.
func (m *AsUnitMutation) AddUnitReform(i int64) {
	if m.addunit_reform != nil {
		*m.addunit_reform += i
	} else {
		m.addunit_reform = &i
	}
}

// AddedUnitReform returns the value that was added to the "unit_reform" field in this mutation.
func (m *AsUnitMutation) AddedUnitReform() (r int64, exists bool) {
	v := m.addunit_reform
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitReform clears the value of the "unit_reform" field.
func (m *AsUnitMutation) ClearUnitReform() {
	m.unit_reform = nil
	m.addunit_reform = nil
	m.clearedFields[asunit.FieldUnitReform] = struct{}{}
}

// UnitReformCleared returns if the "unit_reform" field was cleared in this mutation.
func (m *AsUnitMutation) UnitReformCleared() bool {
	_, ok := m.clearedFields[asunit.FieldUnitReform]
	return ok
}

// ResetUnitReform resets all changes to the "unit_reform" field.
func (m *AsUnitMutation) ResetUnitReform() {
	m.unit_reform = nil
	m.addunit_reform = nil
	delete(m.clearedFields, asunit.FieldUnitReform)
}

// SetPersonExpenditure sets the "person_expenditure" field.
func (m *AsUnitMutation) SetPersonExpenditure(i int64) {
	m.person_expenditure = &i
	m.addperson_expenditure = nil
}

// PersonExpenditure returns the value of the "person_expenditure" field in the mutation.
func (m *AsUnitMutation) PersonExpenditure() (r int64, exists bool) {
	v := m.person_expenditure
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonExpenditure returns the old "person_expenditure" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldPersonExpenditure(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonExpenditure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonExpenditure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonExpenditure: %w", err)
	}
	return oldValue.PersonExpenditure, nil
}

// AddPersonExpenditure adds i to the "person_expenditure" field.
func (m *AsUnitMutation) AddPersonExpenditure(i int64) {
	if m.addperson_expenditure != nil {
		*m.addperson_expenditure += i
	} else {
		m.addperson_expenditure = &i
	}
}

// AddedPersonExpenditure returns the value that was added to the "person_expenditure" field in this mutation.
func (m *AsUnitMutation) AddedPersonExpenditure() (r int64, exists bool) {
	v := m.addperson_expenditure
	if v == nil {
		return
	}
	return *v, true
}

// ClearPersonExpenditure clears the value of the "person_expenditure" field.
func (m *AsUnitMutation) ClearPersonExpenditure() {
	m.person_expenditure = nil
	m.addperson_expenditure = nil
	m.clearedFields[asunit.FieldPersonExpenditure] = struct{}{}
}

// PersonExpenditureCleared returns if the "person_expenditure" field was cleared in this mutation.
func (m *AsUnitMutation) PersonExpenditureCleared() bool {
	_, ok := m.clearedFields[asunit.FieldPersonExpenditure]
	return ok
}

// ResetPersonExpenditure resets all changes to the "person_expenditure" field.
func (m *AsUnitMutation) ResetPersonExpenditure() {
	m.person_expenditure = nil
	m.addperson_expenditure = nil
	delete(m.clearedFields, asunit.FieldPersonExpenditure)
}

// SetInstitutionType sets the "institution_type" field.
func (m *AsUnitMutation) SetInstitutionType(s string) {
	m.institution_type = &s
}

// InstitutionType returns the value of the "institution_type" field in the mutation.
func (m *AsUnitMutation) InstitutionType() (r string, exists bool) {
	v := m.institution_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitutionType returns the old "institution_type" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldInstitutionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitutionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitutionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitutionType: %w", err)
	}
	return oldValue.InstitutionType, nil
}

// ClearInstitutionType clears the value of the "institution_type" field.
func (m *AsUnitMutation) ClearInstitutionType() {
	m.institution_type = nil
	m.clearedFields[asunit.FieldInstitutionType] = struct{}{}
}

// InstitutionTypeCleared returns if the "institution_type" field was cleared in this mutation.
func (m *AsUnitMutation) InstitutionTypeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldInstitutionType]
	return ok
}

// ResetInstitutionType resets all changes to the "institution_type" field.
func (m *AsUnitMutation) ResetInstitutionType() {
	m.institution_type = nil
	delete(m.clearedFields, asunit.FieldInstitutionType)
}

// SetDepartmentIdentification sets the "department_identification" field.
func (m *AsUnitMutation) SetDepartmentIdentification(i int64) {
	m.department_identification = &i
	m.adddepartment_identification = nil
}

// DepartmentIdentification returns the value of the "department_identification" field in the mutation.
func (m *AsUnitMutation) DepartmentIdentification() (r int64, exists bool) {
	v := m.department_identification
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentIdentification returns the old "department_identification" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldDepartmentIdentification(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentIdentification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentIdentification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentIdentification: %w", err)
	}
	return oldValue.DepartmentIdentification, nil
}

// AddDepartmentIdentification adds i to the "department_identification" field.
func (m *AsUnitMutation) AddDepartmentIdentification(i int64) {
	if m.adddepartment_identification != nil {
		*m.adddepartment_identification += i
	} else {
		m.adddepartment_identification = &i
	}
}

// AddedDepartmentIdentification returns the value that was added to the "department_identification" field in this mutation.
func (m *AsUnitMutation) AddedDepartmentIdentification() (r int64, exists bool) {
	v := m.adddepartment_identification
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepartmentIdentification clears the value of the "department_identification" field.
func (m *AsUnitMutation) ClearDepartmentIdentification() {
	m.department_identification = nil
	m.adddepartment_identification = nil
	m.clearedFields[asunit.FieldDepartmentIdentification] = struct{}{}
}

// DepartmentIdentificationCleared returns if the "department_identification" field was cleared in this mutation.
func (m *AsUnitMutation) DepartmentIdentificationCleared() bool {
	_, ok := m.clearedFields[asunit.FieldDepartmentIdentification]
	return ok
}

// ResetDepartmentIdentification resets all changes to the "department_identification" field.
func (m *AsUnitMutation) ResetDepartmentIdentification() {
	m.department_identification = nil
	m.adddepartment_identification = nil
	delete(m.clearedFields, asunit.FieldDepartmentIdentification)
}

// SetTotalHeadcount sets the "total_headcount" field.
func (m *AsUnitMutation) SetTotalHeadcount(i int64) {
	m.total_headcount = &i
	m.addtotal_headcount = nil
}

// TotalHeadcount returns the value of the "total_headcount" field in the mutation.
func (m *AsUnitMutation) TotalHeadcount() (r int64, exists bool) {
	v := m.total_headcount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalHeadcount returns the old "total_headcount" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldTotalHeadcount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalHeadcount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalHeadcount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalHeadcount: %w", err)
	}
	return oldValue.TotalHeadcount, nil
}

// AddTotalHeadcount adds i to the "total_headcount" field.
func (m *AsUnitMutation) AddTotalHeadcount(i int64) {
	if m.addtotal_headcount != nil {
		*m.addtotal_headcount += i
	} else {
		m.addtotal_headcount = &i
	}
}

// AddedTotalHeadcount returns the value that was added to the "total_headcount" field in this mutation.
func (m *AsUnitMutation) AddedTotalHeadcount() (r int64, exists bool) {
	v := m.addtotal_headcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalHeadcount clears the value of the "total_headcount" field.
func (m *AsUnitMutation) ClearTotalHeadcount() {
	m.total_headcount = nil
	m.addtotal_headcount = nil
	m.clearedFields[asunit.FieldTotalHeadcount] = struct{}{}
}

// TotalHeadcountCleared returns if the "total_headcount" field was cleared in this mutation.
func (m *AsUnitMutation) TotalHeadcountCleared() bool {
	_, ok := m.clearedFields[asunit.FieldTotalHeadcount]
	return ok
}

// ResetTotalHeadcount resets all changes to the "total_headcount" field.
func (m *AsUnitMutation) ResetTotalHeadcount() {
	m.total_headcount = nil
	m.addtotal_headcount = nil
	delete(m.clearedFields, asunit.FieldTotalHeadcount)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsUnitMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsUnitMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsUnitMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsUnitMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsUnitMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsUnitMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsUnitMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsUnitMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsUnitMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsUnitMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asunit.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsUnitMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asunit.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsUnitMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asunit.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsUnitMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsUnitMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsUnitMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsUnitMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsUnitMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asunit.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsUnitMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asunit.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsUnitMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asunit.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsUnitMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsUnitMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsUnitMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsUnitMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsUnitMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asunit.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsUnitMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asunit.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsUnitMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asunit.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsUnitMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsUnitMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsUnitMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asunit.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsUnitMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsUnitMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asunit.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsUnitMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsUnitMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsUnit entity.
// If the AsUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUnitMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsUnitMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asunit.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsUnitMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asunit.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsUnitMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asunit.FieldUpdateTime)
}

// SetTenantxID sets the "tenantx" edge to the AsTenant entity by id.
func (m *AsUnitMutation) SetTenantxID(id int64) {
	m.tenantx = &id
}

// ClearTenantx clears the "tenantx" edge to the AsTenant entity.
func (m *AsUnitMutation) ClearTenantx() {
	m.clearedtenantx = true
}

// TenantxCleared reports if the "tenantx" edge to the AsTenant entity was cleared.
func (m *AsUnitMutation) TenantxCleared() bool {
	return m.TenantIDCleared() || m.clearedtenantx
}

// TenantxID returns the "tenantx" edge ID in the mutation.
func (m *AsUnitMutation) TenantxID() (id int64, exists bool) {
	if m.tenantx != nil {
		return *m.tenantx, true
	}
	return
}

// TenantxIDs returns the "tenantx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantxID instead. It exists only for internal usage by the builders.
func (m *AsUnitMutation) TenantxIDs() (ids []int64) {
	if id := m.tenantx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenantx resets all changes to the "tenantx" edge.
func (m *AsUnitMutation) ResetTenantx() {
	m.tenantx = nil
	m.clearedtenantx = false
}

// Where appends a list predicates to the AsUnitMutation builder.
func (m *AsUnitMutation) Where(ps ...predicate.AsUnit) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsUnitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsUnit).
func (m *AsUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsUnitMutation) Fields() []string {
	fields := make([]string, 0, 93)
	if m.unit_name != nil {
		fields = append(fields, asunit.FieldUnitName)
	}
	if m.unit_name_en != nil {
		fields = append(fields, asunit.FieldUnitNameEn)
	}
	if m.organization_form != nil {
		fields = append(fields, asunit.FieldOrganizationForm)
	}
	if m.unit_type != nil {
		fields = append(fields, asunit.FieldUnitType)
	}
	if m.parent_node_name != nil {
		fields = append(fields, asunit.FieldParentNodeName)
	}
	if m.charge_section_id != nil {
		fields = append(fields, asunit.FieldChargeSectionID)
	}
	if m.charge_section_code != nil {
		fields = append(fields, asunit.FieldChargeSectionCode)
	}
	if m.charge_section_name != nil {
		fields = append(fields, asunit.FieldChargeSectionName)
	}
	if m.local_financial_code != nil {
		fields = append(fields, asunit.FieldLocalFinancialCode)
	}
	if m.local_financial_name != nil {
		fields = append(fields, asunit.FieldLocalFinancialName)
	}
	if m.local_financial_id != nil {
		fields = append(fields, asunit.FieldLocalFinancialID)
	}
	if m.office_administration_code != nil {
		fields = append(fields, asunit.FieldOfficeAdministrationCode)
	}
	if m.office_administration_name != nil {
		fields = append(fields, asunit.FieldOfficeAdministrationName)
	}
	if m.administration_division_code != nil {
		fields = append(fields, asunit.FieldAdministrationDivisionCode)
	}
	if m.administration_division_name != nil {
		fields = append(fields, asunit.FieldAdministrationDivisionName)
	}
	if m.budget_code != nil {
		fields = append(fields, asunit.FieldBudgetCode)
	}
	if m.college_code != nil {
		fields = append(fields, asunit.FieldCollegeCode)
	}
	if m.organization_code != nil {
		fields = append(fields, asunit.FieldOrganizationCode)
	}
	if m.unit_type_code != nil {
		fields = append(fields, asunit.FieldUnitTypeCode)
	}
	if m.unit_type_name != nil {
		fields = append(fields, asunit.FieldUnitTypeName)
	}
	if m.unit_basic_property != nil {
		fields = append(fields, asunit.FieldUnitBasicProperty)
	}
	if m.social_credit_code != nil {
		fields = append(fields, asunit.FieldSocialCreditCode)
	}
	if m.budget_unit_name != nil {
		fields = append(fields, asunit.FieldBudgetUnitName)
	}
	if m.budget_unit_code != nil {
		fields = append(fields, asunit.FieldBudgetUnitCode)
	}
	if m.budget_management_level != nil {
		fields = append(fields, asunit.FieldBudgetManagementLevel)
	}
	if m.firm_name != nil {
		fields = append(fields, asunit.FieldFirmName)
	}
	if m.firm_code != nil {
		fields = append(fields, asunit.FieldFirmCode)
	}
	if m.telephone_number != nil {
		fields = append(fields, asunit.FieldTelephoneNumber)
	}
	if m.phone_number != nil {
		fields = append(fields, asunit.FieldPhoneNumber)
	}
	if m.fax_number != nil {
		fields = append(fields, asunit.FieldFaxNumber)
	}
	if m.email_address != nil {
		fields = append(fields, asunit.FieldEmailAddress)
	}
	if m.province != nil {
		fields = append(fields, asunit.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, asunit.FieldCity)
	}
	if m.county != nil {
		fields = append(fields, asunit.FieldCounty)
	}
	if m.street_address != nil {
		fields = append(fields, asunit.FieldStreetAddress)
	}
	if m.postal_code != nil {
		fields = append(fields, asunit.FieldPostalCode)
	}
	if m.fund_supply_mode_name != nil {
		fields = append(fields, asunit.FieldFundSupplyModeName)
	}
	if m.fund_supply_mode_code != nil {
		fields = append(fields, asunit.FieldFundSupplyModeCode)
	}
	if m.administration_level_name != nil {
		fields = append(fields, asunit.FieldAdministrationLevelName)
	}
	if m.administration_level_type != nil {
		fields = append(fields, asunit.FieldAdministrationLevelType)
	}
	if m.department_category_name != nil {
		fields = append(fields, asunit.FieldDepartmentCategoryName)
	}
	if m.business_department_classification_code != nil {
		fields = append(fields, asunit.FieldBusinessDepartmentClassificationCode)
	}
	if m.principal != nil {
		fields = append(fields, asunit.FieldPrincipal)
	}
	if m.contact != nil {
		fields = append(fields, asunit.FieldContact)
	}
	if m.corporate_representative != nil {
		fields = append(fields, asunit.FieldCorporateRepresentative)
	}
	if m.economic_type != nil {
		fields = append(fields, asunit.FieldEconomicType)
	}
	if m.financial_affiliation != nil {
		fields = append(fields, asunit.FieldFinancialAffiliation)
	}
	if m.financial_unit != nil {
		fields = append(fields, asunit.FieldFinancialUnit)
	}
	if m.vertical_unit != nil {
		fields = append(fields, asunit.FieldVerticalUnit)
	}
	if m.virtual_unit != nil {
		fields = append(fields, asunit.FieldVirtualUnit)
	}
	if m.accounting_system != nil {
		fields = append(fields, asunit.FieldAccountingSystem)
	}
	if m.corporate_tag != nil {
		fields = append(fields, asunit.FieldCorporateTag)
	}
	if m.maintainer_mark != nil {
		fields = append(fields, asunit.FieldMaintainerMark)
	}
	if m.supplier_mark != nil {
		fields = append(fields, asunit.FieldSupplierMark)
	}
	if m.manufacture_mark != nil {
		fields = append(fields, asunit.FieldManufactureMark)
	}
	if m.asset_disposal_agency_tag != nil {
		fields = append(fields, asunit.FieldAssetDisposalAgencyTag)
	}
	if m.state_asset_management_company != nil {
		fields = append(fields, asunit.FieldStateAssetManagementCompany)
	}
	if m.institution_number != nil {
		fields = append(fields, asunit.FieldInstitutionNumber)
	}
	if m.authorized_number != nil {
		fields = append(fields, asunit.FieldAuthorizedNumber)
	}
	if m.of_side_number != nil {
		fields = append(fields, asunit.FieldOfSideNumber)
	}
	if m.institution_authority != nil {
		fields = append(fields, asunit.FieldInstitutionAuthority)
	}
	if m.administration_authority != nil {
		fields = append(fields, asunit.FieldAdministrationAuthority)
	}
	if m.enable_time != nil {
		fields = append(fields, asunit.FieldEnableTime)
	}
	if m.disable_time != nil {
		fields = append(fields, asunit.FieldDisableTime)
	}
	if m.seal_time != nil {
		fields = append(fields, asunit.FieldSealTime)
	}
	if m.unit_remark != nil {
		fields = append(fields, asunit.FieldUnitRemark)
	}
	if m.asset_download_status != nil {
		fields = append(fields, asunit.FieldAssetDownloadStatus)
	}
	if m.latitude_and_longitude != nil {
		fields = append(fields, asunit.FieldLatitudeAndLongitude)
	}
	if m.sort != nil {
		fields = append(fields, asunit.FieldSort)
	}
	if m.organ_code != nil {
		fields = append(fields, asunit.FieldOrganCode)
	}
	if m.had_inner_number != nil {
		fields = append(fields, asunit.FieldHadInnerNumber)
	}
	if m.approve_inner_number != nil {
		fields = append(fields, asunit.FieldApproveInnerNumber)
	}
	if m.img != nil {
		fields = append(fields, asunit.FieldImg)
	}
	if m.link_man != nil {
		fields = append(fields, asunit.FieldLinkMan)
	}
	if m.link_phone != nil {
		fields = append(fields, asunit.FieldLinkPhone)
	}
	if m.tenantx != nil {
		fields = append(fields, asunit.FieldTenantID)
	}
	if m.unit_code != nil {
		fields = append(fields, asunit.FieldUnitCode)
	}
	if m.authority_total != nil {
		fields = append(fields, asunit.FieldAuthorityTotal)
	}
	if m.staff_on_active_duty != nil {
		fields = append(fields, asunit.FieldStaffOnActiveDuty)
	}
	if m.retired_staff != nil {
		fields = append(fields, asunit.FieldRetiredStaff)
	}
	if m.other_staff != nil {
		fields = append(fields, asunit.FieldOtherStaff)
	}
	if m.is_virtual != nil {
		fields = append(fields, asunit.FieldIsVirtual)
	}
	if m.unit_reform != nil {
		fields = append(fields, asunit.FieldUnitReform)
	}
	if m.person_expenditure != nil {
		fields = append(fields, asunit.FieldPersonExpenditure)
	}
	if m.institution_type != nil {
		fields = append(fields, asunit.FieldInstitutionType)
	}
	if m.department_identification != nil {
		fields = append(fields, asunit.FieldDepartmentIdentification)
	}
	if m.total_headcount != nil {
		fields = append(fields, asunit.FieldTotalHeadcount)
	}
	if m.is_deleted != nil {
		fields = append(fields, asunit.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asunit.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asunit.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asunit.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asunit.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asunit.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asunit.FieldUnitName:
		return m.UnitName()
	case asunit.FieldUnitNameEn:
		return m.UnitNameEn()
	case asunit.FieldOrganizationForm:
		return m.OrganizationForm()
	case asunit.FieldUnitType:
		return m.UnitType()
	case asunit.FieldParentNodeName:
		return m.ParentNodeName()
	case asunit.FieldChargeSectionID:
		return m.ChargeSectionID()
	case asunit.FieldChargeSectionCode:
		return m.ChargeSectionCode()
	case asunit.FieldChargeSectionName:
		return m.ChargeSectionName()
	case asunit.FieldLocalFinancialCode:
		return m.LocalFinancialCode()
	case asunit.FieldLocalFinancialName:
		return m.LocalFinancialName()
	case asunit.FieldLocalFinancialID:
		return m.LocalFinancialID()
	case asunit.FieldOfficeAdministrationCode:
		return m.OfficeAdministrationCode()
	case asunit.FieldOfficeAdministrationName:
		return m.OfficeAdministrationName()
	case asunit.FieldAdministrationDivisionCode:
		return m.AdministrationDivisionCode()
	case asunit.FieldAdministrationDivisionName:
		return m.AdministrationDivisionName()
	case asunit.FieldBudgetCode:
		return m.BudgetCode()
	case asunit.FieldCollegeCode:
		return m.CollegeCode()
	case asunit.FieldOrganizationCode:
		return m.OrganizationCode()
	case asunit.FieldUnitTypeCode:
		return m.UnitTypeCode()
	case asunit.FieldUnitTypeName:
		return m.UnitTypeName()
	case asunit.FieldUnitBasicProperty:
		return m.UnitBasicProperty()
	case asunit.FieldSocialCreditCode:
		return m.SocialCreditCode()
	case asunit.FieldBudgetUnitName:
		return m.BudgetUnitName()
	case asunit.FieldBudgetUnitCode:
		return m.BudgetUnitCode()
	case asunit.FieldBudgetManagementLevel:
		return m.BudgetManagementLevel()
	case asunit.FieldFirmName:
		return m.FirmName()
	case asunit.FieldFirmCode:
		return m.FirmCode()
	case asunit.FieldTelephoneNumber:
		return m.TelephoneNumber()
	case asunit.FieldPhoneNumber:
		return m.PhoneNumber()
	case asunit.FieldFaxNumber:
		return m.FaxNumber()
	case asunit.FieldEmailAddress:
		return m.EmailAddress()
	case asunit.FieldProvince:
		return m.Province()
	case asunit.FieldCity:
		return m.City()
	case asunit.FieldCounty:
		return m.County()
	case asunit.FieldStreetAddress:
		return m.StreetAddress()
	case asunit.FieldPostalCode:
		return m.PostalCode()
	case asunit.FieldFundSupplyModeName:
		return m.FundSupplyModeName()
	case asunit.FieldFundSupplyModeCode:
		return m.FundSupplyModeCode()
	case asunit.FieldAdministrationLevelName:
		return m.AdministrationLevelName()
	case asunit.FieldAdministrationLevelType:
		return m.AdministrationLevelType()
	case asunit.FieldDepartmentCategoryName:
		return m.DepartmentCategoryName()
	case asunit.FieldBusinessDepartmentClassificationCode:
		return m.BusinessDepartmentClassificationCode()
	case asunit.FieldPrincipal:
		return m.Principal()
	case asunit.FieldContact:
		return m.Contact()
	case asunit.FieldCorporateRepresentative:
		return m.CorporateRepresentative()
	case asunit.FieldEconomicType:
		return m.EconomicType()
	case asunit.FieldFinancialAffiliation:
		return m.FinancialAffiliation()
	case asunit.FieldFinancialUnit:
		return m.FinancialUnit()
	case asunit.FieldVerticalUnit:
		return m.VerticalUnit()
	case asunit.FieldVirtualUnit:
		return m.VirtualUnit()
	case asunit.FieldAccountingSystem:
		return m.AccountingSystem()
	case asunit.FieldCorporateTag:
		return m.CorporateTag()
	case asunit.FieldMaintainerMark:
		return m.MaintainerMark()
	case asunit.FieldSupplierMark:
		return m.SupplierMark()
	case asunit.FieldManufactureMark:
		return m.ManufactureMark()
	case asunit.FieldAssetDisposalAgencyTag:
		return m.AssetDisposalAgencyTag()
	case asunit.FieldStateAssetManagementCompany:
		return m.StateAssetManagementCompany()
	case asunit.FieldInstitutionNumber:
		return m.InstitutionNumber()
	case asunit.FieldAuthorizedNumber:
		return m.AuthorizedNumber()
	case asunit.FieldOfSideNumber:
		return m.OfSideNumber()
	case asunit.FieldInstitutionAuthority:
		return m.InstitutionAuthority()
	case asunit.FieldAdministrationAuthority:
		return m.AdministrationAuthority()
	case asunit.FieldEnableTime:
		return m.EnableTime()
	case asunit.FieldDisableTime:
		return m.DisableTime()
	case asunit.FieldSealTime:
		return m.SealTime()
	case asunit.FieldUnitRemark:
		return m.UnitRemark()
	case asunit.FieldAssetDownloadStatus:
		return m.AssetDownloadStatus()
	case asunit.FieldLatitudeAndLongitude:
		return m.LatitudeAndLongitude()
	case asunit.FieldSort:
		return m.Sort()
	case asunit.FieldOrganCode:
		return m.OrganCode()
	case asunit.FieldHadInnerNumber:
		return m.HadInnerNumber()
	case asunit.FieldApproveInnerNumber:
		return m.ApproveInnerNumber()
	case asunit.FieldImg:
		return m.Img()
	case asunit.FieldLinkMan:
		return m.LinkMan()
	case asunit.FieldLinkPhone:
		return m.LinkPhone()
	case asunit.FieldTenantID:
		return m.TenantID()
	case asunit.FieldUnitCode:
		return m.UnitCode()
	case asunit.FieldAuthorityTotal:
		return m.AuthorityTotal()
	case asunit.FieldStaffOnActiveDuty:
		return m.StaffOnActiveDuty()
	case asunit.FieldRetiredStaff:
		return m.RetiredStaff()
	case asunit.FieldOtherStaff:
		return m.OtherStaff()
	case asunit.FieldIsVirtual:
		return m.IsVirtual()
	case asunit.FieldUnitReform:
		return m.UnitReform()
	case asunit.FieldPersonExpenditure:
		return m.PersonExpenditure()
	case asunit.FieldInstitutionType:
		return m.InstitutionType()
	case asunit.FieldDepartmentIdentification:
		return m.DepartmentIdentification()
	case asunit.FieldTotalHeadcount:
		return m.TotalHeadcount()
	case asunit.FieldIsDeleted:
		return m.IsDeleted()
	case asunit.FieldStatus:
		return m.Status()
	case asunit.FieldCreateUser:
		return m.CreateUser()
	case asunit.FieldUpdateUser:
		return m.UpdateUser()
	case asunit.FieldCreateTime:
		return m.CreateTime()
	case asunit.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asunit.FieldUnitName:
		return m.OldUnitName(ctx)
	case asunit.FieldUnitNameEn:
		return m.OldUnitNameEn(ctx)
	case asunit.FieldOrganizationForm:
		return m.OldOrganizationForm(ctx)
	case asunit.FieldUnitType:
		return m.OldUnitType(ctx)
	case asunit.FieldParentNodeName:
		return m.OldParentNodeName(ctx)
	case asunit.FieldChargeSectionID:
		return m.OldChargeSectionID(ctx)
	case asunit.FieldChargeSectionCode:
		return m.OldChargeSectionCode(ctx)
	case asunit.FieldChargeSectionName:
		return m.OldChargeSectionName(ctx)
	case asunit.FieldLocalFinancialCode:
		return m.OldLocalFinancialCode(ctx)
	case asunit.FieldLocalFinancialName:
		return m.OldLocalFinancialName(ctx)
	case asunit.FieldLocalFinancialID:
		return m.OldLocalFinancialID(ctx)
	case asunit.FieldOfficeAdministrationCode:
		return m.OldOfficeAdministrationCode(ctx)
	case asunit.FieldOfficeAdministrationName:
		return m.OldOfficeAdministrationName(ctx)
	case asunit.FieldAdministrationDivisionCode:
		return m.OldAdministrationDivisionCode(ctx)
	case asunit.FieldAdministrationDivisionName:
		return m.OldAdministrationDivisionName(ctx)
	case asunit.FieldBudgetCode:
		return m.OldBudgetCode(ctx)
	case asunit.FieldCollegeCode:
		return m.OldCollegeCode(ctx)
	case asunit.FieldOrganizationCode:
		return m.OldOrganizationCode(ctx)
	case asunit.FieldUnitTypeCode:
		return m.OldUnitTypeCode(ctx)
	case asunit.FieldUnitTypeName:
		return m.OldUnitTypeName(ctx)
	case asunit.FieldUnitBasicProperty:
		return m.OldUnitBasicProperty(ctx)
	case asunit.FieldSocialCreditCode:
		return m.OldSocialCreditCode(ctx)
	case asunit.FieldBudgetUnitName:
		return m.OldBudgetUnitName(ctx)
	case asunit.FieldBudgetUnitCode:
		return m.OldBudgetUnitCode(ctx)
	case asunit.FieldBudgetManagementLevel:
		return m.OldBudgetManagementLevel(ctx)
	case asunit.FieldFirmName:
		return m.OldFirmName(ctx)
	case asunit.FieldFirmCode:
		return m.OldFirmCode(ctx)
	case asunit.FieldTelephoneNumber:
		return m.OldTelephoneNumber(ctx)
	case asunit.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case asunit.FieldFaxNumber:
		return m.OldFaxNumber(ctx)
	case asunit.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case asunit.FieldProvince:
		return m.OldProvince(ctx)
	case asunit.FieldCity:
		return m.OldCity(ctx)
	case asunit.FieldCounty:
		return m.OldCounty(ctx)
	case asunit.FieldStreetAddress:
		return m.OldStreetAddress(ctx)
	case asunit.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case asunit.FieldFundSupplyModeName:
		return m.OldFundSupplyModeName(ctx)
	case asunit.FieldFundSupplyModeCode:
		return m.OldFundSupplyModeCode(ctx)
	case asunit.FieldAdministrationLevelName:
		return m.OldAdministrationLevelName(ctx)
	case asunit.FieldAdministrationLevelType:
		return m.OldAdministrationLevelType(ctx)
	case asunit.FieldDepartmentCategoryName:
		return m.OldDepartmentCategoryName(ctx)
	case asunit.FieldBusinessDepartmentClassificationCode:
		return m.OldBusinessDepartmentClassificationCode(ctx)
	case asunit.FieldPrincipal:
		return m.OldPrincipal(ctx)
	case asunit.FieldContact:
		return m.OldContact(ctx)
	case asunit.FieldCorporateRepresentative:
		return m.OldCorporateRepresentative(ctx)
	case asunit.FieldEconomicType:
		return m.OldEconomicType(ctx)
	case asunit.FieldFinancialAffiliation:
		return m.OldFinancialAffiliation(ctx)
	case asunit.FieldFinancialUnit:
		return m.OldFinancialUnit(ctx)
	case asunit.FieldVerticalUnit:
		return m.OldVerticalUnit(ctx)
	case asunit.FieldVirtualUnit:
		return m.OldVirtualUnit(ctx)
	case asunit.FieldAccountingSystem:
		return m.OldAccountingSystem(ctx)
	case asunit.FieldCorporateTag:
		return m.OldCorporateTag(ctx)
	case asunit.FieldMaintainerMark:
		return m.OldMaintainerMark(ctx)
	case asunit.FieldSupplierMark:
		return m.OldSupplierMark(ctx)
	case asunit.FieldManufactureMark:
		return m.OldManufactureMark(ctx)
	case asunit.FieldAssetDisposalAgencyTag:
		return m.OldAssetDisposalAgencyTag(ctx)
	case asunit.FieldStateAssetManagementCompany:
		return m.OldStateAssetManagementCompany(ctx)
	case asunit.FieldInstitutionNumber:
		return m.OldInstitutionNumber(ctx)
	case asunit.FieldAuthorizedNumber:
		return m.OldAuthorizedNumber(ctx)
	case asunit.FieldOfSideNumber:
		return m.OldOfSideNumber(ctx)
	case asunit.FieldInstitutionAuthority:
		return m.OldInstitutionAuthority(ctx)
	case asunit.FieldAdministrationAuthority:
		return m.OldAdministrationAuthority(ctx)
	case asunit.FieldEnableTime:
		return m.OldEnableTime(ctx)
	case asunit.FieldDisableTime:
		return m.OldDisableTime(ctx)
	case asunit.FieldSealTime:
		return m.OldSealTime(ctx)
	case asunit.FieldUnitRemark:
		return m.OldUnitRemark(ctx)
	case asunit.FieldAssetDownloadStatus:
		return m.OldAssetDownloadStatus(ctx)
	case asunit.FieldLatitudeAndLongitude:
		return m.OldLatitudeAndLongitude(ctx)
	case asunit.FieldSort:
		return m.OldSort(ctx)
	case asunit.FieldOrganCode:
		return m.OldOrganCode(ctx)
	case asunit.FieldHadInnerNumber:
		return m.OldHadInnerNumber(ctx)
	case asunit.FieldApproveInnerNumber:
		return m.OldApproveInnerNumber(ctx)
	case asunit.FieldImg:
		return m.OldImg(ctx)
	case asunit.FieldLinkMan:
		return m.OldLinkMan(ctx)
	case asunit.FieldLinkPhone:
		return m.OldLinkPhone(ctx)
	case asunit.FieldTenantID:
		return m.OldTenantID(ctx)
	case asunit.FieldUnitCode:
		return m.OldUnitCode(ctx)
	case asunit.FieldAuthorityTotal:
		return m.OldAuthorityTotal(ctx)
	case asunit.FieldStaffOnActiveDuty:
		return m.OldStaffOnActiveDuty(ctx)
	case asunit.FieldRetiredStaff:
		return m.OldRetiredStaff(ctx)
	case asunit.FieldOtherStaff:
		return m.OldOtherStaff(ctx)
	case asunit.FieldIsVirtual:
		return m.OldIsVirtual(ctx)
	case asunit.FieldUnitReform:
		return m.OldUnitReform(ctx)
	case asunit.FieldPersonExpenditure:
		return m.OldPersonExpenditure(ctx)
	case asunit.FieldInstitutionType:
		return m.OldInstitutionType(ctx)
	case asunit.FieldDepartmentIdentification:
		return m.OldDepartmentIdentification(ctx)
	case asunit.FieldTotalHeadcount:
		return m.OldTotalHeadcount(ctx)
	case asunit.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asunit.FieldStatus:
		return m.OldStatus(ctx)
	case asunit.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asunit.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asunit.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asunit.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asunit.FieldUnitName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitName(v)
		return nil
	case asunit.FieldUnitNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitNameEn(v)
		return nil
	case asunit.FieldOrganizationForm:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationForm(v)
		return nil
	case asunit.FieldUnitType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitType(v)
		return nil
	case asunit.FieldParentNodeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentNodeName(v)
		return nil
	case asunit.FieldChargeSectionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeSectionID(v)
		return nil
	case asunit.FieldChargeSectionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeSectionCode(v)
		return nil
	case asunit.FieldChargeSectionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeSectionName(v)
		return nil
	case asunit.FieldLocalFinancialCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalFinancialCode(v)
		return nil
	case asunit.FieldLocalFinancialName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalFinancialName(v)
		return nil
	case asunit.FieldLocalFinancialID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalFinancialID(v)
		return nil
	case asunit.FieldOfficeAdministrationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeAdministrationCode(v)
		return nil
	case asunit.FieldOfficeAdministrationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficeAdministrationName(v)
		return nil
	case asunit.FieldAdministrationDivisionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdministrationDivisionCode(v)
		return nil
	case asunit.FieldAdministrationDivisionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdministrationDivisionName(v)
		return nil
	case asunit.FieldBudgetCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudgetCode(v)
		return nil
	case asunit.FieldCollegeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollegeCode(v)
		return nil
	case asunit.FieldOrganizationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationCode(v)
		return nil
	case asunit.FieldUnitTypeCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitTypeCode(v)
		return nil
	case asunit.FieldUnitTypeName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitTypeName(v)
		return nil
	case asunit.FieldUnitBasicProperty:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitBasicProperty(v)
		return nil
	case asunit.FieldSocialCreditCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialCreditCode(v)
		return nil
	case asunit.FieldBudgetUnitName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudgetUnitName(v)
		return nil
	case asunit.FieldBudgetUnitCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudgetUnitCode(v)
		return nil
	case asunit.FieldBudgetManagementLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudgetManagementLevel(v)
		return nil
	case asunit.FieldFirmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirmName(v)
		return nil
	case asunit.FieldFirmCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirmCode(v)
		return nil
	case asunit.FieldTelephoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephoneNumber(v)
		return nil
	case asunit.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case asunit.FieldFaxNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaxNumber(v)
		return nil
	case asunit.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case asunit.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case asunit.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case asunit.FieldCounty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCounty(v)
		return nil
	case asunit.FieldStreetAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetAddress(v)
		return nil
	case asunit.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case asunit.FieldFundSupplyModeName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundSupplyModeName(v)
		return nil
	case asunit.FieldFundSupplyModeCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundSupplyModeCode(v)
		return nil
	case asunit.FieldAdministrationLevelName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdministrationLevelName(v)
		return nil
	case asunit.FieldAdministrationLevelType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdministrationLevelType(v)
		return nil
	case asunit.FieldDepartmentCategoryName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentCategoryName(v)
		return nil
	case asunit.FieldBusinessDepartmentClassificationCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessDepartmentClassificationCode(v)
		return nil
	case asunit.FieldPrincipal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrincipal(v)
		return nil
	case asunit.FieldContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case asunit.FieldCorporateRepresentative:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorporateRepresentative(v)
		return nil
	case asunit.FieldEconomicType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEconomicType(v)
		return nil
	case asunit.FieldFinancialAffiliation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinancialAffiliation(v)
		return nil
	case asunit.FieldFinancialUnit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinancialUnit(v)
		return nil
	case asunit.FieldVerticalUnit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerticalUnit(v)
		return nil
	case asunit.FieldVirtualUnit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVirtualUnit(v)
		return nil
	case asunit.FieldAccountingSystem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountingSystem(v)
		return nil
	case asunit.FieldCorporateTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorporateTag(v)
		return nil
	case asunit.FieldMaintainerMark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainerMark(v)
		return nil
	case asunit.FieldSupplierMark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierMark(v)
		return nil
	case asunit.FieldManufactureMark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufactureMark(v)
		return nil
	case asunit.FieldAssetDisposalAgencyTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetDisposalAgencyTag(v)
		return nil
	case asunit.FieldStateAssetManagementCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateAssetManagementCompany(v)
		return nil
	case asunit.FieldInstitutionNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitutionNumber(v)
		return nil
	case asunit.FieldAuthorizedNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizedNumber(v)
		return nil
	case asunit.FieldOfSideNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfSideNumber(v)
		return nil
	case asunit.FieldInstitutionAuthority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitutionAuthority(v)
		return nil
	case asunit.FieldAdministrationAuthority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdministrationAuthority(v)
		return nil
	case asunit.FieldEnableTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableTime(v)
		return nil
	case asunit.FieldDisableTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisableTime(v)
		return nil
	case asunit.FieldSealTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSealTime(v)
		return nil
	case asunit.FieldUnitRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitRemark(v)
		return nil
	case asunit.FieldAssetDownloadStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetDownloadStatus(v)
		return nil
	case asunit.FieldLatitudeAndLongitude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitudeAndLongitude(v)
		return nil
	case asunit.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case asunit.FieldOrganCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganCode(v)
		return nil
	case asunit.FieldHadInnerNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHadInnerNumber(v)
		return nil
	case asunit.FieldApproveInnerNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproveInnerNumber(v)
		return nil
	case asunit.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case asunit.FieldLinkMan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkMan(v)
		return nil
	case asunit.FieldLinkPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkPhone(v)
		return nil
	case asunit.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case asunit.FieldUnitCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCode(v)
		return nil
	case asunit.FieldAuthorityTotal:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorityTotal(v)
		return nil
	case asunit.FieldStaffOnActiveDuty:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffOnActiveDuty(v)
		return nil
	case asunit.FieldRetiredStaff:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetiredStaff(v)
		return nil
	case asunit.FieldOtherStaff:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherStaff(v)
		return nil
	case asunit.FieldIsVirtual:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVirtual(v)
		return nil
	case asunit.FieldUnitReform:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitReform(v)
		return nil
	case asunit.FieldPersonExpenditure:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonExpenditure(v)
		return nil
	case asunit.FieldInstitutionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitutionType(v)
		return nil
	case asunit.FieldDepartmentIdentification:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentIdentification(v)
		return nil
	case asunit.FieldTotalHeadcount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalHeadcount(v)
		return nil
	case asunit.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asunit.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asunit.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asunit.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asunit.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asunit.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsUnitMutation) AddedFields() []string {
	var fields []string
	if m.addorganization_form != nil {
		fields = append(fields, asunit.FieldOrganizationForm)
	}
	if m.addunit_type != nil {
		fields = append(fields, asunit.FieldUnitType)
	}
	if m.addcharge_section_id != nil {
		fields = append(fields, asunit.FieldChargeSectionID)
	}
	if m.addbudget_code != nil {
		fields = append(fields, asunit.FieldBudgetCode)
	}
	if m.addunit_type_code != nil {
		fields = append(fields, asunit.FieldUnitTypeCode)
	}
	if m.addunit_type_name != nil {
		fields = append(fields, asunit.FieldUnitTypeName)
	}
	if m.addunit_basic_property != nil {
		fields = append(fields, asunit.FieldUnitBasicProperty)
	}
	if m.addbudget_management_level != nil {
		fields = append(fields, asunit.FieldBudgetManagementLevel)
	}
	if m.addfund_supply_mode_name != nil {
		fields = append(fields, asunit.FieldFundSupplyModeName)
	}
	if m.addfund_supply_mode_code != nil {
		fields = append(fields, asunit.FieldFundSupplyModeCode)
	}
	if m.addadministration_level_name != nil {
		fields = append(fields, asunit.FieldAdministrationLevelName)
	}
	if m.addadministration_level_type != nil {
		fields = append(fields, asunit.FieldAdministrationLevelType)
	}
	if m.adddepartment_category_name != nil {
		fields = append(fields, asunit.FieldDepartmentCategoryName)
	}
	if m.addbusiness_department_classification_code != nil {
		fields = append(fields, asunit.FieldBusinessDepartmentClassificationCode)
	}
	if m.addeconomic_type != nil {
		fields = append(fields, asunit.FieldEconomicType)
	}
	if m.addfinancial_unit != nil {
		fields = append(fields, asunit.FieldFinancialUnit)
	}
	if m.addvertical_unit != nil {
		fields = append(fields, asunit.FieldVerticalUnit)
	}
	if m.addvirtual_unit != nil {
		fields = append(fields, asunit.FieldVirtualUnit)
	}
	if m.addaccounting_system != nil {
		fields = append(fields, asunit.FieldAccountingSystem)
	}
	if m.addinstitution_number != nil {
		fields = append(fields, asunit.FieldInstitutionNumber)
	}
	if m.addauthorized_number != nil {
		fields = append(fields, asunit.FieldAuthorizedNumber)
	}
	if m.addof_side_number != nil {
		fields = append(fields, asunit.FieldOfSideNumber)
	}
	if m.addsort != nil {
		fields = append(fields, asunit.FieldSort)
	}
	if m.addhad_inner_number != nil {
		fields = append(fields, asunit.FieldHadInnerNumber)
	}
	if m.addapprove_inner_number != nil {
		fields = append(fields, asunit.FieldApproveInnerNumber)
	}
	if m.addauthority_total != nil {
		fields = append(fields, asunit.FieldAuthorityTotal)
	}
	if m.addstaff_on_active_duty != nil {
		fields = append(fields, asunit.FieldStaffOnActiveDuty)
	}
	if m.addretired_staff != nil {
		fields = append(fields, asunit.FieldRetiredStaff)
	}
	if m.addother_staff != nil {
		fields = append(fields, asunit.FieldOtherStaff)
	}
	if m.addunit_reform != nil {
		fields = append(fields, asunit.FieldUnitReform)
	}
	if m.addperson_expenditure != nil {
		fields = append(fields, asunit.FieldPersonExpenditure)
	}
	if m.adddepartment_identification != nil {
		fields = append(fields, asunit.FieldDepartmentIdentification)
	}
	if m.addtotal_headcount != nil {
		fields = append(fields, asunit.FieldTotalHeadcount)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asunit.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asunit.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asunit.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asunit.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsUnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asunit.FieldOrganizationForm:
		return m.AddedOrganizationForm()
	case asunit.FieldUnitType:
		return m.AddedUnitType()
	case asunit.FieldChargeSectionID:
		return m.AddedChargeSectionID()
	case asunit.FieldBudgetCode:
		return m.AddedBudgetCode()
	case asunit.FieldUnitTypeCode:
		return m.AddedUnitTypeCode()
	case asunit.FieldUnitTypeName:
		return m.AddedUnitTypeName()
	case asunit.FieldUnitBasicProperty:
		return m.AddedUnitBasicProperty()
	case asunit.FieldBudgetManagementLevel:
		return m.AddedBudgetManagementLevel()
	case asunit.FieldFundSupplyModeName:
		return m.AddedFundSupplyModeName()
	case asunit.FieldFundSupplyModeCode:
		return m.AddedFundSupplyModeCode()
	case asunit.FieldAdministrationLevelName:
		return m.AddedAdministrationLevelName()
	case asunit.FieldAdministrationLevelType:
		return m.AddedAdministrationLevelType()
	case asunit.FieldDepartmentCategoryName:
		return m.AddedDepartmentCategoryName()
	case asunit.FieldBusinessDepartmentClassificationCode:
		return m.AddedBusinessDepartmentClassificationCode()
	case asunit.FieldEconomicType:
		return m.AddedEconomicType()
	case asunit.FieldFinancialUnit:
		return m.AddedFinancialUnit()
	case asunit.FieldVerticalUnit:
		return m.AddedVerticalUnit()
	case asunit.FieldVirtualUnit:
		return m.AddedVirtualUnit()
	case asunit.FieldAccountingSystem:
		return m.AddedAccountingSystem()
	case asunit.FieldInstitutionNumber:
		return m.AddedInstitutionNumber()
	case asunit.FieldAuthorizedNumber:
		return m.AddedAuthorizedNumber()
	case asunit.FieldOfSideNumber:
		return m.AddedOfSideNumber()
	case asunit.FieldSort:
		return m.AddedSort()
	case asunit.FieldHadInnerNumber:
		return m.AddedHadInnerNumber()
	case asunit.FieldApproveInnerNumber:
		return m.AddedApproveInnerNumber()
	case asunit.FieldAuthorityTotal:
		return m.AddedAuthorityTotal()
	case asunit.FieldStaffOnActiveDuty:
		return m.AddedStaffOnActiveDuty()
	case asunit.FieldRetiredStaff:
		return m.AddedRetiredStaff()
	case asunit.FieldOtherStaff:
		return m.AddedOtherStaff()
	case asunit.FieldUnitReform:
		return m.AddedUnitReform()
	case asunit.FieldPersonExpenditure:
		return m.AddedPersonExpenditure()
	case asunit.FieldDepartmentIdentification:
		return m.AddedDepartmentIdentification()
	case asunit.FieldTotalHeadcount:
		return m.AddedTotalHeadcount()
	case asunit.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asunit.FieldStatus:
		return m.AddedStatus()
	case asunit.FieldCreateUser:
		return m.AddedCreateUser()
	case asunit.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asunit.FieldOrganizationForm:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrganizationForm(v)
		return nil
	case asunit.FieldUnitType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitType(v)
		return nil
	case asunit.FieldChargeSectionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChargeSectionID(v)
		return nil
	case asunit.FieldBudgetCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBudgetCode(v)
		return nil
	case asunit.FieldUnitTypeCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitTypeCode(v)
		return nil
	case asunit.FieldUnitTypeName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitTypeName(v)
		return nil
	case asunit.FieldUnitBasicProperty:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitBasicProperty(v)
		return nil
	case asunit.FieldBudgetManagementLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBudgetManagementLevel(v)
		return nil
	case asunit.FieldFundSupplyModeName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFundSupplyModeName(v)
		return nil
	case asunit.FieldFundSupplyModeCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFundSupplyModeCode(v)
		return nil
	case asunit.FieldAdministrationLevelName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdministrationLevelName(v)
		return nil
	case asunit.FieldAdministrationLevelType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdministrationLevelType(v)
		return nil
	case asunit.FieldDepartmentCategoryName:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepartmentCategoryName(v)
		return nil
	case asunit.FieldBusinessDepartmentClassificationCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBusinessDepartmentClassificationCode(v)
		return nil
	case asunit.FieldEconomicType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEconomicType(v)
		return nil
	case asunit.FieldFinancialUnit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinancialUnit(v)
		return nil
	case asunit.FieldVerticalUnit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVerticalUnit(v)
		return nil
	case asunit.FieldVirtualUnit:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVirtualUnit(v)
		return nil
	case asunit.FieldAccountingSystem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountingSystem(v)
		return nil
	case asunit.FieldInstitutionNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInstitutionNumber(v)
		return nil
	case asunit.FieldAuthorizedNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorizedNumber(v)
		return nil
	case asunit.FieldOfSideNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOfSideNumber(v)
		return nil
	case asunit.FieldSort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case asunit.FieldHadInnerNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHadInnerNumber(v)
		return nil
	case asunit.FieldApproveInnerNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApproveInnerNumber(v)
		return nil
	case asunit.FieldAuthorityTotal:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorityTotal(v)
		return nil
	case asunit.FieldStaffOnActiveDuty:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStaffOnActiveDuty(v)
		return nil
	case asunit.FieldRetiredStaff:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetiredStaff(v)
		return nil
	case asunit.FieldOtherStaff:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOtherStaff(v)
		return nil
	case asunit.FieldUnitReform:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitReform(v)
		return nil
	case asunit.FieldPersonExpenditure:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPersonExpenditure(v)
		return nil
	case asunit.FieldDepartmentIdentification:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepartmentIdentification(v)
		return nil
	case asunit.FieldTotalHeadcount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalHeadcount(v)
		return nil
	case asunit.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asunit.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asunit.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asunit.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsUnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asunit.FieldUnitNameEn) {
		fields = append(fields, asunit.FieldUnitNameEn)
	}
	if m.FieldCleared(asunit.FieldOrganizationForm) {
		fields = append(fields, asunit.FieldOrganizationForm)
	}
	if m.FieldCleared(asunit.FieldUnitType) {
		fields = append(fields, asunit.FieldUnitType)
	}
	if m.FieldCleared(asunit.FieldParentNodeName) {
		fields = append(fields, asunit.FieldParentNodeName)
	}
	if m.FieldCleared(asunit.FieldChargeSectionID) {
		fields = append(fields, asunit.FieldChargeSectionID)
	}
	if m.FieldCleared(asunit.FieldChargeSectionCode) {
		fields = append(fields, asunit.FieldChargeSectionCode)
	}
	if m.FieldCleared(asunit.FieldChargeSectionName) {
		fields = append(fields, asunit.FieldChargeSectionName)
	}
	if m.FieldCleared(asunit.FieldLocalFinancialCode) {
		fields = append(fields, asunit.FieldLocalFinancialCode)
	}
	if m.FieldCleared(asunit.FieldLocalFinancialName) {
		fields = append(fields, asunit.FieldLocalFinancialName)
	}
	if m.FieldCleared(asunit.FieldLocalFinancialID) {
		fields = append(fields, asunit.FieldLocalFinancialID)
	}
	if m.FieldCleared(asunit.FieldOfficeAdministrationCode) {
		fields = append(fields, asunit.FieldOfficeAdministrationCode)
	}
	if m.FieldCleared(asunit.FieldOfficeAdministrationName) {
		fields = append(fields, asunit.FieldOfficeAdministrationName)
	}
	if m.FieldCleared(asunit.FieldAdministrationDivisionCode) {
		fields = append(fields, asunit.FieldAdministrationDivisionCode)
	}
	if m.FieldCleared(asunit.FieldAdministrationDivisionName) {
		fields = append(fields, asunit.FieldAdministrationDivisionName)
	}
	if m.FieldCleared(asunit.FieldBudgetCode) {
		fields = append(fields, asunit.FieldBudgetCode)
	}
	if m.FieldCleared(asunit.FieldCollegeCode) {
		fields = append(fields, asunit.FieldCollegeCode)
	}
	if m.FieldCleared(asunit.FieldOrganizationCode) {
		fields = append(fields, asunit.FieldOrganizationCode)
	}
	if m.FieldCleared(asunit.FieldUnitTypeCode) {
		fields = append(fields, asunit.FieldUnitTypeCode)
	}
	if m.FieldCleared(asunit.FieldUnitTypeName) {
		fields = append(fields, asunit.FieldUnitTypeName)
	}
	if m.FieldCleared(asunit.FieldUnitBasicProperty) {
		fields = append(fields, asunit.FieldUnitBasicProperty)
	}
	if m.FieldCleared(asunit.FieldSocialCreditCode) {
		fields = append(fields, asunit.FieldSocialCreditCode)
	}
	if m.FieldCleared(asunit.FieldBudgetUnitName) {
		fields = append(fields, asunit.FieldBudgetUnitName)
	}
	if m.FieldCleared(asunit.FieldBudgetUnitCode) {
		fields = append(fields, asunit.FieldBudgetUnitCode)
	}
	if m.FieldCleared(asunit.FieldBudgetManagementLevel) {
		fields = append(fields, asunit.FieldBudgetManagementLevel)
	}
	if m.FieldCleared(asunit.FieldFirmName) {
		fields = append(fields, asunit.FieldFirmName)
	}
	if m.FieldCleared(asunit.FieldFirmCode) {
		fields = append(fields, asunit.FieldFirmCode)
	}
	if m.FieldCleared(asunit.FieldTelephoneNumber) {
		fields = append(fields, asunit.FieldTelephoneNumber)
	}
	if m.FieldCleared(asunit.FieldPhoneNumber) {
		fields = append(fields, asunit.FieldPhoneNumber)
	}
	if m.FieldCleared(asunit.FieldFaxNumber) {
		fields = append(fields, asunit.FieldFaxNumber)
	}
	if m.FieldCleared(asunit.FieldEmailAddress) {
		fields = append(fields, asunit.FieldEmailAddress)
	}
	if m.FieldCleared(asunit.FieldProvince) {
		fields = append(fields, asunit.FieldProvince)
	}
	if m.FieldCleared(asunit.FieldCity) {
		fields = append(fields, asunit.FieldCity)
	}
	if m.FieldCleared(asunit.FieldCounty) {
		fields = append(fields, asunit.FieldCounty)
	}
	if m.FieldCleared(asunit.FieldStreetAddress) {
		fields = append(fields, asunit.FieldStreetAddress)
	}
	if m.FieldCleared(asunit.FieldPostalCode) {
		fields = append(fields, asunit.FieldPostalCode)
	}
	if m.FieldCleared(asunit.FieldFundSupplyModeName) {
		fields = append(fields, asunit.FieldFundSupplyModeName)
	}
	if m.FieldCleared(asunit.FieldFundSupplyModeCode) {
		fields = append(fields, asunit.FieldFundSupplyModeCode)
	}
	if m.FieldCleared(asunit.FieldAdministrationLevelName) {
		fields = append(fields, asunit.FieldAdministrationLevelName)
	}
	if m.FieldCleared(asunit.FieldAdministrationLevelType) {
		fields = append(fields, asunit.FieldAdministrationLevelType)
	}
	if m.FieldCleared(asunit.FieldDepartmentCategoryName) {
		fields = append(fields, asunit.FieldDepartmentCategoryName)
	}
	if m.FieldCleared(asunit.FieldBusinessDepartmentClassificationCode) {
		fields = append(fields, asunit.FieldBusinessDepartmentClassificationCode)
	}
	if m.FieldCleared(asunit.FieldPrincipal) {
		fields = append(fields, asunit.FieldPrincipal)
	}
	if m.FieldCleared(asunit.FieldContact) {
		fields = append(fields, asunit.FieldContact)
	}
	if m.FieldCleared(asunit.FieldCorporateRepresentative) {
		fields = append(fields, asunit.FieldCorporateRepresentative)
	}
	if m.FieldCleared(asunit.FieldEconomicType) {
		fields = append(fields, asunit.FieldEconomicType)
	}
	if m.FieldCleared(asunit.FieldFinancialAffiliation) {
		fields = append(fields, asunit.FieldFinancialAffiliation)
	}
	if m.FieldCleared(asunit.FieldFinancialUnit) {
		fields = append(fields, asunit.FieldFinancialUnit)
	}
	if m.FieldCleared(asunit.FieldVerticalUnit) {
		fields = append(fields, asunit.FieldVerticalUnit)
	}
	if m.FieldCleared(asunit.FieldVirtualUnit) {
		fields = append(fields, asunit.FieldVirtualUnit)
	}
	if m.FieldCleared(asunit.FieldAccountingSystem) {
		fields = append(fields, asunit.FieldAccountingSystem)
	}
	if m.FieldCleared(asunit.FieldCorporateTag) {
		fields = append(fields, asunit.FieldCorporateTag)
	}
	if m.FieldCleared(asunit.FieldMaintainerMark) {
		fields = append(fields, asunit.FieldMaintainerMark)
	}
	if m.FieldCleared(asunit.FieldSupplierMark) {
		fields = append(fields, asunit.FieldSupplierMark)
	}
	if m.FieldCleared(asunit.FieldManufactureMark) {
		fields = append(fields, asunit.FieldManufactureMark)
	}
	if m.FieldCleared(asunit.FieldAssetDisposalAgencyTag) {
		fields = append(fields, asunit.FieldAssetDisposalAgencyTag)
	}
	if m.FieldCleared(asunit.FieldStateAssetManagementCompany) {
		fields = append(fields, asunit.FieldStateAssetManagementCompany)
	}
	if m.FieldCleared(asunit.FieldInstitutionNumber) {
		fields = append(fields, asunit.FieldInstitutionNumber)
	}
	if m.FieldCleared(asunit.FieldAuthorizedNumber) {
		fields = append(fields, asunit.FieldAuthorizedNumber)
	}
	if m.FieldCleared(asunit.FieldOfSideNumber) {
		fields = append(fields, asunit.FieldOfSideNumber)
	}
	if m.FieldCleared(asunit.FieldInstitutionAuthority) {
		fields = append(fields, asunit.FieldInstitutionAuthority)
	}
	if m.FieldCleared(asunit.FieldAdministrationAuthority) {
		fields = append(fields, asunit.FieldAdministrationAuthority)
	}
	if m.FieldCleared(asunit.FieldEnableTime) {
		fields = append(fields, asunit.FieldEnableTime)
	}
	if m.FieldCleared(asunit.FieldDisableTime) {
		fields = append(fields, asunit.FieldDisableTime)
	}
	if m.FieldCleared(asunit.FieldSealTime) {
		fields = append(fields, asunit.FieldSealTime)
	}
	if m.FieldCleared(asunit.FieldUnitRemark) {
		fields = append(fields, asunit.FieldUnitRemark)
	}
	if m.FieldCleared(asunit.FieldAssetDownloadStatus) {
		fields = append(fields, asunit.FieldAssetDownloadStatus)
	}
	if m.FieldCleared(asunit.FieldLatitudeAndLongitude) {
		fields = append(fields, asunit.FieldLatitudeAndLongitude)
	}
	if m.FieldCleared(asunit.FieldSort) {
		fields = append(fields, asunit.FieldSort)
	}
	if m.FieldCleared(asunit.FieldOrganCode) {
		fields = append(fields, asunit.FieldOrganCode)
	}
	if m.FieldCleared(asunit.FieldHadInnerNumber) {
		fields = append(fields, asunit.FieldHadInnerNumber)
	}
	if m.FieldCleared(asunit.FieldApproveInnerNumber) {
		fields = append(fields, asunit.FieldApproveInnerNumber)
	}
	if m.FieldCleared(asunit.FieldImg) {
		fields = append(fields, asunit.FieldImg)
	}
	if m.FieldCleared(asunit.FieldLinkMan) {
		fields = append(fields, asunit.FieldLinkMan)
	}
	if m.FieldCleared(asunit.FieldLinkPhone) {
		fields = append(fields, asunit.FieldLinkPhone)
	}
	if m.FieldCleared(asunit.FieldTenantID) {
		fields = append(fields, asunit.FieldTenantID)
	}
	if m.FieldCleared(asunit.FieldUnitCode) {
		fields = append(fields, asunit.FieldUnitCode)
	}
	if m.FieldCleared(asunit.FieldAuthorityTotal) {
		fields = append(fields, asunit.FieldAuthorityTotal)
	}
	if m.FieldCleared(asunit.FieldStaffOnActiveDuty) {
		fields = append(fields, asunit.FieldStaffOnActiveDuty)
	}
	if m.FieldCleared(asunit.FieldRetiredStaff) {
		fields = append(fields, asunit.FieldRetiredStaff)
	}
	if m.FieldCleared(asunit.FieldOtherStaff) {
		fields = append(fields, asunit.FieldOtherStaff)
	}
	if m.FieldCleared(asunit.FieldUnitReform) {
		fields = append(fields, asunit.FieldUnitReform)
	}
	if m.FieldCleared(asunit.FieldPersonExpenditure) {
		fields = append(fields, asunit.FieldPersonExpenditure)
	}
	if m.FieldCleared(asunit.FieldInstitutionType) {
		fields = append(fields, asunit.FieldInstitutionType)
	}
	if m.FieldCleared(asunit.FieldDepartmentIdentification) {
		fields = append(fields, asunit.FieldDepartmentIdentification)
	}
	if m.FieldCleared(asunit.FieldTotalHeadcount) {
		fields = append(fields, asunit.FieldTotalHeadcount)
	}
	if m.FieldCleared(asunit.FieldStatus) {
		fields = append(fields, asunit.FieldStatus)
	}
	if m.FieldCleared(asunit.FieldCreateUser) {
		fields = append(fields, asunit.FieldCreateUser)
	}
	if m.FieldCleared(asunit.FieldUpdateUser) {
		fields = append(fields, asunit.FieldUpdateUser)
	}
	if m.FieldCleared(asunit.FieldCreateTime) {
		fields = append(fields, asunit.FieldCreateTime)
	}
	if m.FieldCleared(asunit.FieldUpdateTime) {
		fields = append(fields, asunit.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsUnitMutation) ClearField(name string) error {
	switch name {
	case asunit.FieldUnitNameEn:
		m.ClearUnitNameEn()
		return nil
	case asunit.FieldOrganizationForm:
		m.ClearOrganizationForm()
		return nil
	case asunit.FieldUnitType:
		m.ClearUnitType()
		return nil
	case asunit.FieldParentNodeName:
		m.ClearParentNodeName()
		return nil
	case asunit.FieldChargeSectionID:
		m.ClearChargeSectionID()
		return nil
	case asunit.FieldChargeSectionCode:
		m.ClearChargeSectionCode()
		return nil
	case asunit.FieldChargeSectionName:
		m.ClearChargeSectionName()
		return nil
	case asunit.FieldLocalFinancialCode:
		m.ClearLocalFinancialCode()
		return nil
	case asunit.FieldLocalFinancialName:
		m.ClearLocalFinancialName()
		return nil
	case asunit.FieldLocalFinancialID:
		m.ClearLocalFinancialID()
		return nil
	case asunit.FieldOfficeAdministrationCode:
		m.ClearOfficeAdministrationCode()
		return nil
	case asunit.FieldOfficeAdministrationName:
		m.ClearOfficeAdministrationName()
		return nil
	case asunit.FieldAdministrationDivisionCode:
		m.ClearAdministrationDivisionCode()
		return nil
	case asunit.FieldAdministrationDivisionName:
		m.ClearAdministrationDivisionName()
		return nil
	case asunit.FieldBudgetCode:
		m.ClearBudgetCode()
		return nil
	case asunit.FieldCollegeCode:
		m.ClearCollegeCode()
		return nil
	case asunit.FieldOrganizationCode:
		m.ClearOrganizationCode()
		return nil
	case asunit.FieldUnitTypeCode:
		m.ClearUnitTypeCode()
		return nil
	case asunit.FieldUnitTypeName:
		m.ClearUnitTypeName()
		return nil
	case asunit.FieldUnitBasicProperty:
		m.ClearUnitBasicProperty()
		return nil
	case asunit.FieldSocialCreditCode:
		m.ClearSocialCreditCode()
		return nil
	case asunit.FieldBudgetUnitName:
		m.ClearBudgetUnitName()
		return nil
	case asunit.FieldBudgetUnitCode:
		m.ClearBudgetUnitCode()
		return nil
	case asunit.FieldBudgetManagementLevel:
		m.ClearBudgetManagementLevel()
		return nil
	case asunit.FieldFirmName:
		m.ClearFirmName()
		return nil
	case asunit.FieldFirmCode:
		m.ClearFirmCode()
		return nil
	case asunit.FieldTelephoneNumber:
		m.ClearTelephoneNumber()
		return nil
	case asunit.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case asunit.FieldFaxNumber:
		m.ClearFaxNumber()
		return nil
	case asunit.FieldEmailAddress:
		m.ClearEmailAddress()
		return nil
	case asunit.FieldProvince:
		m.ClearProvince()
		return nil
	case asunit.FieldCity:
		m.ClearCity()
		return nil
	case asunit.FieldCounty:
		m.ClearCounty()
		return nil
	case asunit.FieldStreetAddress:
		m.ClearStreetAddress()
		return nil
	case asunit.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case asunit.FieldFundSupplyModeName:
		m.ClearFundSupplyModeName()
		return nil
	case asunit.FieldFundSupplyModeCode:
		m.ClearFundSupplyModeCode()
		return nil
	case asunit.FieldAdministrationLevelName:
		m.ClearAdministrationLevelName()
		return nil
	case asunit.FieldAdministrationLevelType:
		m.ClearAdministrationLevelType()
		return nil
	case asunit.FieldDepartmentCategoryName:
		m.ClearDepartmentCategoryName()
		return nil
	case asunit.FieldBusinessDepartmentClassificationCode:
		m.ClearBusinessDepartmentClassificationCode()
		return nil
	case asunit.FieldPrincipal:
		m.ClearPrincipal()
		return nil
	case asunit.FieldContact:
		m.ClearContact()
		return nil
	case asunit.FieldCorporateRepresentative:
		m.ClearCorporateRepresentative()
		return nil
	case asunit.FieldEconomicType:
		m.ClearEconomicType()
		return nil
	case asunit.FieldFinancialAffiliation:
		m.ClearFinancialAffiliation()
		return nil
	case asunit.FieldFinancialUnit:
		m.ClearFinancialUnit()
		return nil
	case asunit.FieldVerticalUnit:
		m.ClearVerticalUnit()
		return nil
	case asunit.FieldVirtualUnit:
		m.ClearVirtualUnit()
		return nil
	case asunit.FieldAccountingSystem:
		m.ClearAccountingSystem()
		return nil
	case asunit.FieldCorporateTag:
		m.ClearCorporateTag()
		return nil
	case asunit.FieldMaintainerMark:
		m.ClearMaintainerMark()
		return nil
	case asunit.FieldSupplierMark:
		m.ClearSupplierMark()
		return nil
	case asunit.FieldManufactureMark:
		m.ClearManufactureMark()
		return nil
	case asunit.FieldAssetDisposalAgencyTag:
		m.ClearAssetDisposalAgencyTag()
		return nil
	case asunit.FieldStateAssetManagementCompany:
		m.ClearStateAssetManagementCompany()
		return nil
	case asunit.FieldInstitutionNumber:
		m.ClearInstitutionNumber()
		return nil
	case asunit.FieldAuthorizedNumber:
		m.ClearAuthorizedNumber()
		return nil
	case asunit.FieldOfSideNumber:
		m.ClearOfSideNumber()
		return nil
	case asunit.FieldInstitutionAuthority:
		m.ClearInstitutionAuthority()
		return nil
	case asunit.FieldAdministrationAuthority:
		m.ClearAdministrationAuthority()
		return nil
	case asunit.FieldEnableTime:
		m.ClearEnableTime()
		return nil
	case asunit.FieldDisableTime:
		m.ClearDisableTime()
		return nil
	case asunit.FieldSealTime:
		m.ClearSealTime()
		return nil
	case asunit.FieldUnitRemark:
		m.ClearUnitRemark()
		return nil
	case asunit.FieldAssetDownloadStatus:
		m.ClearAssetDownloadStatus()
		return nil
	case asunit.FieldLatitudeAndLongitude:
		m.ClearLatitudeAndLongitude()
		return nil
	case asunit.FieldSort:
		m.ClearSort()
		return nil
	case asunit.FieldOrganCode:
		m.ClearOrganCode()
		return nil
	case asunit.FieldHadInnerNumber:
		m.ClearHadInnerNumber()
		return nil
	case asunit.FieldApproveInnerNumber:
		m.ClearApproveInnerNumber()
		return nil
	case asunit.FieldImg:
		m.ClearImg()
		return nil
	case asunit.FieldLinkMan:
		m.ClearLinkMan()
		return nil
	case asunit.FieldLinkPhone:
		m.ClearLinkPhone()
		return nil
	case asunit.FieldTenantID:
		m.ClearTenantID()
		return nil
	case asunit.FieldUnitCode:
		m.ClearUnitCode()
		return nil
	case asunit.FieldAuthorityTotal:
		m.ClearAuthorityTotal()
		return nil
	case asunit.FieldStaffOnActiveDuty:
		m.ClearStaffOnActiveDuty()
		return nil
	case asunit.FieldRetiredStaff:
		m.ClearRetiredStaff()
		return nil
	case asunit.FieldOtherStaff:
		m.ClearOtherStaff()
		return nil
	case asunit.FieldUnitReform:
		m.ClearUnitReform()
		return nil
	case asunit.FieldPersonExpenditure:
		m.ClearPersonExpenditure()
		return nil
	case asunit.FieldInstitutionType:
		m.ClearInstitutionType()
		return nil
	case asunit.FieldDepartmentIdentification:
		m.ClearDepartmentIdentification()
		return nil
	case asunit.FieldTotalHeadcount:
		m.ClearTotalHeadcount()
		return nil
	case asunit.FieldStatus:
		m.ClearStatus()
		return nil
	case asunit.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asunit.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asunit.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asunit.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsUnitMutation) ResetField(name string) error {
	switch name {
	case asunit.FieldUnitName:
		m.ResetUnitName()
		return nil
	case asunit.FieldUnitNameEn:
		m.ResetUnitNameEn()
		return nil
	case asunit.FieldOrganizationForm:
		m.ResetOrganizationForm()
		return nil
	case asunit.FieldUnitType:
		m.ResetUnitType()
		return nil
	case asunit.FieldParentNodeName:
		m.ResetParentNodeName()
		return nil
	case asunit.FieldChargeSectionID:
		m.ResetChargeSectionID()
		return nil
	case asunit.FieldChargeSectionCode:
		m.ResetChargeSectionCode()
		return nil
	case asunit.FieldChargeSectionName:
		m.ResetChargeSectionName()
		return nil
	case asunit.FieldLocalFinancialCode:
		m.ResetLocalFinancialCode()
		return nil
	case asunit.FieldLocalFinancialName:
		m.ResetLocalFinancialName()
		return nil
	case asunit.FieldLocalFinancialID:
		m.ResetLocalFinancialID()
		return nil
	case asunit.FieldOfficeAdministrationCode:
		m.ResetOfficeAdministrationCode()
		return nil
	case asunit.FieldOfficeAdministrationName:
		m.ResetOfficeAdministrationName()
		return nil
	case asunit.FieldAdministrationDivisionCode:
		m.ResetAdministrationDivisionCode()
		return nil
	case asunit.FieldAdministrationDivisionName:
		m.ResetAdministrationDivisionName()
		return nil
	case asunit.FieldBudgetCode:
		m.ResetBudgetCode()
		return nil
	case asunit.FieldCollegeCode:
		m.ResetCollegeCode()
		return nil
	case asunit.FieldOrganizationCode:
		m.ResetOrganizationCode()
		return nil
	case asunit.FieldUnitTypeCode:
		m.ResetUnitTypeCode()
		return nil
	case asunit.FieldUnitTypeName:
		m.ResetUnitTypeName()
		return nil
	case asunit.FieldUnitBasicProperty:
		m.ResetUnitBasicProperty()
		return nil
	case asunit.FieldSocialCreditCode:
		m.ResetSocialCreditCode()
		return nil
	case asunit.FieldBudgetUnitName:
		m.ResetBudgetUnitName()
		return nil
	case asunit.FieldBudgetUnitCode:
		m.ResetBudgetUnitCode()
		return nil
	case asunit.FieldBudgetManagementLevel:
		m.ResetBudgetManagementLevel()
		return nil
	case asunit.FieldFirmName:
		m.ResetFirmName()
		return nil
	case asunit.FieldFirmCode:
		m.ResetFirmCode()
		return nil
	case asunit.FieldTelephoneNumber:
		m.ResetTelephoneNumber()
		return nil
	case asunit.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case asunit.FieldFaxNumber:
		m.ResetFaxNumber()
		return nil
	case asunit.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case asunit.FieldProvince:
		m.ResetProvince()
		return nil
	case asunit.FieldCity:
		m.ResetCity()
		return nil
	case asunit.FieldCounty:
		m.ResetCounty()
		return nil
	case asunit.FieldStreetAddress:
		m.ResetStreetAddress()
		return nil
	case asunit.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case asunit.FieldFundSupplyModeName:
		m.ResetFundSupplyModeName()
		return nil
	case asunit.FieldFundSupplyModeCode:
		m.ResetFundSupplyModeCode()
		return nil
	case asunit.FieldAdministrationLevelName:
		m.ResetAdministrationLevelName()
		return nil
	case asunit.FieldAdministrationLevelType:
		m.ResetAdministrationLevelType()
		return nil
	case asunit.FieldDepartmentCategoryName:
		m.ResetDepartmentCategoryName()
		return nil
	case asunit.FieldBusinessDepartmentClassificationCode:
		m.ResetBusinessDepartmentClassificationCode()
		return nil
	case asunit.FieldPrincipal:
		m.ResetPrincipal()
		return nil
	case asunit.FieldContact:
		m.ResetContact()
		return nil
	case asunit.FieldCorporateRepresentative:
		m.ResetCorporateRepresentative()
		return nil
	case asunit.FieldEconomicType:
		m.ResetEconomicType()
		return nil
	case asunit.FieldFinancialAffiliation:
		m.ResetFinancialAffiliation()
		return nil
	case asunit.FieldFinancialUnit:
		m.ResetFinancialUnit()
		return nil
	case asunit.FieldVerticalUnit:
		m.ResetVerticalUnit()
		return nil
	case asunit.FieldVirtualUnit:
		m.ResetVirtualUnit()
		return nil
	case asunit.FieldAccountingSystem:
		m.ResetAccountingSystem()
		return nil
	case asunit.FieldCorporateTag:
		m.ResetCorporateTag()
		return nil
	case asunit.FieldMaintainerMark:
		m.ResetMaintainerMark()
		return nil
	case asunit.FieldSupplierMark:
		m.ResetSupplierMark()
		return nil
	case asunit.FieldManufactureMark:
		m.ResetManufactureMark()
		return nil
	case asunit.FieldAssetDisposalAgencyTag:
		m.ResetAssetDisposalAgencyTag()
		return nil
	case asunit.FieldStateAssetManagementCompany:
		m.ResetStateAssetManagementCompany()
		return nil
	case asunit.FieldInstitutionNumber:
		m.ResetInstitutionNumber()
		return nil
	case asunit.FieldAuthorizedNumber:
		m.ResetAuthorizedNumber()
		return nil
	case asunit.FieldOfSideNumber:
		m.ResetOfSideNumber()
		return nil
	case asunit.FieldInstitutionAuthority:
		m.ResetInstitutionAuthority()
		return nil
	case asunit.FieldAdministrationAuthority:
		m.ResetAdministrationAuthority()
		return nil
	case asunit.FieldEnableTime:
		m.ResetEnableTime()
		return nil
	case asunit.FieldDisableTime:
		m.ResetDisableTime()
		return nil
	case asunit.FieldSealTime:
		m.ResetSealTime()
		return nil
	case asunit.FieldUnitRemark:
		m.ResetUnitRemark()
		return nil
	case asunit.FieldAssetDownloadStatus:
		m.ResetAssetDownloadStatus()
		return nil
	case asunit.FieldLatitudeAndLongitude:
		m.ResetLatitudeAndLongitude()
		return nil
	case asunit.FieldSort:
		m.ResetSort()
		return nil
	case asunit.FieldOrganCode:
		m.ResetOrganCode()
		return nil
	case asunit.FieldHadInnerNumber:
		m.ResetHadInnerNumber()
		return nil
	case asunit.FieldApproveInnerNumber:
		m.ResetApproveInnerNumber()
		return nil
	case asunit.FieldImg:
		m.ResetImg()
		return nil
	case asunit.FieldLinkMan:
		m.ResetLinkMan()
		return nil
	case asunit.FieldLinkPhone:
		m.ResetLinkPhone()
		return nil
	case asunit.FieldTenantID:
		m.ResetTenantID()
		return nil
	case asunit.FieldUnitCode:
		m.ResetUnitCode()
		return nil
	case asunit.FieldAuthorityTotal:
		m.ResetAuthorityTotal()
		return nil
	case asunit.FieldStaffOnActiveDuty:
		m.ResetStaffOnActiveDuty()
		return nil
	case asunit.FieldRetiredStaff:
		m.ResetRetiredStaff()
		return nil
	case asunit.FieldOtherStaff:
		m.ResetOtherStaff()
		return nil
	case asunit.FieldIsVirtual:
		m.ResetIsVirtual()
		return nil
	case asunit.FieldUnitReform:
		m.ResetUnitReform()
		return nil
	case asunit.FieldPersonExpenditure:
		m.ResetPersonExpenditure()
		return nil
	case asunit.FieldInstitutionType:
		m.ResetInstitutionType()
		return nil
	case asunit.FieldDepartmentIdentification:
		m.ResetDepartmentIdentification()
		return nil
	case asunit.FieldTotalHeadcount:
		m.ResetTotalHeadcount()
		return nil
	case asunit.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asunit.FieldStatus:
		m.ResetStatus()
		return nil
	case asunit.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asunit.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asunit.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asunit.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenantx != nil {
		edges = append(edges, asunit.EdgeTenantx)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsUnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asunit.EdgeTenantx:
		if id := m.tenantx; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsUnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenantx {
		edges = append(edges, asunit.EdgeTenantx)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsUnitMutation) EdgeCleared(name string) bool {
	switch name {
	case asunit.EdgeTenantx:
		return m.clearedtenantx
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsUnitMutation) ClearEdge(name string) error {
	switch name {
	case asunit.EdgeTenantx:
		m.ClearTenantx()
		return nil
	}
	return fmt.Errorf("unknown AsUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsUnitMutation) ResetEdge(name string) error {
	switch name {
	case asunit.EdgeTenantx:
		m.ResetTenantx()
		return nil
	}
	return fmt.Errorf("unknown AsUnit edge %s", name)
}

// AsUserMutation represents an operation that mutates the AsUser nodes in the graph.
type AsUserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	tenant_code              *string
	pwd                      *string
	phone_number             *string
	is_admin                 *int64
	addis_admin              *int64
	tenant_applying_state    *int64
	addtenant_applying_state *int64
	is_master                *int64
	addis_master             *int64
	is_created               *int64
	addis_created            *int64
	open_id                  *string
	user_name                *string
	is_deleted               *int64
	addis_deleted            *int64
	status                   *int64
	addstatus                *int64
	create_user              *int64
	addcreate_user           *int64
	update_user              *int64
	addupdate_user           *int64
	create_time              *date.DateTime
	update_time              *date.DateTime
	clearedFields            map[string]struct{}
	person                   *int64
	clearedperson            bool
	roles                    map[int64]struct{}
	removedroles             map[int64]struct{}
	clearedroles             bool
	jobs                     map[int64]struct{}
	removedjobs              map[int64]struct{}
	clearedjobs              bool
	usedapps                 map[int64]struct{}
	removedusedapps          map[int64]struct{}
	clearedusedapps          bool
	workingDatas             map[int64]struct{}
	removedworkingDatas      map[int64]struct{}
	clearedworkingDatas      bool
	agencys                  map[int64]struct{}
	removedagencys           map[int64]struct{}
	clearedagencys           bool
	roleDistribs             map[int64]struct{}
	removedroleDistribs      map[int64]struct{}
	clearedroleDistribs      bool
	appMenusUserSorts        map[int64]struct{}
	removedappMenusUserSorts map[int64]struct{}
	clearedappMenusUserSorts bool
	appUserTemplates         map[int64]struct{}
	removedappUserTemplates  map[int64]struct{}
	clearedappUserTemplates  bool
	done                     bool
	oldValue                 func(context.Context) (*AsUser, error)
	predicates               []predicate.AsUser
}

var _ ent.Mutation = (*AsUserMutation)(nil)

// asuserOption allows management of the mutation configuration using functional options.
type asuserOption func(*AsUserMutation)

// newAsUserMutation creates new mutation for the AsUser entity.
func newAsUserMutation(c config, op Op, opts ...asuserOption) *AsUserMutation {
	m := &AsUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAsUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsUserID sets the ID field of the mutation.
func withAsUserID(id int64) asuserOption {
	return func(m *AsUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AsUser
		)
		m.oldValue = func(ctx context.Context) (*AsUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsUser sets the old AsUser of the mutation.
func withAsUser(node *AsUser) asuserOption {
	return func(m *AsUserMutation) {
		m.oldValue = func(context.Context) (*AsUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsUser entities.
func (m *AsUserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsUserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsUserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantCode sets the "tenant_code" field.
func (m *AsUserMutation) SetTenantCode(s string) {
	m.tenant_code = &s
}

// TenantCode returns the value of the "tenant_code" field in the mutation.
func (m *AsUserMutation) TenantCode() (r string, exists bool) {
	v := m.tenant_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantCode returns the old "tenant_code" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldTenantCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantCode: %w", err)
	}
	return oldValue.TenantCode, nil
}

// ClearTenantCode clears the value of the "tenant_code" field.
func (m *AsUserMutation) ClearTenantCode() {
	m.tenant_code = nil
	m.clearedFields[asuser.FieldTenantCode] = struct{}{}
}

// TenantCodeCleared returns if the "tenant_code" field was cleared in this mutation.
func (m *AsUserMutation) TenantCodeCleared() bool {
	_, ok := m.clearedFields[asuser.FieldTenantCode]
	return ok
}

// ResetTenantCode resets all changes to the "tenant_code" field.
func (m *AsUserMutation) ResetTenantCode() {
	m.tenant_code = nil
	delete(m.clearedFields, asuser.FieldTenantCode)
}

// SetPwd sets the "pwd" field.
func (m *AsUserMutation) SetPwd(s string) {
	m.pwd = &s
}

// Pwd returns the value of the "pwd" field in the mutation.
func (m *AsUserMutation) Pwd() (r string, exists bool) {
	v := m.pwd
	if v == nil {
		return
	}
	return *v, true
}

// OldPwd returns the old "pwd" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldPwd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPwd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPwd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPwd: %w", err)
	}
	return oldValue.Pwd, nil
}

// ResetPwd resets all changes to the "pwd" field.
func (m *AsUserMutation) ResetPwd() {
	m.pwd = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *AsUserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *AsUserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *AsUserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[asuser.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *AsUserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[asuser.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *AsUserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, asuser.FieldPhoneNumber)
}

// SetIsAdmin sets the "is_admin" field.
func (m *AsUserMutation) SetIsAdmin(i int64) {
	m.is_admin = &i
	m.addis_admin = nil
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *AsUserMutation) IsAdmin() (r int64, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldIsAdmin(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// AddIsAdmin adds i to the "is_admin" field.
func (m *AsUserMutation) AddIsAdmin(i int64) {
	if m.addis_admin != nil {
		*m.addis_admin += i
	} else {
		m.addis_admin = &i
	}
}

// AddedIsAdmin returns the value that was added to the "is_admin" field in this mutation.
func (m *AsUserMutation) AddedIsAdmin() (r int64, exists bool) {
	v := m.addis_admin
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *AsUserMutation) ResetIsAdmin() {
	m.is_admin = nil
	m.addis_admin = nil
}

// SetTenantApplyingState sets the "tenant_applying_state" field.
func (m *AsUserMutation) SetTenantApplyingState(i int64) {
	m.tenant_applying_state = &i
	m.addtenant_applying_state = nil
}

// TenantApplyingState returns the value of the "tenant_applying_state" field in the mutation.
func (m *AsUserMutation) TenantApplyingState() (r int64, exists bool) {
	v := m.tenant_applying_state
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantApplyingState returns the old "tenant_applying_state" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldTenantApplyingState(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantApplyingState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantApplyingState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantApplyingState: %w", err)
	}
	return oldValue.TenantApplyingState, nil
}

// AddTenantApplyingState adds i to the "tenant_applying_state" field.
func (m *AsUserMutation) AddTenantApplyingState(i int64) {
	if m.addtenant_applying_state != nil {
		*m.addtenant_applying_state += i
	} else {
		m.addtenant_applying_state = &i
	}
}

// AddedTenantApplyingState returns the value that was added to the "tenant_applying_state" field in this mutation.
func (m *AsUserMutation) AddedTenantApplyingState() (r int64, exists bool) {
	v := m.addtenant_applying_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantApplyingState resets all changes to the "tenant_applying_state" field.
func (m *AsUserMutation) ResetTenantApplyingState() {
	m.tenant_applying_state = nil
	m.addtenant_applying_state = nil
}

// SetIsMaster sets the "is_master" field.
func (m *AsUserMutation) SetIsMaster(i int64) {
	m.is_master = &i
	m.addis_master = nil
}

// IsMaster returns the value of the "is_master" field in the mutation.
func (m *AsUserMutation) IsMaster() (r int64, exists bool) {
	v := m.is_master
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMaster returns the old "is_master" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldIsMaster(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsMaster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsMaster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMaster: %w", err)
	}
	return oldValue.IsMaster, nil
}

// AddIsMaster adds i to the "is_master" field.
func (m *AsUserMutation) AddIsMaster(i int64) {
	if m.addis_master != nil {
		*m.addis_master += i
	} else {
		m.addis_master = &i
	}
}

// AddedIsMaster returns the value that was added to the "is_master" field in this mutation.
func (m *AsUserMutation) AddedIsMaster() (r int64, exists bool) {
	v := m.addis_master
	if v == nil {
		return
	}
	return *v, true
}

// ClearIsMaster clears the value of the "is_master" field.
func (m *AsUserMutation) ClearIsMaster() {
	m.is_master = nil
	m.addis_master = nil
	m.clearedFields[asuser.FieldIsMaster] = struct{}{}
}

// IsMasterCleared returns if the "is_master" field was cleared in this mutation.
func (m *AsUserMutation) IsMasterCleared() bool {
	_, ok := m.clearedFields[asuser.FieldIsMaster]
	return ok
}

// ResetIsMaster resets all changes to the "is_master" field.
func (m *AsUserMutation) ResetIsMaster() {
	m.is_master = nil
	m.addis_master = nil
	delete(m.clearedFields, asuser.FieldIsMaster)
}

// SetIsCreated sets the "is_created" field.
func (m *AsUserMutation) SetIsCreated(i int64) {
	m.is_created = &i
	m.addis_created = nil
}

// IsCreated returns the value of the "is_created" field in the mutation.
func (m *AsUserMutation) IsCreated() (r int64, exists bool) {
	v := m.is_created
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCreated returns the old "is_created" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldIsCreated(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCreated: %w", err)
	}
	return oldValue.IsCreated, nil
}

// AddIsCreated adds i to the "is_created" field.
func (m *AsUserMutation) AddIsCreated(i int64) {
	if m.addis_created != nil {
		*m.addis_created += i
	} else {
		m.addis_created = &i
	}
}

// AddedIsCreated returns the value that was added to the "is_created" field in this mutation.
func (m *AsUserMutation) AddedIsCreated() (r int64, exists bool) {
	v := m.addis_created
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsCreated resets all changes to the "is_created" field.
func (m *AsUserMutation) ResetIsCreated() {
	m.is_created = nil
	m.addis_created = nil
}

// SetOpenID sets the "open_id" field.
func (m *AsUserMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *AsUserMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ClearOpenID clears the value of the "open_id" field.
func (m *AsUserMutation) ClearOpenID() {
	m.open_id = nil
	m.clearedFields[asuser.FieldOpenID] = struct{}{}
}

// OpenIDCleared returns if the "open_id" field was cleared in this mutation.
func (m *AsUserMutation) OpenIDCleared() bool {
	_, ok := m.clearedFields[asuser.FieldOpenID]
	return ok
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *AsUserMutation) ResetOpenID() {
	m.open_id = nil
	delete(m.clearedFields, asuser.FieldOpenID)
}

// SetUserName sets the "user_name" field.
func (m *AsUserMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *AsUserMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "user_name" field.
func (m *AsUserMutation) ClearUserName() {
	m.user_name = nil
	m.clearedFields[asuser.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "user_name" field was cleared in this mutation.
func (m *AsUserMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[asuser.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "user_name" field.
func (m *AsUserMutation) ResetUserName() {
	m.user_name = nil
	delete(m.clearedFields, asuser.FieldUserName)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsUserMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsUserMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsUserMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsUserMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsUserMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsUserMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsUserMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsUserMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsUserMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsUserMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asuser.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsUserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asuser.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsUserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asuser.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsUserMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsUserMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsUserMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsUserMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsUserMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asuser.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsUserMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asuser.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsUserMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asuser.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsUserMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsUserMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsUserMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsUserMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsUserMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asuser.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsUserMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asuser.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsUserMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asuser.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsUserMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsUserMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsUserMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asuser.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsUserMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asuser.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsUserMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asuser.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsUserMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsUserMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsUser entity.
// If the AsUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsUserMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsUserMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asuser.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsUserMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asuser.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsUserMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asuser.FieldUpdateTime)
}

// SetPersonID sets the "person" edge to the AsPerson entity by id.
func (m *AsUserMutation) SetPersonID(id int64) {
	m.person = &id
}

// ClearPerson clears the "person" edge to the AsPerson entity.
func (m *AsUserMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the AsPerson entity was cleared.
func (m *AsUserMutation) PersonCleared() bool {
	return m.clearedperson
}

// PersonID returns the "person" edge ID in the mutation.
func (m *AsUserMutation) PersonID() (id int64, exists bool) {
	if m.person != nil {
		return *m.person, true
	}
	return
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *AsUserMutation) PersonIDs() (ids []int64) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *AsUserMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// AddRoleIDs adds the "roles" edge to the AsRole entity by ids.
func (m *AsUserMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the AsRole entity.
func (m *AsUserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AsRole entity was cleared.
func (m *AsUserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the AsRole entity by IDs.
func (m *AsUserMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the AsRole entity.
func (m *AsUserMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AsUserMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AsUserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddJobIDs adds the "jobs" edge to the AsJob entity by ids.
func (m *AsUserMutation) AddJobIDs(ids ...int64) {
	if m.jobs == nil {
		m.jobs = make(map[int64]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the AsJob entity.
func (m *AsUserMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the AsJob entity was cleared.
func (m *AsUserMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the AsJob entity by IDs.
func (m *AsUserMutation) RemoveJobIDs(ids ...int64) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the AsJob entity.
func (m *AsUserMutation) RemovedJobsIDs() (ids []int64) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *AsUserMutation) JobsIDs() (ids []int64) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *AsUserMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// AddUsedappIDs adds the "usedapps" edge to the AsMarketUsedApp entity by ids.
func (m *AsUserMutation) AddUsedappIDs(ids ...int64) {
	if m.usedapps == nil {
		m.usedapps = make(map[int64]struct{})
	}
	for i := range ids {
		m.usedapps[ids[i]] = struct{}{}
	}
}

// ClearUsedapps clears the "usedapps" edge to the AsMarketUsedApp entity.
func (m *AsUserMutation) ClearUsedapps() {
	m.clearedusedapps = true
}

// UsedappsCleared reports if the "usedapps" edge to the AsMarketUsedApp entity was cleared.
func (m *AsUserMutation) UsedappsCleared() bool {
	return m.clearedusedapps
}

// RemoveUsedappIDs removes the "usedapps" edge to the AsMarketUsedApp entity by IDs.
func (m *AsUserMutation) RemoveUsedappIDs(ids ...int64) {
	if m.removedusedapps == nil {
		m.removedusedapps = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usedapps, ids[i])
		m.removedusedapps[ids[i]] = struct{}{}
	}
}

// RemovedUsedapps returns the removed IDs of the "usedapps" edge to the AsMarketUsedApp entity.
func (m *AsUserMutation) RemovedUsedappsIDs() (ids []int64) {
	for id := range m.removedusedapps {
		ids = append(ids, id)
	}
	return
}

// UsedappsIDs returns the "usedapps" edge IDs in the mutation.
func (m *AsUserMutation) UsedappsIDs() (ids []int64) {
	for id := range m.usedapps {
		ids = append(ids, id)
	}
	return
}

// ResetUsedapps resets all changes to the "usedapps" edge.
func (m *AsUserMutation) ResetUsedapps() {
	m.usedapps = nil
	m.clearedusedapps = false
	m.removedusedapps = nil
}

// AddWorkingDataIDs adds the "workingDatas" edge to the AsWorkingData entity by ids.
func (m *AsUserMutation) AddWorkingDataIDs(ids ...int64) {
	if m.workingDatas == nil {
		m.workingDatas = make(map[int64]struct{})
	}
	for i := range ids {
		m.workingDatas[ids[i]] = struct{}{}
	}
}

// ClearWorkingDatas clears the "workingDatas" edge to the AsWorkingData entity.
func (m *AsUserMutation) ClearWorkingDatas() {
	m.clearedworkingDatas = true
}

// WorkingDatasCleared reports if the "workingDatas" edge to the AsWorkingData entity was cleared.
func (m *AsUserMutation) WorkingDatasCleared() bool {
	return m.clearedworkingDatas
}

// RemoveWorkingDataIDs removes the "workingDatas" edge to the AsWorkingData entity by IDs.
func (m *AsUserMutation) RemoveWorkingDataIDs(ids ...int64) {
	if m.removedworkingDatas == nil {
		m.removedworkingDatas = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.workingDatas, ids[i])
		m.removedworkingDatas[ids[i]] = struct{}{}
	}
}

// RemovedWorkingDatas returns the removed IDs of the "workingDatas" edge to the AsWorkingData entity.
func (m *AsUserMutation) RemovedWorkingDatasIDs() (ids []int64) {
	for id := range m.removedworkingDatas {
		ids = append(ids, id)
	}
	return
}

// WorkingDatasIDs returns the "workingDatas" edge IDs in the mutation.
func (m *AsUserMutation) WorkingDatasIDs() (ids []int64) {
	for id := range m.workingDatas {
		ids = append(ids, id)
	}
	return
}

// ResetWorkingDatas resets all changes to the "workingDatas" edge.
func (m *AsUserMutation) ResetWorkingDatas() {
	m.workingDatas = nil
	m.clearedworkingDatas = false
	m.removedworkingDatas = nil
}

// AddAgencyIDs adds the "agencys" edge to the AsInnerAgency entity by ids.
func (m *AsUserMutation) AddAgencyIDs(ids ...int64) {
	if m.agencys == nil {
		m.agencys = make(map[int64]struct{})
	}
	for i := range ids {
		m.agencys[ids[i]] = struct{}{}
	}
}

// ClearAgencys clears the "agencys" edge to the AsInnerAgency entity.
func (m *AsUserMutation) ClearAgencys() {
	m.clearedagencys = true
}

// AgencysCleared reports if the "agencys" edge to the AsInnerAgency entity was cleared.
func (m *AsUserMutation) AgencysCleared() bool {
	return m.clearedagencys
}

// RemoveAgencyIDs removes the "agencys" edge to the AsInnerAgency entity by IDs.
func (m *AsUserMutation) RemoveAgencyIDs(ids ...int64) {
	if m.removedagencys == nil {
		m.removedagencys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.agencys, ids[i])
		m.removedagencys[ids[i]] = struct{}{}
	}
}

// RemovedAgencys returns the removed IDs of the "agencys" edge to the AsInnerAgency entity.
func (m *AsUserMutation) RemovedAgencysIDs() (ids []int64) {
	for id := range m.removedagencys {
		ids = append(ids, id)
	}
	return
}

// AgencysIDs returns the "agencys" edge IDs in the mutation.
func (m *AsUserMutation) AgencysIDs() (ids []int64) {
	for id := range m.agencys {
		ids = append(ids, id)
	}
	return
}

// ResetAgencys resets all changes to the "agencys" edge.
func (m *AsUserMutation) ResetAgencys() {
	m.agencys = nil
	m.clearedagencys = false
	m.removedagencys = nil
}

// AddRoleDistribIDs adds the "roleDistribs" edge to the AsMarketRoleDistribution entity by ids.
func (m *AsUserMutation) AddRoleDistribIDs(ids ...int64) {
	if m.roleDistribs == nil {
		m.roleDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		m.roleDistribs[ids[i]] = struct{}{}
	}
}

// ClearRoleDistribs clears the "roleDistribs" edge to the AsMarketRoleDistribution entity.
func (m *AsUserMutation) ClearRoleDistribs() {
	m.clearedroleDistribs = true
}

// RoleDistribsCleared reports if the "roleDistribs" edge to the AsMarketRoleDistribution entity was cleared.
func (m *AsUserMutation) RoleDistribsCleared() bool {
	return m.clearedroleDistribs
}

// RemoveRoleDistribIDs removes the "roleDistribs" edge to the AsMarketRoleDistribution entity by IDs.
func (m *AsUserMutation) RemoveRoleDistribIDs(ids ...int64) {
	if m.removedroleDistribs == nil {
		m.removedroleDistribs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roleDistribs, ids[i])
		m.removedroleDistribs[ids[i]] = struct{}{}
	}
}

// RemovedRoleDistribs returns the removed IDs of the "roleDistribs" edge to the AsMarketRoleDistribution entity.
func (m *AsUserMutation) RemovedRoleDistribsIDs() (ids []int64) {
	for id := range m.removedroleDistribs {
		ids = append(ids, id)
	}
	return
}

// RoleDistribsIDs returns the "roleDistribs" edge IDs in the mutation.
func (m *AsUserMutation) RoleDistribsIDs() (ids []int64) {
	for id := range m.roleDistribs {
		ids = append(ids, id)
	}
	return
}

// ResetRoleDistribs resets all changes to the "roleDistribs" edge.
func (m *AsUserMutation) ResetRoleDistribs() {
	m.roleDistribs = nil
	m.clearedroleDistribs = false
	m.removedroleDistribs = nil
}

// AddAppMenusUserSortIDs adds the "appMenusUserSorts" edge to the AsMarketMenuUserSort entity by ids.
func (m *AsUserMutation) AddAppMenusUserSortIDs(ids ...int64) {
	if m.appMenusUserSorts == nil {
		m.appMenusUserSorts = make(map[int64]struct{})
	}
	for i := range ids {
		m.appMenusUserSorts[ids[i]] = struct{}{}
	}
}

// ClearAppMenusUserSorts clears the "appMenusUserSorts" edge to the AsMarketMenuUserSort entity.
func (m *AsUserMutation) ClearAppMenusUserSorts() {
	m.clearedappMenusUserSorts = true
}

// AppMenusUserSortsCleared reports if the "appMenusUserSorts" edge to the AsMarketMenuUserSort entity was cleared.
func (m *AsUserMutation) AppMenusUserSortsCleared() bool {
	return m.clearedappMenusUserSorts
}

// RemoveAppMenusUserSortIDs removes the "appMenusUserSorts" edge to the AsMarketMenuUserSort entity by IDs.
func (m *AsUserMutation) RemoveAppMenusUserSortIDs(ids ...int64) {
	if m.removedappMenusUserSorts == nil {
		m.removedappMenusUserSorts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appMenusUserSorts, ids[i])
		m.removedappMenusUserSorts[ids[i]] = struct{}{}
	}
}

// RemovedAppMenusUserSorts returns the removed IDs of the "appMenusUserSorts" edge to the AsMarketMenuUserSort entity.
func (m *AsUserMutation) RemovedAppMenusUserSortsIDs() (ids []int64) {
	for id := range m.removedappMenusUserSorts {
		ids = append(ids, id)
	}
	return
}

// AppMenusUserSortsIDs returns the "appMenusUserSorts" edge IDs in the mutation.
func (m *AsUserMutation) AppMenusUserSortsIDs() (ids []int64) {
	for id := range m.appMenusUserSorts {
		ids = append(ids, id)
	}
	return
}

// ResetAppMenusUserSorts resets all changes to the "appMenusUserSorts" edge.
func (m *AsUserMutation) ResetAppMenusUserSorts() {
	m.appMenusUserSorts = nil
	m.clearedappMenusUserSorts = false
	m.removedappMenusUserSorts = nil
}

// AddAppUserTemplateIDs adds the "appUserTemplates" edge to the AsMarketAppUserTemplate entity by ids.
func (m *AsUserMutation) AddAppUserTemplateIDs(ids ...int64) {
	if m.appUserTemplates == nil {
		m.appUserTemplates = make(map[int64]struct{})
	}
	for i := range ids {
		m.appUserTemplates[ids[i]] = struct{}{}
	}
}

// ClearAppUserTemplates clears the "appUserTemplates" edge to the AsMarketAppUserTemplate entity.
func (m *AsUserMutation) ClearAppUserTemplates() {
	m.clearedappUserTemplates = true
}

// AppUserTemplatesCleared reports if the "appUserTemplates" edge to the AsMarketAppUserTemplate entity was cleared.
func (m *AsUserMutation) AppUserTemplatesCleared() bool {
	return m.clearedappUserTemplates
}

// RemoveAppUserTemplateIDs removes the "appUserTemplates" edge to the AsMarketAppUserTemplate entity by IDs.
func (m *AsUserMutation) RemoveAppUserTemplateIDs(ids ...int64) {
	if m.removedappUserTemplates == nil {
		m.removedappUserTemplates = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.appUserTemplates, ids[i])
		m.removedappUserTemplates[ids[i]] = struct{}{}
	}
}

// RemovedAppUserTemplates returns the removed IDs of the "appUserTemplates" edge to the AsMarketAppUserTemplate entity.
func (m *AsUserMutation) RemovedAppUserTemplatesIDs() (ids []int64) {
	for id := range m.removedappUserTemplates {
		ids = append(ids, id)
	}
	return
}

// AppUserTemplatesIDs returns the "appUserTemplates" edge IDs in the mutation.
func (m *AsUserMutation) AppUserTemplatesIDs() (ids []int64) {
	for id := range m.appUserTemplates {
		ids = append(ids, id)
	}
	return
}

// ResetAppUserTemplates resets all changes to the "appUserTemplates" edge.
func (m *AsUserMutation) ResetAppUserTemplates() {
	m.appUserTemplates = nil
	m.clearedappUserTemplates = false
	m.removedappUserTemplates = nil
}

// Where appends a list predicates to the AsUserMutation builder.
func (m *AsUserMutation) Where(ps ...predicate.AsUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsUser).
func (m *AsUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsUserMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.tenant_code != nil {
		fields = append(fields, asuser.FieldTenantCode)
	}
	if m.pwd != nil {
		fields = append(fields, asuser.FieldPwd)
	}
	if m.phone_number != nil {
		fields = append(fields, asuser.FieldPhoneNumber)
	}
	if m.is_admin != nil {
		fields = append(fields, asuser.FieldIsAdmin)
	}
	if m.tenant_applying_state != nil {
		fields = append(fields, asuser.FieldTenantApplyingState)
	}
	if m.is_master != nil {
		fields = append(fields, asuser.FieldIsMaster)
	}
	if m.is_created != nil {
		fields = append(fields, asuser.FieldIsCreated)
	}
	if m.open_id != nil {
		fields = append(fields, asuser.FieldOpenID)
	}
	if m.user_name != nil {
		fields = append(fields, asuser.FieldUserName)
	}
	if m.is_deleted != nil {
		fields = append(fields, asuser.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asuser.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asuser.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asuser.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asuser.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asuser.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asuser.FieldTenantCode:
		return m.TenantCode()
	case asuser.FieldPwd:
		return m.Pwd()
	case asuser.FieldPhoneNumber:
		return m.PhoneNumber()
	case asuser.FieldIsAdmin:
		return m.IsAdmin()
	case asuser.FieldTenantApplyingState:
		return m.TenantApplyingState()
	case asuser.FieldIsMaster:
		return m.IsMaster()
	case asuser.FieldIsCreated:
		return m.IsCreated()
	case asuser.FieldOpenID:
		return m.OpenID()
	case asuser.FieldUserName:
		return m.UserName()
	case asuser.FieldIsDeleted:
		return m.IsDeleted()
	case asuser.FieldStatus:
		return m.Status()
	case asuser.FieldCreateUser:
		return m.CreateUser()
	case asuser.FieldUpdateUser:
		return m.UpdateUser()
	case asuser.FieldCreateTime:
		return m.CreateTime()
	case asuser.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asuser.FieldTenantCode:
		return m.OldTenantCode(ctx)
	case asuser.FieldPwd:
		return m.OldPwd(ctx)
	case asuser.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case asuser.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case asuser.FieldTenantApplyingState:
		return m.OldTenantApplyingState(ctx)
	case asuser.FieldIsMaster:
		return m.OldIsMaster(ctx)
	case asuser.FieldIsCreated:
		return m.OldIsCreated(ctx)
	case asuser.FieldOpenID:
		return m.OldOpenID(ctx)
	case asuser.FieldUserName:
		return m.OldUserName(ctx)
	case asuser.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asuser.FieldStatus:
		return m.OldStatus(ctx)
	case asuser.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asuser.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asuser.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asuser.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asuser.FieldTenantCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantCode(v)
		return nil
	case asuser.FieldPwd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPwd(v)
		return nil
	case asuser.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case asuser.FieldIsAdmin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case asuser.FieldTenantApplyingState:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantApplyingState(v)
		return nil
	case asuser.FieldIsMaster:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMaster(v)
		return nil
	case asuser.FieldIsCreated:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCreated(v)
		return nil
	case asuser.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case asuser.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case asuser.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asuser.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asuser.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asuser.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asuser.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asuser.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsUserMutation) AddedFields() []string {
	var fields []string
	if m.addis_admin != nil {
		fields = append(fields, asuser.FieldIsAdmin)
	}
	if m.addtenant_applying_state != nil {
		fields = append(fields, asuser.FieldTenantApplyingState)
	}
	if m.addis_master != nil {
		fields = append(fields, asuser.FieldIsMaster)
	}
	if m.addis_created != nil {
		fields = append(fields, asuser.FieldIsCreated)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asuser.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asuser.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asuser.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asuser.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asuser.FieldIsAdmin:
		return m.AddedIsAdmin()
	case asuser.FieldTenantApplyingState:
		return m.AddedTenantApplyingState()
	case asuser.FieldIsMaster:
		return m.AddedIsMaster()
	case asuser.FieldIsCreated:
		return m.AddedIsCreated()
	case asuser.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asuser.FieldStatus:
		return m.AddedStatus()
	case asuser.FieldCreateUser:
		return m.AddedCreateUser()
	case asuser.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asuser.FieldIsAdmin:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsAdmin(v)
		return nil
	case asuser.FieldTenantApplyingState:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantApplyingState(v)
		return nil
	case asuser.FieldIsMaster:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsMaster(v)
		return nil
	case asuser.FieldIsCreated:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsCreated(v)
		return nil
	case asuser.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asuser.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asuser.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asuser.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asuser.FieldTenantCode) {
		fields = append(fields, asuser.FieldTenantCode)
	}
	if m.FieldCleared(asuser.FieldPhoneNumber) {
		fields = append(fields, asuser.FieldPhoneNumber)
	}
	if m.FieldCleared(asuser.FieldIsMaster) {
		fields = append(fields, asuser.FieldIsMaster)
	}
	if m.FieldCleared(asuser.FieldOpenID) {
		fields = append(fields, asuser.FieldOpenID)
	}
	if m.FieldCleared(asuser.FieldUserName) {
		fields = append(fields, asuser.FieldUserName)
	}
	if m.FieldCleared(asuser.FieldStatus) {
		fields = append(fields, asuser.FieldStatus)
	}
	if m.FieldCleared(asuser.FieldCreateUser) {
		fields = append(fields, asuser.FieldCreateUser)
	}
	if m.FieldCleared(asuser.FieldUpdateUser) {
		fields = append(fields, asuser.FieldUpdateUser)
	}
	if m.FieldCleared(asuser.FieldCreateTime) {
		fields = append(fields, asuser.FieldCreateTime)
	}
	if m.FieldCleared(asuser.FieldUpdateTime) {
		fields = append(fields, asuser.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsUserMutation) ClearField(name string) error {
	switch name {
	case asuser.FieldTenantCode:
		m.ClearTenantCode()
		return nil
	case asuser.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case asuser.FieldIsMaster:
		m.ClearIsMaster()
		return nil
	case asuser.FieldOpenID:
		m.ClearOpenID()
		return nil
	case asuser.FieldUserName:
		m.ClearUserName()
		return nil
	case asuser.FieldStatus:
		m.ClearStatus()
		return nil
	case asuser.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asuser.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asuser.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asuser.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsUserMutation) ResetField(name string) error {
	switch name {
	case asuser.FieldTenantCode:
		m.ResetTenantCode()
		return nil
	case asuser.FieldPwd:
		m.ResetPwd()
		return nil
	case asuser.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case asuser.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case asuser.FieldTenantApplyingState:
		m.ResetTenantApplyingState()
		return nil
	case asuser.FieldIsMaster:
		m.ResetIsMaster()
		return nil
	case asuser.FieldIsCreated:
		m.ResetIsCreated()
		return nil
	case asuser.FieldOpenID:
		m.ResetOpenID()
		return nil
	case asuser.FieldUserName:
		m.ResetUserName()
		return nil
	case asuser.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asuser.FieldStatus:
		m.ResetStatus()
		return nil
	case asuser.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asuser.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asuser.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asuser.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.person != nil {
		edges = append(edges, asuser.EdgePerson)
	}
	if m.roles != nil {
		edges = append(edges, asuser.EdgeRoles)
	}
	if m.jobs != nil {
		edges = append(edges, asuser.EdgeJobs)
	}
	if m.usedapps != nil {
		edges = append(edges, asuser.EdgeUsedapps)
	}
	if m.workingDatas != nil {
		edges = append(edges, asuser.EdgeWorkingDatas)
	}
	if m.agencys != nil {
		edges = append(edges, asuser.EdgeAgencys)
	}
	if m.roleDistribs != nil {
		edges = append(edges, asuser.EdgeRoleDistribs)
	}
	if m.appMenusUserSorts != nil {
		edges = append(edges, asuser.EdgeAppMenusUserSorts)
	}
	if m.appUserTemplates != nil {
		edges = append(edges, asuser.EdgeAppUserTemplates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asuser.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	case asuser.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeUsedapps:
		ids := make([]ent.Value, 0, len(m.usedapps))
		for id := range m.usedapps {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeWorkingDatas:
		ids := make([]ent.Value, 0, len(m.workingDatas))
		for id := range m.workingDatas {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeAgencys:
		ids := make([]ent.Value, 0, len(m.agencys))
		for id := range m.agencys {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeRoleDistribs:
		ids := make([]ent.Value, 0, len(m.roleDistribs))
		for id := range m.roleDistribs {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeAppMenusUserSorts:
		ids := make([]ent.Value, 0, len(m.appMenusUserSorts))
		for id := range m.appMenusUserSorts {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeAppUserTemplates:
		ids := make([]ent.Value, 0, len(m.appUserTemplates))
		for id := range m.appUserTemplates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedroles != nil {
		edges = append(edges, asuser.EdgeRoles)
	}
	if m.removedjobs != nil {
		edges = append(edges, asuser.EdgeJobs)
	}
	if m.removedusedapps != nil {
		edges = append(edges, asuser.EdgeUsedapps)
	}
	if m.removedworkingDatas != nil {
		edges = append(edges, asuser.EdgeWorkingDatas)
	}
	if m.removedagencys != nil {
		edges = append(edges, asuser.EdgeAgencys)
	}
	if m.removedroleDistribs != nil {
		edges = append(edges, asuser.EdgeRoleDistribs)
	}
	if m.removedappMenusUserSorts != nil {
		edges = append(edges, asuser.EdgeAppMenusUserSorts)
	}
	if m.removedappUserTemplates != nil {
		edges = append(edges, asuser.EdgeAppUserTemplates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asuser.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeUsedapps:
		ids := make([]ent.Value, 0, len(m.removedusedapps))
		for id := range m.removedusedapps {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeWorkingDatas:
		ids := make([]ent.Value, 0, len(m.removedworkingDatas))
		for id := range m.removedworkingDatas {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeAgencys:
		ids := make([]ent.Value, 0, len(m.removedagencys))
		for id := range m.removedagencys {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeRoleDistribs:
		ids := make([]ent.Value, 0, len(m.removedroleDistribs))
		for id := range m.removedroleDistribs {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeAppMenusUserSorts:
		ids := make([]ent.Value, 0, len(m.removedappMenusUserSorts))
		for id := range m.removedappMenusUserSorts {
			ids = append(ids, id)
		}
		return ids
	case asuser.EdgeAppUserTemplates:
		ids := make([]ent.Value, 0, len(m.removedappUserTemplates))
		for id := range m.removedappUserTemplates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedperson {
		edges = append(edges, asuser.EdgePerson)
	}
	if m.clearedroles {
		edges = append(edges, asuser.EdgeRoles)
	}
	if m.clearedjobs {
		edges = append(edges, asuser.EdgeJobs)
	}
	if m.clearedusedapps {
		edges = append(edges, asuser.EdgeUsedapps)
	}
	if m.clearedworkingDatas {
		edges = append(edges, asuser.EdgeWorkingDatas)
	}
	if m.clearedagencys {
		edges = append(edges, asuser.EdgeAgencys)
	}
	if m.clearedroleDistribs {
		edges = append(edges, asuser.EdgeRoleDistribs)
	}
	if m.clearedappMenusUserSorts {
		edges = append(edges, asuser.EdgeAppMenusUserSorts)
	}
	if m.clearedappUserTemplates {
		edges = append(edges, asuser.EdgeAppUserTemplates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsUserMutation) EdgeCleared(name string) bool {
	switch name {
	case asuser.EdgePerson:
		return m.clearedperson
	case asuser.EdgeRoles:
		return m.clearedroles
	case asuser.EdgeJobs:
		return m.clearedjobs
	case asuser.EdgeUsedapps:
		return m.clearedusedapps
	case asuser.EdgeWorkingDatas:
		return m.clearedworkingDatas
	case asuser.EdgeAgencys:
		return m.clearedagencys
	case asuser.EdgeRoleDistribs:
		return m.clearedroleDistribs
	case asuser.EdgeAppMenusUserSorts:
		return m.clearedappMenusUserSorts
	case asuser.EdgeAppUserTemplates:
		return m.clearedappUserTemplates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsUserMutation) ClearEdge(name string) error {
	switch name {
	case asuser.EdgePerson:
		m.ClearPerson()
		return nil
	}
	return fmt.Errorf("unknown AsUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsUserMutation) ResetEdge(name string) error {
	switch name {
	case asuser.EdgePerson:
		m.ResetPerson()
		return nil
	case asuser.EdgeRoles:
		m.ResetRoles()
		return nil
	case asuser.EdgeJobs:
		m.ResetJobs()
		return nil
	case asuser.EdgeUsedapps:
		m.ResetUsedapps()
		return nil
	case asuser.EdgeWorkingDatas:
		m.ResetWorkingDatas()
		return nil
	case asuser.EdgeAgencys:
		m.ResetAgencys()
		return nil
	case asuser.EdgeRoleDistribs:
		m.ResetRoleDistribs()
		return nil
	case asuser.EdgeAppMenusUserSorts:
		m.ResetAppMenusUserSorts()
		return nil
	case asuser.EdgeAppUserTemplates:
		m.ResetAppUserTemplates()
		return nil
	}
	return fmt.Errorf("unknown AsUser edge %s", name)
}

// AsWorkingDataMutation represents an operation that mutates the AsWorkingData nodes in the graph.
type AsWorkingDataMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	app_id         *int64
	addapp_id      *int64
	_type          *int64
	add_type       *int64
	is_deleted     *int64
	addis_deleted  *int64
	status         *int64
	addstatus      *int64
	create_user    *int64
	addcreate_user *int64
	update_user    *int64
	addupdate_user *int64
	create_time    *date.DateTime
	update_time    *date.DateTime
	clearedFields  map[string]struct{}
	user           *int64
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*AsWorkingData, error)
	predicates     []predicate.AsWorkingData
}

var _ ent.Mutation = (*AsWorkingDataMutation)(nil)

// asworkingdataOption allows management of the mutation configuration using functional options.
type asworkingdataOption func(*AsWorkingDataMutation)

// newAsWorkingDataMutation creates new mutation for the AsWorkingData entity.
func newAsWorkingDataMutation(c config, op Op, opts ...asworkingdataOption) *AsWorkingDataMutation {
	m := &AsWorkingDataMutation{
		config:        c,
		op:            op,
		typ:           TypeAsWorkingData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAsWorkingDataID sets the ID field of the mutation.
func withAsWorkingDataID(id int64) asworkingdataOption {
	return func(m *AsWorkingDataMutation) {
		var (
			err   error
			once  sync.Once
			value *AsWorkingData
		)
		m.oldValue = func(ctx context.Context) (*AsWorkingData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AsWorkingData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsWorkingData sets the old AsWorkingData of the mutation.
func withAsWorkingData(node *AsWorkingData) asworkingdataOption {
	return func(m *AsWorkingDataMutation) {
		m.oldValue = func(context.Context) (*AsWorkingData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AsWorkingDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AsWorkingDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AsWorkingData entities.
func (m *AsWorkingDataMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AsWorkingDataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AsWorkingDataMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AsWorkingData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *AsWorkingDataMutation) SetAppID(i int64) {
	m.app_id = &i
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AsWorkingDataMutation) AppID() (r int64, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AsWorkingData entity.
// If the AsWorkingData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsWorkingDataMutation) OldAppID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds i to the "app_id" field.
func (m *AsWorkingDataMutation) AddAppID(i int64) {
	if m.addapp_id != nil {
		*m.addapp_id += i
	} else {
		m.addapp_id = &i
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *AsWorkingDataMutation) AddedAppID() (r int64, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AsWorkingDataMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AsWorkingDataMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AsWorkingDataMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AsWorkingData entity.
// If the AsWorkingData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsWorkingDataMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AsWorkingDataMutation) ResetUserID() {
	m.user = nil
}

// SetType sets the "type" field.
func (m *AsWorkingDataMutation) SetType(i int64) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *AsWorkingDataMutation) GetType() (r int64, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AsWorkingData entity.
// If the AsWorkingData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsWorkingDataMutation) OldType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *AsWorkingDataMutation) AddType(i int64) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *AsWorkingDataMutation) AddedType() (r int64, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *AsWorkingDataMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *AsWorkingDataMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *AsWorkingDataMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the AsWorkingData entity.
// If the AsWorkingData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsWorkingDataMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *AsWorkingDataMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *AsWorkingDataMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *AsWorkingDataMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *AsWorkingDataMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AsWorkingDataMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AsWorkingData entity.
// If the AsWorkingData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsWorkingDataMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AsWorkingDataMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AsWorkingDataMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *AsWorkingDataMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[asworkingdata.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AsWorkingDataMutation) StatusCleared() bool {
	_, ok := m.clearedFields[asworkingdata.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AsWorkingDataMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, asworkingdata.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *AsWorkingDataMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *AsWorkingDataMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the AsWorkingData entity.
// If the AsWorkingData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsWorkingDataMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *AsWorkingDataMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *AsWorkingDataMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *AsWorkingDataMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[asworkingdata.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *AsWorkingDataMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[asworkingdata.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *AsWorkingDataMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, asworkingdata.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *AsWorkingDataMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *AsWorkingDataMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the AsWorkingData entity.
// If the AsWorkingData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsWorkingDataMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *AsWorkingDataMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *AsWorkingDataMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *AsWorkingDataMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[asworkingdata.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *AsWorkingDataMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[asworkingdata.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *AsWorkingDataMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, asworkingdata.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *AsWorkingDataMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AsWorkingDataMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AsWorkingData entity.
// If the AsWorkingData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsWorkingDataMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AsWorkingDataMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[asworkingdata.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AsWorkingDataMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[asworkingdata.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AsWorkingDataMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, asworkingdata.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AsWorkingDataMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AsWorkingDataMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AsWorkingData entity.
// If the AsWorkingData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AsWorkingDataMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AsWorkingDataMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[asworkingdata.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AsWorkingDataMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[asworkingdata.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AsWorkingDataMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, asworkingdata.FieldUpdateTime)
}

// ClearUser clears the "user" edge to the AsUser entity.
func (m *AsWorkingDataMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the AsUser entity was cleared.
func (m *AsWorkingDataMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AsWorkingDataMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AsWorkingDataMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AsWorkingDataMutation builder.
func (m *AsWorkingDataMutation) Where(ps ...predicate.AsWorkingData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AsWorkingDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AsWorkingData).
func (m *AsWorkingDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AsWorkingDataMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.app_id != nil {
		fields = append(fields, asworkingdata.FieldAppID)
	}
	if m.user != nil {
		fields = append(fields, asworkingdata.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, asworkingdata.FieldType)
	}
	if m.is_deleted != nil {
		fields = append(fields, asworkingdata.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, asworkingdata.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, asworkingdata.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, asworkingdata.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, asworkingdata.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, asworkingdata.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AsWorkingDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asworkingdata.FieldAppID:
		return m.AppID()
	case asworkingdata.FieldUserID:
		return m.UserID()
	case asworkingdata.FieldType:
		return m.GetType()
	case asworkingdata.FieldIsDeleted:
		return m.IsDeleted()
	case asworkingdata.FieldStatus:
		return m.Status()
	case asworkingdata.FieldCreateUser:
		return m.CreateUser()
	case asworkingdata.FieldUpdateUser:
		return m.UpdateUser()
	case asworkingdata.FieldCreateTime:
		return m.CreateTime()
	case asworkingdata.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AsWorkingDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asworkingdata.FieldAppID:
		return m.OldAppID(ctx)
	case asworkingdata.FieldUserID:
		return m.OldUserID(ctx)
	case asworkingdata.FieldType:
		return m.OldType(ctx)
	case asworkingdata.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case asworkingdata.FieldStatus:
		return m.OldStatus(ctx)
	case asworkingdata.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case asworkingdata.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case asworkingdata.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case asworkingdata.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AsWorkingData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsWorkingDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asworkingdata.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case asworkingdata.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case asworkingdata.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case asworkingdata.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case asworkingdata.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case asworkingdata.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case asworkingdata.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case asworkingdata.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case asworkingdata.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AsWorkingData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AsWorkingDataMutation) AddedFields() []string {
	var fields []string
	if m.addapp_id != nil {
		fields = append(fields, asworkingdata.FieldAppID)
	}
	if m.add_type != nil {
		fields = append(fields, asworkingdata.FieldType)
	}
	if m.addis_deleted != nil {
		fields = append(fields, asworkingdata.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, asworkingdata.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, asworkingdata.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, asworkingdata.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AsWorkingDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asworkingdata.FieldAppID:
		return m.AddedAppID()
	case asworkingdata.FieldType:
		return m.AddedType()
	case asworkingdata.FieldIsDeleted:
		return m.AddedIsDeleted()
	case asworkingdata.FieldStatus:
		return m.AddedStatus()
	case asworkingdata.FieldCreateUser:
		return m.AddedCreateUser()
	case asworkingdata.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AsWorkingDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asworkingdata.FieldAppID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	case asworkingdata.FieldType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case asworkingdata.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case asworkingdata.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case asworkingdata.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case asworkingdata.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown AsWorkingData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AsWorkingDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asworkingdata.FieldStatus) {
		fields = append(fields, asworkingdata.FieldStatus)
	}
	if m.FieldCleared(asworkingdata.FieldCreateUser) {
		fields = append(fields, asworkingdata.FieldCreateUser)
	}
	if m.FieldCleared(asworkingdata.FieldUpdateUser) {
		fields = append(fields, asworkingdata.FieldUpdateUser)
	}
	if m.FieldCleared(asworkingdata.FieldCreateTime) {
		fields = append(fields, asworkingdata.FieldCreateTime)
	}
	if m.FieldCleared(asworkingdata.FieldUpdateTime) {
		fields = append(fields, asworkingdata.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AsWorkingDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AsWorkingDataMutation) ClearField(name string) error {
	switch name {
	case asworkingdata.FieldStatus:
		m.ClearStatus()
		return nil
	case asworkingdata.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case asworkingdata.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case asworkingdata.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case asworkingdata.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsWorkingData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AsWorkingDataMutation) ResetField(name string) error {
	switch name {
	case asworkingdata.FieldAppID:
		m.ResetAppID()
		return nil
	case asworkingdata.FieldUserID:
		m.ResetUserID()
		return nil
	case asworkingdata.FieldType:
		m.ResetType()
		return nil
	case asworkingdata.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case asworkingdata.FieldStatus:
		m.ResetStatus()
		return nil
	case asworkingdata.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case asworkingdata.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case asworkingdata.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case asworkingdata.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AsWorkingData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AsWorkingDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, asworkingdata.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AsWorkingDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asworkingdata.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AsWorkingDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AsWorkingDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AsWorkingDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, asworkingdata.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AsWorkingDataMutation) EdgeCleared(name string) bool {
	switch name {
	case asworkingdata.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AsWorkingDataMutation) ClearEdge(name string) error {
	switch name {
	case asworkingdata.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AsWorkingData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AsWorkingDataMutation) ResetEdge(name string) error {
	switch name {
	case asworkingdata.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AsWorkingData edge %s", name)
}

// BaseinfoadministrativeareaallMutation represents an operation that mutates the Baseinfoadministrativeareaall nodes in the graph.
type BaseinfoadministrativeareaallMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	code             *string
	name             *string
	province         *string
	city             *string
	area             *string
	town             *string
	all_name         *string
	_type            *int32
	add_type         *int32
	ts_version       *int32
	addts_version    *int32
	is_deleted       *int64
	addis_deleted    *int64
	status           *int64
	addstatus        *int64
	create_user      *int64
	addcreate_user   *int64
	update_user      *int64
	addupdate_user   *int64
	create_time      *date.DateTime
	update_time      *date.DateTime
	clearedFields    map[string]struct{}
	parentx          *int64
	clearedparentx   bool
	childrens        map[int64]struct{}
	removedchildrens map[int64]struct{}
	clearedchildrens bool
	done             bool
	oldValue         func(context.Context) (*Baseinfoadministrativeareaall, error)
	predicates       []predicate.Baseinfoadministrativeareaall
}

var _ ent.Mutation = (*BaseinfoadministrativeareaallMutation)(nil)

// baseinfoadministrativeareaallOption allows management of the mutation configuration using functional options.
type baseinfoadministrativeareaallOption func(*BaseinfoadministrativeareaallMutation)

// newBaseinfoadministrativeareaallMutation creates new mutation for the Baseinfoadministrativeareaall entity.
func newBaseinfoadministrativeareaallMutation(c config, op Op, opts ...baseinfoadministrativeareaallOption) *BaseinfoadministrativeareaallMutation {
	m := &BaseinfoadministrativeareaallMutation{
		config:        c,
		op:            op,
		typ:           TypeBaseinfoadministrativeareaall,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaseinfoadministrativeareaallID sets the ID field of the mutation.
func withBaseinfoadministrativeareaallID(id int64) baseinfoadministrativeareaallOption {
	return func(m *BaseinfoadministrativeareaallMutation) {
		var (
			err   error
			once  sync.Once
			value *Baseinfoadministrativeareaall
		)
		m.oldValue = func(ctx context.Context) (*Baseinfoadministrativeareaall, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Baseinfoadministrativeareaall.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaseinfoadministrativeareaall sets the old Baseinfoadministrativeareaall of the mutation.
func withBaseinfoadministrativeareaall(node *Baseinfoadministrativeareaall) baseinfoadministrativeareaallOption {
	return func(m *BaseinfoadministrativeareaallMutation) {
		m.oldValue = func(context.Context) (*Baseinfoadministrativeareaall, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaseinfoadministrativeareaallMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaseinfoadministrativeareaallMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("schema: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Baseinfoadministrativeareaall entities.
func (m *BaseinfoadministrativeareaallMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaseinfoadministrativeareaallMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaseinfoadministrativeareaallMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Baseinfoadministrativeareaall.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPid sets the "pid" field.
func (m *BaseinfoadministrativeareaallMutation) SetPid(i int64) {
	m.parentx = &i
}

// Pid returns the value of the "pid" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) Pid() (r int64, exists bool) {
	v := m.parentx
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldPid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// ClearPid clears the value of the "pid" field.
func (m *BaseinfoadministrativeareaallMutation) ClearPid() {
	m.parentx = nil
	m.clearedFields[baseinfoadministrativeareaall.FieldPid] = struct{}{}
}

// PidCleared returns if the "pid" field was cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) PidCleared() bool {
	_, ok := m.clearedFields[baseinfoadministrativeareaall.FieldPid]
	return ok
}

// ResetPid resets all changes to the "pid" field.
func (m *BaseinfoadministrativeareaallMutation) ResetPid() {
	m.parentx = nil
	delete(m.clearedFields, baseinfoadministrativeareaall.FieldPid)
}

// SetCode sets the "code" field.
func (m *BaseinfoadministrativeareaallMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *BaseinfoadministrativeareaallMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *BaseinfoadministrativeareaallMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BaseinfoadministrativeareaallMutation) ResetName() {
	m.name = nil
}

// SetProvince sets the "province" field.
func (m *BaseinfoadministrativeareaallMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *BaseinfoadministrativeareaallMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *BaseinfoadministrativeareaallMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *BaseinfoadministrativeareaallMutation) ResetCity() {
	m.city = nil
}

// SetArea sets the "area" field.
func (m *BaseinfoadministrativeareaallMutation) SetArea(s string) {
	m.area = &s
}

// Area returns the value of the "area" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) Area() (r string, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// ResetArea resets all changes to the "area" field.
func (m *BaseinfoadministrativeareaallMutation) ResetArea() {
	m.area = nil
}

// SetTown sets the "town" field.
func (m *BaseinfoadministrativeareaallMutation) SetTown(s string) {
	m.town = &s
}

// Town returns the value of the "town" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) Town() (r string, exists bool) {
	v := m.town
	if v == nil {
		return
	}
	return *v, true
}

// OldTown returns the old "town" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldTown(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTown: %w", err)
	}
	return oldValue.Town, nil
}

// ResetTown resets all changes to the "town" field.
func (m *BaseinfoadministrativeareaallMutation) ResetTown() {
	m.town = nil
}

// SetAllName sets the "all_name" field.
func (m *BaseinfoadministrativeareaallMutation) SetAllName(s string) {
	m.all_name = &s
}

// AllName returns the value of the "all_name" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) AllName() (r string, exists bool) {
	v := m.all_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAllName returns the old "all_name" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldAllName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllName: %w", err)
	}
	return oldValue.AllName, nil
}

// ResetAllName resets all changes to the "all_name" field.
func (m *BaseinfoadministrativeareaallMutation) ResetAllName() {
	m.all_name = nil
}

// SetType sets the "type" field.
func (m *BaseinfoadministrativeareaallMutation) SetType(i int32) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) GetType() (r int32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *BaseinfoadministrativeareaallMutation) AddType(i int32) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *BaseinfoadministrativeareaallMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *BaseinfoadministrativeareaallMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[baseinfoadministrativeareaall.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) TypeCleared() bool {
	_, ok := m.clearedFields[baseinfoadministrativeareaall.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *BaseinfoadministrativeareaallMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, baseinfoadministrativeareaall.FieldType)
}

// SetTsVersion sets the "ts_version" field.
func (m *BaseinfoadministrativeareaallMutation) SetTsVersion(i int32) {
	m.ts_version = &i
	m.addts_version = nil
}

// TsVersion returns the value of the "ts_version" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) TsVersion() (r int32, exists bool) {
	v := m.ts_version
	if v == nil {
		return
	}
	return *v, true
}

// OldTsVersion returns the old "ts_version" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldTsVersion(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTsVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTsVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTsVersion: %w", err)
	}
	return oldValue.TsVersion, nil
}

// AddTsVersion adds i to the "ts_version" field.
func (m *BaseinfoadministrativeareaallMutation) AddTsVersion(i int32) {
	if m.addts_version != nil {
		*m.addts_version += i
	} else {
		m.addts_version = &i
	}
}

// AddedTsVersion returns the value that was added to the "ts_version" field in this mutation.
func (m *BaseinfoadministrativeareaallMutation) AddedTsVersion() (r int32, exists bool) {
	v := m.addts_version
	if v == nil {
		return
	}
	return *v, true
}

// ClearTsVersion clears the value of the "ts_version" field.
func (m *BaseinfoadministrativeareaallMutation) ClearTsVersion() {
	m.ts_version = nil
	m.addts_version = nil
	m.clearedFields[baseinfoadministrativeareaall.FieldTsVersion] = struct{}{}
}

// TsVersionCleared returns if the "ts_version" field was cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) TsVersionCleared() bool {
	_, ok := m.clearedFields[baseinfoadministrativeareaall.FieldTsVersion]
	return ok
}

// ResetTsVersion resets all changes to the "ts_version" field.
func (m *BaseinfoadministrativeareaallMutation) ResetTsVersion() {
	m.ts_version = nil
	m.addts_version = nil
	delete(m.clearedFields, baseinfoadministrativeareaall.FieldTsVersion)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *BaseinfoadministrativeareaallMutation) SetIsDeleted(i int64) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) IsDeleted() (r int64, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldIsDeleted(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *BaseinfoadministrativeareaallMutation) AddIsDeleted(i int64) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *BaseinfoadministrativeareaallMutation) AddedIsDeleted() (r int64, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *BaseinfoadministrativeareaallMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetStatus sets the "status" field.
func (m *BaseinfoadministrativeareaallMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BaseinfoadministrativeareaallMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BaseinfoadministrativeareaallMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *BaseinfoadministrativeareaallMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[baseinfoadministrativeareaall.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) StatusCleared() bool {
	_, ok := m.clearedFields[baseinfoadministrativeareaall.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *BaseinfoadministrativeareaallMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, baseinfoadministrativeareaall.FieldStatus)
}

// SetCreateUser sets the "create_user" field.
func (m *BaseinfoadministrativeareaallMutation) SetCreateUser(i int64) {
	m.create_user = &i
	m.addcreate_user = nil
}

// CreateUser returns the value of the "create_user" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) CreateUser() (r int64, exists bool) {
	v := m.create_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateUser returns the old "create_user" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldCreateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateUser: %w", err)
	}
	return oldValue.CreateUser, nil
}

// AddCreateUser adds i to the "create_user" field.
func (m *BaseinfoadministrativeareaallMutation) AddCreateUser(i int64) {
	if m.addcreate_user != nil {
		*m.addcreate_user += i
	} else {
		m.addcreate_user = &i
	}
}

// AddedCreateUser returns the value that was added to the "create_user" field in this mutation.
func (m *BaseinfoadministrativeareaallMutation) AddedCreateUser() (r int64, exists bool) {
	v := m.addcreate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateUser clears the value of the "create_user" field.
func (m *BaseinfoadministrativeareaallMutation) ClearCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	m.clearedFields[baseinfoadministrativeareaall.FieldCreateUser] = struct{}{}
}

// CreateUserCleared returns if the "create_user" field was cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) CreateUserCleared() bool {
	_, ok := m.clearedFields[baseinfoadministrativeareaall.FieldCreateUser]
	return ok
}

// ResetCreateUser resets all changes to the "create_user" field.
func (m *BaseinfoadministrativeareaallMutation) ResetCreateUser() {
	m.create_user = nil
	m.addcreate_user = nil
	delete(m.clearedFields, baseinfoadministrativeareaall.FieldCreateUser)
}

// SetUpdateUser sets the "update_user" field.
func (m *BaseinfoadministrativeareaallMutation) SetUpdateUser(i int64) {
	m.update_user = &i
	m.addupdate_user = nil
}

// UpdateUser returns the value of the "update_user" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) UpdateUser() (r int64, exists bool) {
	v := m.update_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateUser returns the old "update_user" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldUpdateUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateUser: %w", err)
	}
	return oldValue.UpdateUser, nil
}

// AddUpdateUser adds i to the "update_user" field.
func (m *BaseinfoadministrativeareaallMutation) AddUpdateUser(i int64) {
	if m.addupdate_user != nil {
		*m.addupdate_user += i
	} else {
		m.addupdate_user = &i
	}
}

// AddedUpdateUser returns the value that was added to the "update_user" field in this mutation.
func (m *BaseinfoadministrativeareaallMutation) AddedUpdateUser() (r int64, exists bool) {
	v := m.addupdate_user
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateUser clears the value of the "update_user" field.
func (m *BaseinfoadministrativeareaallMutation) ClearUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	m.clearedFields[baseinfoadministrativeareaall.FieldUpdateUser] = struct{}{}
}

// UpdateUserCleared returns if the "update_user" field was cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) UpdateUserCleared() bool {
	_, ok := m.clearedFields[baseinfoadministrativeareaall.FieldUpdateUser]
	return ok
}

// ResetUpdateUser resets all changes to the "update_user" field.
func (m *BaseinfoadministrativeareaallMutation) ResetUpdateUser() {
	m.update_user = nil
	m.addupdate_user = nil
	delete(m.clearedFields, baseinfoadministrativeareaall.FieldUpdateUser)
}

// SetCreateTime sets the "create_time" field.
func (m *BaseinfoadministrativeareaallMutation) SetCreateTime(dt date.DateTime) {
	m.create_time = &dt
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) CreateTime() (r date.DateTime, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldCreateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *BaseinfoadministrativeareaallMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[baseinfoadministrativeareaall.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[baseinfoadministrativeareaall.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BaseinfoadministrativeareaallMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, baseinfoadministrativeareaall.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *BaseinfoadministrativeareaallMutation) SetUpdateTime(dt date.DateTime) {
	m.update_time = &dt
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BaseinfoadministrativeareaallMutation) UpdateTime() (r date.DateTime, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Baseinfoadministrativeareaall entity.
// If the Baseinfoadministrativeareaall object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaseinfoadministrativeareaallMutation) OldUpdateTime(ctx context.Context) (v date.DateTime, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *BaseinfoadministrativeareaallMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[baseinfoadministrativeareaall.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[baseinfoadministrativeareaall.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BaseinfoadministrativeareaallMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, baseinfoadministrativeareaall.FieldUpdateTime)
}

// SetParentxID sets the "parentx" edge to the Baseinfoadministrativeareaall entity by id.
func (m *BaseinfoadministrativeareaallMutation) SetParentxID(id int64) {
	m.parentx = &id
}

// ClearParentx clears the "parentx" edge to the Baseinfoadministrativeareaall entity.
func (m *BaseinfoadministrativeareaallMutation) ClearParentx() {
	m.clearedparentx = true
}

// ParentxCleared reports if the "parentx" edge to the Baseinfoadministrativeareaall entity was cleared.
func (m *BaseinfoadministrativeareaallMutation) ParentxCleared() bool {
	return m.PidCleared() || m.clearedparentx
}

// ParentxID returns the "parentx" edge ID in the mutation.
func (m *BaseinfoadministrativeareaallMutation) ParentxID() (id int64, exists bool) {
	if m.parentx != nil {
		return *m.parentx, true
	}
	return
}

// ParentxIDs returns the "parentx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentxID instead. It exists only for internal usage by the builders.
func (m *BaseinfoadministrativeareaallMutation) ParentxIDs() (ids []int64) {
	if id := m.parentx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentx resets all changes to the "parentx" edge.
func (m *BaseinfoadministrativeareaallMutation) ResetParentx() {
	m.parentx = nil
	m.clearedparentx = false
}

// AddChildrenIDs adds the "childrens" edge to the Baseinfoadministrativeareaall entity by ids.
func (m *BaseinfoadministrativeareaallMutation) AddChildrenIDs(ids ...int64) {
	if m.childrens == nil {
		m.childrens = make(map[int64]struct{})
	}
	for i := range ids {
		m.childrens[ids[i]] = struct{}{}
	}
}

// ClearChildrens clears the "childrens" edge to the Baseinfoadministrativeareaall entity.
func (m *BaseinfoadministrativeareaallMutation) ClearChildrens() {
	m.clearedchildrens = true
}

// ChildrensCleared reports if the "childrens" edge to the Baseinfoadministrativeareaall entity was cleared.
func (m *BaseinfoadministrativeareaallMutation) ChildrensCleared() bool {
	return m.clearedchildrens
}

// RemoveChildrenIDs removes the "childrens" edge to the Baseinfoadministrativeareaall entity by IDs.
func (m *BaseinfoadministrativeareaallMutation) RemoveChildrenIDs(ids ...int64) {
	if m.removedchildrens == nil {
		m.removedchildrens = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.childrens, ids[i])
		m.removedchildrens[ids[i]] = struct{}{}
	}
}

// RemovedChildrens returns the removed IDs of the "childrens" edge to the Baseinfoadministrativeareaall entity.
func (m *BaseinfoadministrativeareaallMutation) RemovedChildrensIDs() (ids []int64) {
	for id := range m.removedchildrens {
		ids = append(ids, id)
	}
	return
}

// ChildrensIDs returns the "childrens" edge IDs in the mutation.
func (m *BaseinfoadministrativeareaallMutation) ChildrensIDs() (ids []int64) {
	for id := range m.childrens {
		ids = append(ids, id)
	}
	return
}

// ResetChildrens resets all changes to the "childrens" edge.
func (m *BaseinfoadministrativeareaallMutation) ResetChildrens() {
	m.childrens = nil
	m.clearedchildrens = false
	m.removedchildrens = nil
}

// Where appends a list predicates to the BaseinfoadministrativeareaallMutation builder.
func (m *BaseinfoadministrativeareaallMutation) Where(ps ...predicate.Baseinfoadministrativeareaall) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaseinfoadministrativeareaallMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Baseinfoadministrativeareaall).
func (m *BaseinfoadministrativeareaallMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaseinfoadministrativeareaallMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.parentx != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldPid)
	}
	if m.code != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldName)
	}
	if m.province != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldCity)
	}
	if m.area != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldArea)
	}
	if m.town != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldTown)
	}
	if m.all_name != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldAllName)
	}
	if m._type != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldType)
	}
	if m.ts_version != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldTsVersion)
	}
	if m.is_deleted != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldIsDeleted)
	}
	if m.status != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldStatus)
	}
	if m.create_user != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldCreateUser)
	}
	if m.update_user != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldUpdateUser)
	}
	if m.create_time != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaseinfoadministrativeareaallMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baseinfoadministrativeareaall.FieldPid:
		return m.Pid()
	case baseinfoadministrativeareaall.FieldCode:
		return m.Code()
	case baseinfoadministrativeareaall.FieldName:
		return m.Name()
	case baseinfoadministrativeareaall.FieldProvince:
		return m.Province()
	case baseinfoadministrativeareaall.FieldCity:
		return m.City()
	case baseinfoadministrativeareaall.FieldArea:
		return m.Area()
	case baseinfoadministrativeareaall.FieldTown:
		return m.Town()
	case baseinfoadministrativeareaall.FieldAllName:
		return m.AllName()
	case baseinfoadministrativeareaall.FieldType:
		return m.GetType()
	case baseinfoadministrativeareaall.FieldTsVersion:
		return m.TsVersion()
	case baseinfoadministrativeareaall.FieldIsDeleted:
		return m.IsDeleted()
	case baseinfoadministrativeareaall.FieldStatus:
		return m.Status()
	case baseinfoadministrativeareaall.FieldCreateUser:
		return m.CreateUser()
	case baseinfoadministrativeareaall.FieldUpdateUser:
		return m.UpdateUser()
	case baseinfoadministrativeareaall.FieldCreateTime:
		return m.CreateTime()
	case baseinfoadministrativeareaall.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaseinfoadministrativeareaallMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baseinfoadministrativeareaall.FieldPid:
		return m.OldPid(ctx)
	case baseinfoadministrativeareaall.FieldCode:
		return m.OldCode(ctx)
	case baseinfoadministrativeareaall.FieldName:
		return m.OldName(ctx)
	case baseinfoadministrativeareaall.FieldProvince:
		return m.OldProvince(ctx)
	case baseinfoadministrativeareaall.FieldCity:
		return m.OldCity(ctx)
	case baseinfoadministrativeareaall.FieldArea:
		return m.OldArea(ctx)
	case baseinfoadministrativeareaall.FieldTown:
		return m.OldTown(ctx)
	case baseinfoadministrativeareaall.FieldAllName:
		return m.OldAllName(ctx)
	case baseinfoadministrativeareaall.FieldType:
		return m.OldType(ctx)
	case baseinfoadministrativeareaall.FieldTsVersion:
		return m.OldTsVersion(ctx)
	case baseinfoadministrativeareaall.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case baseinfoadministrativeareaall.FieldStatus:
		return m.OldStatus(ctx)
	case baseinfoadministrativeareaall.FieldCreateUser:
		return m.OldCreateUser(ctx)
	case baseinfoadministrativeareaall.FieldUpdateUser:
		return m.OldUpdateUser(ctx)
	case baseinfoadministrativeareaall.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case baseinfoadministrativeareaall.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Baseinfoadministrativeareaall field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaseinfoadministrativeareaallMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baseinfoadministrativeareaall.FieldPid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case baseinfoadministrativeareaall.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case baseinfoadministrativeareaall.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case baseinfoadministrativeareaall.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case baseinfoadministrativeareaall.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case baseinfoadministrativeareaall.FieldArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case baseinfoadministrativeareaall.FieldTown:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTown(v)
		return nil
	case baseinfoadministrativeareaall.FieldAllName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllName(v)
		return nil
	case baseinfoadministrativeareaall.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case baseinfoadministrativeareaall.FieldTsVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTsVersion(v)
		return nil
	case baseinfoadministrativeareaall.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case baseinfoadministrativeareaall.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case baseinfoadministrativeareaall.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateUser(v)
		return nil
	case baseinfoadministrativeareaall.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateUser(v)
		return nil
	case baseinfoadministrativeareaall.FieldCreateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case baseinfoadministrativeareaall.FieldUpdateTime:
		v, ok := value.(date.DateTime)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Baseinfoadministrativeareaall field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaseinfoadministrativeareaallMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldType)
	}
	if m.addts_version != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldTsVersion)
	}
	if m.addis_deleted != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldIsDeleted)
	}
	if m.addstatus != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldStatus)
	}
	if m.addcreate_user != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldCreateUser)
	}
	if m.addupdate_user != nil {
		fields = append(fields, baseinfoadministrativeareaall.FieldUpdateUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaseinfoadministrativeareaallMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case baseinfoadministrativeareaall.FieldType:
		return m.AddedType()
	case baseinfoadministrativeareaall.FieldTsVersion:
		return m.AddedTsVersion()
	case baseinfoadministrativeareaall.FieldIsDeleted:
		return m.AddedIsDeleted()
	case baseinfoadministrativeareaall.FieldStatus:
		return m.AddedStatus()
	case baseinfoadministrativeareaall.FieldCreateUser:
		return m.AddedCreateUser()
	case baseinfoadministrativeareaall.FieldUpdateUser:
		return m.AddedUpdateUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaseinfoadministrativeareaallMutation) AddField(name string, value ent.Value) error {
	switch name {
	case baseinfoadministrativeareaall.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case baseinfoadministrativeareaall.FieldTsVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTsVersion(v)
		return nil
	case baseinfoadministrativeareaall.FieldIsDeleted:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case baseinfoadministrativeareaall.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case baseinfoadministrativeareaall.FieldCreateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateUser(v)
		return nil
	case baseinfoadministrativeareaall.FieldUpdateUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateUser(v)
		return nil
	}
	return fmt.Errorf("unknown Baseinfoadministrativeareaall numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaseinfoadministrativeareaallMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(baseinfoadministrativeareaall.FieldPid) {
		fields = append(fields, baseinfoadministrativeareaall.FieldPid)
	}
	if m.FieldCleared(baseinfoadministrativeareaall.FieldType) {
		fields = append(fields, baseinfoadministrativeareaall.FieldType)
	}
	if m.FieldCleared(baseinfoadministrativeareaall.FieldTsVersion) {
		fields = append(fields, baseinfoadministrativeareaall.FieldTsVersion)
	}
	if m.FieldCleared(baseinfoadministrativeareaall.FieldStatus) {
		fields = append(fields, baseinfoadministrativeareaall.FieldStatus)
	}
	if m.FieldCleared(baseinfoadministrativeareaall.FieldCreateUser) {
		fields = append(fields, baseinfoadministrativeareaall.FieldCreateUser)
	}
	if m.FieldCleared(baseinfoadministrativeareaall.FieldUpdateUser) {
		fields = append(fields, baseinfoadministrativeareaall.FieldUpdateUser)
	}
	if m.FieldCleared(baseinfoadministrativeareaall.FieldCreateTime) {
		fields = append(fields, baseinfoadministrativeareaall.FieldCreateTime)
	}
	if m.FieldCleared(baseinfoadministrativeareaall.FieldUpdateTime) {
		fields = append(fields, baseinfoadministrativeareaall.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaseinfoadministrativeareaallMutation) ClearField(name string) error {
	switch name {
	case baseinfoadministrativeareaall.FieldPid:
		m.ClearPid()
		return nil
	case baseinfoadministrativeareaall.FieldType:
		m.ClearType()
		return nil
	case baseinfoadministrativeareaall.FieldTsVersion:
		m.ClearTsVersion()
		return nil
	case baseinfoadministrativeareaall.FieldStatus:
		m.ClearStatus()
		return nil
	case baseinfoadministrativeareaall.FieldCreateUser:
		m.ClearCreateUser()
		return nil
	case baseinfoadministrativeareaall.FieldUpdateUser:
		m.ClearUpdateUser()
		return nil
	case baseinfoadministrativeareaall.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case baseinfoadministrativeareaall.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Baseinfoadministrativeareaall nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaseinfoadministrativeareaallMutation) ResetField(name string) error {
	switch name {
	case baseinfoadministrativeareaall.FieldPid:
		m.ResetPid()
		return nil
	case baseinfoadministrativeareaall.FieldCode:
		m.ResetCode()
		return nil
	case baseinfoadministrativeareaall.FieldName:
		m.ResetName()
		return nil
	case baseinfoadministrativeareaall.FieldProvince:
		m.ResetProvince()
		return nil
	case baseinfoadministrativeareaall.FieldCity:
		m.ResetCity()
		return nil
	case baseinfoadministrativeareaall.FieldArea:
		m.ResetArea()
		return nil
	case baseinfoadministrativeareaall.FieldTown:
		m.ResetTown()
		return nil
	case baseinfoadministrativeareaall.FieldAllName:
		m.ResetAllName()
		return nil
	case baseinfoadministrativeareaall.FieldType:
		m.ResetType()
		return nil
	case baseinfoadministrativeareaall.FieldTsVersion:
		m.ResetTsVersion()
		return nil
	case baseinfoadministrativeareaall.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case baseinfoadministrativeareaall.FieldStatus:
		m.ResetStatus()
		return nil
	case baseinfoadministrativeareaall.FieldCreateUser:
		m.ResetCreateUser()
		return nil
	case baseinfoadministrativeareaall.FieldUpdateUser:
		m.ResetUpdateUser()
		return nil
	case baseinfoadministrativeareaall.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case baseinfoadministrativeareaall.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Baseinfoadministrativeareaall field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaseinfoadministrativeareaallMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parentx != nil {
		edges = append(edges, baseinfoadministrativeareaall.EdgeParentx)
	}
	if m.childrens != nil {
		edges = append(edges, baseinfoadministrativeareaall.EdgeChildrens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaseinfoadministrativeareaallMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baseinfoadministrativeareaall.EdgeParentx:
		if id := m.parentx; id != nil {
			return []ent.Value{*id}
		}
	case baseinfoadministrativeareaall.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.childrens))
		for id := range m.childrens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaseinfoadministrativeareaallMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchildrens != nil {
		edges = append(edges, baseinfoadministrativeareaall.EdgeChildrens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaseinfoadministrativeareaallMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case baseinfoadministrativeareaall.EdgeChildrens:
		ids := make([]ent.Value, 0, len(m.removedchildrens))
		for id := range m.removedchildrens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparentx {
		edges = append(edges, baseinfoadministrativeareaall.EdgeParentx)
	}
	if m.clearedchildrens {
		edges = append(edges, baseinfoadministrativeareaall.EdgeChildrens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaseinfoadministrativeareaallMutation) EdgeCleared(name string) bool {
	switch name {
	case baseinfoadministrativeareaall.EdgeParentx:
		return m.clearedparentx
	case baseinfoadministrativeareaall.EdgeChildrens:
		return m.clearedchildrens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaseinfoadministrativeareaallMutation) ClearEdge(name string) error {
	switch name {
	case baseinfoadministrativeareaall.EdgeParentx:
		m.ClearParentx()
		return nil
	}
	return fmt.Errorf("unknown Baseinfoadministrativeareaall unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaseinfoadministrativeareaallMutation) ResetEdge(name string) error {
	switch name {
	case baseinfoadministrativeareaall.EdgeParentx:
		m.ResetParentx()
		return nil
	case baseinfoadministrativeareaall.EdgeChildrens:
		m.ResetChildrens()
		return nil
	}
	return fmt.Errorf("unknown Baseinfoadministrativeareaall edge %s", name)
}
